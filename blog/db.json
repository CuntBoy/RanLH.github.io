{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/uploads/wechat-qcode.jpg","path":"uploads/wechat-qcode.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"9198ffd83e0d8aa2ea2bb40dea5654d0fa6523a4","modified":1658796516843},{"_id":"source/_posts/2021年终总结.md","hash":"5bfd785b6da1fdad1a2d06ddc2f9b808847e99f6","modified":1658796516845},{"_id":"source/_posts/Bucket-Sort.md","hash":"3ba1f3f43800fa36115dca88bd2397c136497c28","modified":1658796516846},{"_id":"source/_posts/Bug奇遇记-uint16-t.md","hash":"c30320a084223b543544c126a81c9c6204a6bf3b","modified":1658796516847},{"_id":"source/_posts/Dynamic-drawing-of-osg-vertex-buffer-objects.md","hash":"b91e465a5b9bed61c4fb2c2cd467136cb6575e44","modified":1658796516848},{"_id":"source/_posts/Games202-ShadowMap.md","hash":"12f2fc5bf1df2537302c20c210541e5a385f1940","modified":1658796516849},{"_id":"source/_posts/Git常用命令-上.md","hash":"12cd76df62102dbf41ab18f64a41be73d75279cd","modified":1658796516851},{"_id":"source/_posts/Heap.md","hash":"5bd91b771738d1dc43736424a51ab22746971c4d","modified":1658796516852},{"_id":"source/_posts/Multi-KeyWord-Sort.md","hash":"064a74da7b4fab2e79731e7859826356bf2f3b0b","modified":1658796516853},{"_id":"source/_posts/OSG-HUD.md","hash":"0191ebda309fe95b3ce285bf8482d7e1c1367b6f","modified":1658796516855},{"_id":"source/_posts/OSG踩坑记-模型共享-模型颜色修改.md","hash":"44edd3c59c004ed4c451640cc2abf841b617ae23","modified":1658796516856},{"_id":"source/_posts/OSG踩坑记-默认光源.md","hash":"fed998864a3a510c5c4176e4ca857645bbe2d79d","modified":1658796516857},{"_id":"source/_posts/Physical-Sort.md","hash":"e01ab88636078f9e30366265e02ab30904422ac4","modified":1658796516859},{"_id":"source/_posts/QuickSort.md","hash":"45914277a7ce07b50db3b17c2af2fb0cf4621e21","modified":1658796516860},{"_id":"source/_posts/Selection-sort.md","hash":"27bf32b78858504ca56ee9fc0e6e5af4b71d4c60","modified":1658796516861},{"_id":"source/_posts/Shell-Sort.md","hash":"61f2a4b0047edfce5bc2bf7b98b779b7c39f6c19","modified":1658796516862},{"_id":"source/_posts/Table-Sort.md","hash":"da41e33ec3b59d9e1c5edcee6c7af86e8b7835c0","modified":1658796516864},{"_id":"source/_posts/baozi.md","hash":"6e6318e27d3ec7068353ec3a10f20ab2cf1e8d2c","modified":1658796516865},{"_id":"source/_posts/sort-bubble-insertion.md","hash":"dcbb77153b1179a4fe53a33693f2e9d0de4eda94","modified":1658796516866},{"_id":"source/_posts/归并排序.md","hash":"1da2a41b4a4be478f3ef5dafd30156a96a86da0d","modified":1658796516867},{"_id":"source/_posts/微信多开.md","hash":"8c0398737fdb894f66fd4b488a6958204c6de0f7","modified":1658796516869},{"_id":"source/_posts/记一次总结.md","hash":"34185aa15a207f83aa5fdd2deac40c8354738e7c","modified":1658796516870},{"_id":"source/_posts/记一次面试-1.md","hash":"b822a8b86c42c7aa5beb29cb618e139864755f93","modified":1658796997048},{"_id":"source/_posts/记一次面试.md","hash":"88ff765d5ee87f29f3a9872cab1704b810dd78e8","modified":1658796516873},{"_id":"source/_posts/迟到的毕业总结.md","hash":"a44bf0651ec40c83c015cff3770325edc7761677","modified":1658796516875},{"_id":"source/about/index.md","hash":"6bb81b3f8277110633a932eb61e5a499581b7fac","modified":1658796516877},{"_id":"source/categories/index.md","hash":"236083d68d8025f61f92d0e0b4e204b0ef153490","modified":1658796516878},{"_id":"source/home/index.md","hash":"bc87602b4927ef3728ae4c8a1b5ef29679bff7f8","modified":1658796516880},{"_id":"source/tags/index.md","hash":"45274de8daf24abfab25dd6babb51ab7b579a5db","modified":1658796516882},{"_id":"source/uploads/wechat-qcode.jpg","hash":"5e32da2bbb5828e9050d948db5f9f36731ecfccc","modified":1658796516884},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1658802342417},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1658802342419},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1658802342424},{"_id":"themes/next/.gitignore","hash":"417520c4dbbeab9c7e3ab10d944da0886366a0ee","modified":1658802342475},{"_id":"themes/next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":1658802342482},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1658802342477},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1658802342479},{"_id":"themes/next/_config.yml","hash":"ca90890962fd3d003f68cc710e3dc1f9161e5ce5","modified":1658802342485},{"_id":"themes/next/_vendors.yml","hash":"4a00898e7f4e08e6b42604a33dd926ba57e11939","modified":1658802342488},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1658802342490},{"_id":"themes/next/package.json","hash":"ed04579cb05e09d83946d898edcca4677897e328","modified":1658802342733},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1658802342734},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1658802342428},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1658802342431},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1658802342433},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"330656d93b6c03df9fb1f2f0e3534c971969473b","modified":1658802342436},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1658802342449},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1658802342451},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1658802342455},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1658802342457},{"_id":"themes/next/.github/labeler.yml","hash":"5c4bc2bd561e6d9b33ee118cc12218c5de46f72d","modified":1658802342458},{"_id":"themes/next/.github/release-drafter.yml","hash":"423275ec021104b263cd88776936a8c8d6872b66","modified":1658802342460},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1658802342493},{"_id":"themes/next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1658802342495},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1658802342501},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1658802342513},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1658802342516},{"_id":"themes/next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":1658802342518},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1658802342520},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1658802342521},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1658802342524},{"_id":"themes/next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":1658802342525},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1658802342527},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1658802342530},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1658802342535},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1658802342537},{"_id":"themes/next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":1658802342539},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1658802342541},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1658802342533},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1658802342542},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1658802342544},{"_id":"themes/next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":1658802342549},{"_id":"themes/next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":1658802342550},{"_id":"themes/next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":1658802342552},{"_id":"themes/next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":1658802342553},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1658802342555},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1658802342557},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1658802342559},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1658802342561},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1658802342565},{"_id":"themes/next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":1658802342568},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1658802342722},{"_id":"themes/next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1658802342724},{"_id":"themes/next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1658802342726},{"_id":"themes/next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":1658802342728},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1658802342730},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1658802342731},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1658802343099},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1658802342440},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1658802342442},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1658802342444},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1658802342447},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"e9d51e93f239a2d4b69722c69db3463b4baf0f4c","modified":1658802342465},{"_id":"themes/next/.github/workflows/linter.yml","hash":"49d96d5d150d348805d55c6bac044fa9b5244bd0","modified":1658802342466},{"_id":"themes/next/.github/workflows/lock.yml","hash":"e48d1ced9a673d3f0911a700d3e68c0f4ca79263","modified":1658802342468},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1658802342470},{"_id":"themes/next/.github/workflows/tester.yml","hash":"80a20c3a7522249f051a48239db41d1317e9b552","modified":1658802342472},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"434cc0674290958b1e9bbc46c3486f073c0722db","modified":1658802342463},{"_id":"themes/next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":1658802342504},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1658802342508},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1658802342509},{"_id":"themes/next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":1658802342510},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1658802342571},{"_id":"themes/next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":1658802342572},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1658802342573},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1658802342576},{"_id":"themes/next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":1658802342578},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1658802342595},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1658802342632},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":1658802342634},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":1658802342636},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1658802342677},{"_id":"themes/next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":1658802342680},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1658802342688},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1658802342692},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1658802342690},{"_id":"themes/next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":1658802342737},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1658802342771},{"_id":"themes/next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1658802342772},{"_id":"themes/next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":1658802342773},{"_id":"themes/next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":1658802342775},{"_id":"themes/next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":1658802342777},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1658802342782},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1658802342780},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":1658802342784},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":1658802342787},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1658802342607},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1658802342789},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1658802342794},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1658802342792},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1658802342798},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":1658802342801},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1658802342802},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1658802342804},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1658802342806},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1658802342807},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1658802342808},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1658802342810},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1658802342814},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1658802342816},{"_id":"themes/next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":1658802342945},{"_id":"themes/next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":1658802342818},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1658802342999},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1658802343004},{"_id":"themes/next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":1658802343001},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1658796517310},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1658796517329},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1658796517330},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1658802343005},{"_id":"themes/next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1658802343009},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1658802343007},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1658802343013},{"_id":"themes/next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1658802343015},{"_id":"themes/next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1658802343018},{"_id":"themes/next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1658802343016},{"_id":"themes/next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1658802343022},{"_id":"themes/next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1658802343087},{"_id":"themes/next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1658802343020},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1658802343091},{"_id":"themes/next/test/helpers/next-url.js","hash":"a91d880cb75e0a8e65a7be4c7362b2c8ebfb7c4f","modified":1658802343097},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1658802343092},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1658802343102},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1658802343103},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1658802343104},{"_id":"themes/next/test/tags/group-pictures.js","hash":"5c68ae0184f9da6e00ba199f2554d503d8e6da71","modified":1658802343105},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1658802343109},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1658802343107},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1658802343110},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1658802343114},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1658802343112},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1658802343116},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1658802343119},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1658802343118},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1658802343011},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1658802343123},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":1658802342581},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":1658802342583},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":1658802342586},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1658802342587},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1658802342589},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1658802342591},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1658802342594},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1658802342599},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1658802342601},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1658802342602},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1658802342604},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1658802342611},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1658802342605},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":1658802342615},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1658802342614},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1658802342617},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":1658802342620},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":1658802342618},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1658802342622},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1658802342625},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1658802342627},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":1658802342630},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1658802342640},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1658802342642},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1658802342643},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1658802342645},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"45477a04cf2b3c077061c8c3ada216c1ae288e0e","modified":1658802342647},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":1658802342649},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1658802342651},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":1658802342655},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1658802342660},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1658802342664},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1658802342666},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1658802342667},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1658802342669},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1658802342670},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1658802342673},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1658802342676},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1658802342683},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1658802342684},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1658802342686},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":1658802342696},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1658802342698},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1658802342717},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1658802342719},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1658802342701},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1658802342705},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1658802342708},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1658802342711},{"_id":"themes/next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":1658802342740},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1658802342742},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1658802342744},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1658802342745},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":1658802342747},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":1658802342749},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"7fa8701c86485b2fe7324e017101a32417902397","modified":1658802342753},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1658802342755},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1658802342757},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1658802342758},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"135b87d151055eefdbc711d9e704b112b3214a84","modified":1658802342760},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1658802342762},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1658802342765},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1658802342767},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1658802342769},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1658802342986},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1658802342988},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1658802342990},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1658802342992},{"_id":"themes/next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":1658802342994},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1658802343024},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1658802343059},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1658802343067},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1658802343069},{"_id":"themes/next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1658802343071},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":1658802342820},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":1658802342822},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1658802342854},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1658802342888},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":1658802342890},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":1658802342910},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1658802342912},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1658802342915},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1658802342921},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1658802342923},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":1658802342924},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1658802342926},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1658802342943},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1658802342948},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1658802342950},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1658802342951},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":1658802342955},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":1658802342957},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1658802342959},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1658802342961},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1658802342963},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":1658802342965},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1658802342967},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1658802342968},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1658802342971},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":1658802342974},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1658802342976},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1658802342978},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":1658802342981},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1658802342982},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1658802342984},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1658802343031},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1658802343033},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1658802343034},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1658802343038},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1658802343040},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1658802343041},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1658802343049},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1658802343048},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1658802343051},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1658802343053},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1658802343055},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1658802343056},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1658802343058},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1658802343064},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1658802343066},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1658802343073},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1658802343075},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1658802343077},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1658802343080},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1658802343083},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1658802343085},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":1658802342834},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":1658802342837},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1658802342839},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":1658802342841},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1658802342842},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1658802342845},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":1658802342848},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1658802342849},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":1658802342851},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":1658802342853},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1658802342823},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1658802342825},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1658802342827},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1658802342830},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1658802342832},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":1658802342858},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":1658802342861},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":1658802342863},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":1658802342865},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1658802342867},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":1658802342868},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":1658802342869},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1658802342871},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":1658802342875},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1658802342878},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1658802342880},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":1658802342882},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1658802342883},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":1658802342885},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1658802342886},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1658802342894},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1658802342897},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":1658802342892},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1658802342898},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":1658802342900},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1658802342902},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":1658802342903},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":1658802342905},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":1658802342906},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1658802342907},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":1658802342917},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":1658802342919},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1658802342930},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1658802342931},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":1658802342933},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1658802342934},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":1658802342935},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1658802342936},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":1658802342938},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1658802342940},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":1658802342942},{"_id":"public/atom.xml","hash":"0c8eb1adb8c5bc1be0a48818c13be5c6c2e62936","modified":1658802377686},{"_id":"public/search.xml","hash":"807efac95ae92d444b65014295110470f2803987","modified":1658802377686},{"_id":"public/sitemap.xml","hash":"b1eef6e1621ee36fe54e8a606633926c08ff313c","modified":1658802377686},{"_id":"public/about/index.html","hash":"e2eda63212fcf4e82472719313c683dc1139a624","modified":1658802377686},{"_id":"public/categories/index.html","hash":"7d7ff22349777d25e9a3a9f85a09b39c2beca03e","modified":1658802377686},{"_id":"public/home/index.html","hash":"21dd817896576018406a40d73baaf15457fbd660","modified":1658802377686},{"_id":"public/tags/index.html","hash":"dc17f203a2081b028899d9fd173a57ca4c1d6630","modified":1658802377686},{"_id":"public/2022/07/24/Git常用命令-上/index.html","hash":"2234ff1525d8529dde4e1499e3de4cf6f9d63ce3","modified":1658802377686},{"_id":"public/2022/02/28/微信多开/index.html","hash":"c5d9e123710ee6be1176e74dc8e17d9f19a94a7f","modified":1658802377686},{"_id":"public/2021/11/07/Multi-KeyWord-Sort/index.html","hash":"691a1e5dc2194f66b82a8f1bae3212de6b765740","modified":1658802377686},{"_id":"public/2021/11/07/Bucket-Sort/index.html","hash":"269f694acd24b4a8748728984750de64edb0da3a","modified":1658802377686},{"_id":"public/2021/11/07/Dynamic-drawing-of-osg-vertex-buffer-objects/index.html","hash":"fef95ab41b88228312746934d0a73d2a91feb77a","modified":1658802377686},{"_id":"public/2021/10/26/Shell-Sort/index.html","hash":"405cdeddaec7e7dda88adef756b1b1723722dc6b","modified":1658802377686},{"_id":"public/2021/10/25/Selection-sort/index.html","hash":"4edee50940ee304616e79fab6bf373bf9a7f260d","modified":1658802377686},{"_id":"public/2021/10/17/记一次总结/index.html","hash":"f57c414a19cf51cfc88cc1f54d5491db702ea9b3","modified":1658802377686},{"_id":"public/2021/03/19/Bug奇遇记-uint16-t/index.html","hash":"c4bb3f174aac214507e0be282e10a55db042e378","modified":1658802377686},{"_id":"public/2021/03/18/迟到的毕业总结/index.html","hash":"fdc53385eaa63388eed649492ce6a76601ebf244","modified":1658802377686},{"_id":"public/2021/03/16/baozi/index.html","hash":"c001b61fb3874f80455cee9544f3f8616d36052d","modified":1658802377686},{"_id":"public/archives/index.html","hash":"e795341862fff3381973a02699d376835883def8","modified":1658802377686},{"_id":"public/archives/page/2/index.html","hash":"c5dd6f4eaace7c8d90d622e2ec5ffd901615ef82","modified":1658802377686},{"_id":"public/archives/page/3/index.html","hash":"7f87d08c74476df29fb2fbbf6f37354e9f5114d1","modified":1658802377686},{"_id":"public/archives/2021/index.html","hash":"cae234303b253d437e1224ba527c82171f7a8a1f","modified":1658802377686},{"_id":"public/archives/2021/page/2/index.html","hash":"3e9bd1714075b14599884702cd8886ced7caa61f","modified":1658802377686},{"_id":"public/archives/2021/03/index.html","hash":"34018b9fa78227016b05ef03e61049032e37c1e7","modified":1658802377686},{"_id":"public/archives/2021/04/index.html","hash":"05fa8e1a79e267ed25c4e99a827386fafcf92d2c","modified":1658802377686},{"_id":"public/archives/2021/07/index.html","hash":"78e50f59ac3fe7e96de3197a341c18366c77c7bf","modified":1658802377686},{"_id":"public/archives/2021/10/index.html","hash":"c1091065483d8497f18e250696a897a15a783cd2","modified":1658802377686},{"_id":"public/archives/2021/11/index.html","hash":"7049bcc5f49b222650b025c1314feb48e6585480","modified":1658802377686},{"_id":"public/archives/2021/12/index.html","hash":"137dda46ddf742184959f54dbe98b4bf1ddebe53","modified":1658802377686},{"_id":"public/archives/2022/index.html","hash":"9d8d6c075bf10467490d0e2d74bba059bed30c8f","modified":1658802377686},{"_id":"public/archives/2022/01/index.html","hash":"97c79fa95fa89d0f4c0df4db12da550034742b2c","modified":1658802377686},{"_id":"public/archives/2022/02/index.html","hash":"801bcbf54bd2898eb884c4d7ee7c3d211f4995a5","modified":1658802377686},{"_id":"public/archives/2022/07/index.html","hash":"2c24378e5c02f4ce362569d278ab993b88238f39","modified":1658802377686},{"_id":"public/categories/bun/index.html","hash":"b92224fb9f39e3e05bd1d31da6f6f795d7873742","modified":1658802377686},{"_id":"public/categories/Algorithm/index.html","hash":"124cbf0cc30ba65541493c4383e421f93062e50c","modified":1658802377686},{"_id":"public/categories/works/index.html","hash":"6a9c74a8ad86a3a721dc0c2340d9c6bc3aafbd0a","modified":1658802377686},{"_id":"public/categories/bun/life/index.html","hash":"f4649d0487157214bf7b5513345b22a5398007fe","modified":1658802377686},{"_id":"public/categories/Computer-Graph/index.html","hash":"ab3d95169d6b2f5a82c7ec4bf7f7aebbb5daa302","modified":1658802377686},{"_id":"public/categories/works/GF/index.html","hash":"f434fcd50b00a353af9f3082581a0e3fc576c07d","modified":1658802377686},{"_id":"public/categories/works/HJ/index.html","hash":"13d722d1525520cf39a065f5f40ba4377b3cd337","modified":1658802377686},{"_id":"public/categories/works/SCU/index.html","hash":"a53999f9d7f47ac107938da348ac204cbb66033f","modified":1658802377686},{"_id":"public/categories/works/GF/data-type/index.html","hash":"ecd770418578a0022b6c72a4678bc5952e56b5f4","modified":1658802377686},{"_id":"public/categories/Tips/index.html","hash":"3d7096976dc51d1a4ae88461a66dc8a45b2753ee","modified":1658802377686},{"_id":"public/categories/works/interview/index.html","hash":"6f616389e4abb3d30cb6937301c55e37f73b151b","modified":1658802377686},{"_id":"public/categories/works/GF/OSG/index.html","hash":"f7575a458f905624f126cd9f4c891590da7e1010","modified":1658802377686},{"_id":"public/categories/bun/university/index.html","hash":"6ab001e5b21e115b82d824fbdac5cc3d98f86300","modified":1658802377686},{"_id":"public/categories/works/HJ/OSG/index.html","hash":"239cf9522dbe963117eb570e35bdaba767c553ac","modified":1658802377686},{"_id":"public/categories/works/GF/data-type/bugs/index.html","hash":"33dd99ed7743a22002d877924fd2e2613d76b869","modified":1658802377686},{"_id":"public/tags/mylife/index.html","hash":"a57c2d72778b6e592703119d9efdfa3de25f95b9","modified":1658802377686},{"_id":"public/tags/cpp/index.html","hash":"63ffdff6ea71458df5b60d6966a07563072d751f","modified":1658802377686},{"_id":"public/tags/cpp/page/2/index.html","hash":"c036787a6fbb7405cd90ecd2589b9f38ee43ed48","modified":1658802377686},{"_id":"public/tags/sort/index.html","hash":"37f439c4f0eb7db206883a4e75c8f83576a7a836","modified":1658802377686},{"_id":"public/tags/osg/index.html","hash":"8de1378e91ffdb927aa54450a903e37f502ae8d3","modified":1658802377686},{"_id":"public/tags/Games202/index.html","hash":"f5607c0f29e41042d00d52d80417966746188b66","modified":1658802377686},{"_id":"public/tags/Shadow/index.html","hash":"f19597ecc54b1528fcb7e7166f0e131a92859e21","modified":1658802377686},{"_id":"public/tags/Git/index.html","hash":"a5b67c923728935c464217d092fbdd8caa610c16","modified":1658802377686},{"_id":"public/tags/intraduce/index.html","hash":"c83632a6e1458d7da31c004dac16e11b9e0d012a","modified":1658802377686},{"_id":"public/tags/windows/index.html","hash":"80da636aaf79a6f49fad27191da203540fdb0b8e","modified":1658802377686},{"_id":"public/tags/conclusion/index.html","hash":"0ca54f39c49a28af0c1a9191833268194bbe76c6","modified":1658802377686},{"_id":"public/tags/openGL/index.html","hash":"1c174c17bd2c3e42d8434b07504d31bfdf5c2acf","modified":1658802377686},{"_id":"public/tags/computer-graphics/index.html","hash":"8fa6573ff847383dbae259120b28b5d7cd056ba8","modified":1658802377686},{"_id":"public/tags/university/index.html","hash":"fb8465ed93fab547efa270846eaf03ab0da06277","modified":1658802377686},{"_id":"public/2022/01/16/记一次面试-1/index.html","hash":"80adae6668e0316f9a1ccd16786c0874ff37bf7d","modified":1658802377686},{"_id":"public/2022/01/16/2021年终总结/index.html","hash":"1d748ad58f29772eca70aa7e9e3a50cea9f98ecf","modified":1658802377686},{"_id":"public/2021/12/13/Games202-ShadowMap/index.html","hash":"0e4fac311b412c98edc8d42be1ddea8fffb2dcdc","modified":1658802377686},{"_id":"public/2021/11/07/Physical-Sort/index.html","hash":"db3ca6ee59a74213d5a3d9e68e61fcaf3c956e97","modified":1658802377686},{"_id":"public/2021/11/07/Table-Sort/index.html","hash":"2e598aa71e61c7c0c146639f40ca60ae9d27f9af","modified":1658802377686},{"_id":"public/2021/10/28/QuickSort/index.html","hash":"f0bc125410b90f149d64b64a6fdbc8bcdb9cf1eb","modified":1658802377686},{"_id":"public/2021/10/26/归并排序/index.html","hash":"0ccf0abea1084643bc13fa40107b323e27dc5f9e","modified":1658802377686},{"_id":"public/2021/10/24/Heap/index.html","hash":"569d788b741f7669c407389bd52a8ab49935b9ee","modified":1658802377686},{"_id":"public/2021/10/19/sort-bubble-insertion/index.html","hash":"6a60178d7b3d65c56f1ddfd8fe1c77b37d63f0b6","modified":1658802377686},{"_id":"public/2021/07/27/记一次面试/index.html","hash":"9c1790c575794f86da943b26c7a79767021b2f71","modified":1658802377686},{"_id":"public/2021/07/26/OSG-HUD/index.html","hash":"2b4f85a6ea8d647e2e82fa3cf1b07fec65c40233","modified":1658802377686},{"_id":"public/2021/04/04/OSG踩坑记-默认光源/index.html","hash":"8a6ea3bbd22637d89052ce93cbf54966ba551151","modified":1658802377686},{"_id":"public/2021/03/20/OSG踩坑记-模型共享-模型颜色修改/index.html","hash":"ee6b2360a7881b1acf167717582e53e661974a56","modified":1658802377686},{"_id":"public/index.html","hash":"5bc5cb5b7d4cb3caed12287203230b405f7911b6","modified":1658802377686},{"_id":"public/page/2/index.html","hash":"40ba8a90557b7797d75bc7d2beb6ca979790e7b8","modified":1658802377686},{"_id":"public/page/3/index.html","hash":"92d9594fa83cdcbeba0f361a861495a03e4c2fc0","modified":1658802377686},{"_id":"public/CNAME","hash":"9198ffd83e0d8aa2ea2bb40dea5654d0fa6523a4","modified":1658802377686},{"_id":"public/uploads/wechat-qcode.jpg","hash":"5e32da2bbb5828e9050d948db5f9f36731ecfccc","modified":1658802377686},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1658802377686},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1658802377686},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1658802377686},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1658802377686},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1658802377686},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1658802377686},{"_id":"public/css/noscript.css","hash":"ec89b3425fbce20863d554c6fd495ea29c3c303d","modified":1658802377686},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1658802377686},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1658802377686},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1658802377686},{"_id":"public/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":1658802377686},{"_id":"public/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":1658802377686},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1658802377686},{"_id":"public/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":1658802377686},{"_id":"public/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":1658802377686},{"_id":"public/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":1658802377686},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1658802377686},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1658802377686},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1658802377686},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1658802377686},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1658802377686},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1658802377686},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1658802377686},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1658802377686},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1658802377686},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1658802377686},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1658802377686},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1658802377686},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1658802377686},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1658802377686},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1658802377686},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1658802377686},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1658802377686},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1658802377686},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1658802377686},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1658802377686},{"_id":"public/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":1658802377686},{"_id":"public/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":1658802377686},{"_id":"public/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":1658802377686},{"_id":"public/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":1658802377686},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1658802377686},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1658802377686},{"_id":"public/css/main.css","hash":"67e16fba1a6ae6b698c514bd35487a39e455a93e","modified":1658802377686}],"Category":[{"name":"bun","_id":"cl61k3vbb0004ucuug0ro3npz"},{"name":"Algorithm","_id":"cl61k3vbi000bucuu6kdu1jxx"},{"name":"works","_id":"cl61k3vbm000gucuuf4tae46d"},{"name":"life","parent":"cl61k3vbb0004ucuug0ro3npz","_id":"cl61k3vbz000tucuubpu487g8"},{"name":"Computer Graph","_id":"cl61k3vc20010ucuu3hdkcpp8"},{"name":"GF","parent":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vcb001iucuueky83wri"},{"name":"HJ","parent":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vct0025ucuu21zaam60"},{"name":"SCU","parent":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd1002hucuu9mhygn8y"},{"name":"data type","parent":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vd4002nucuu9dbvf2ho"},{"name":"Tips","_id":"cl61k3vd6002sucuueskd2f2a"},{"name":"interview","parent":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd80031ucuu5kscakj9"},{"name":"OSG","parent":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vd80037ucuu9d4793ep"},{"name":"university","parent":"cl61k3vbb0004ucuug0ro3npz","_id":"cl61k3vda003eucuu7b0t1kh7"},{"name":"OSG","parent":"cl61k3vct0025ucuu21zaam60","_id":"cl61k3vdb003kucuu8tll2nn0"},{"name":"bugs","parent":"cl61k3vd4002nucuu9dbvf2ho","_id":"cl61k3vdd003vucuu3jljg0kh"}],"Data":[],"Page":[{"title":"About me","date":"2021-03-17T14:19:57.000Z","type":"about","_content":"\n#### Current Status\n\n- 一个无心上班的，三流软件开发人员。\n\n#### Work\n\n- 图形开发（图形展示`2D` & `3D`），桌面软件开发。\n\n#### Work Tags\n\n- `Cpp`、`OSG`、`OpenGL`、`Qt`、`VS`、`Git`、`Math`。","source":"about/index.md","raw":"---\ntitle: \"About me\"\ndate: 2021-03-17 22:19:57\ntype: \"about\"\n---\n\n#### Current Status\n\n- 一个无心上班的，三流软件开发人员。\n\n#### Work\n\n- 图形开发（图形展示`2D` & `3D`），桌面软件开发。\n\n#### Work Tags\n\n- `Cpp`、`OSG`、`OpenGL`、`Qt`、`VS`、`Git`、`Math`。","updated":"2022-07-26T00:48:36.877Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl61k3vb00000ucuu8zwmfc96","content":"<h4 id=\"Current-Status\"><a href=\"#Current-Status\" class=\"headerlink\" title=\"Current Status\"></a>Current Status</h4><ul>\n<li>一个无心上班的，三流软件开发人员。</li>\n</ul>\n<h4 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h4><ul>\n<li>图形开发（图形展示<code>2D</code> &amp; <code>3D</code>），桌面软件开发。</li>\n</ul>\n<h4 id=\"Work-Tags\"><a href=\"#Work-Tags\" class=\"headerlink\" title=\"Work Tags\"></a>Work Tags</h4><ul>\n<li><code>Cpp</code>、<code>OSG</code>、<code>OpenGL</code>、<code>Qt</code>、<code>VS</code>、<code>Git</code>、<code>Math</code>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Current-Status\"><a href=\"#Current-Status\" class=\"headerlink\" title=\"Current Status\"></a>Current Status</h4><ul>\n<li>一个无心上班的，三流软件开发人员。</li>\n</ul>\n<h4 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h4><ul>\n<li>图形开发（图形展示<code>2D</code> &amp; <code>3D</code>），桌面软件开发。</li>\n</ul>\n<h4 id=\"Work-Tags\"><a href=\"#Work-Tags\" class=\"headerlink\" title=\"Work Tags\"></a>Work Tags</h4><ul>\n<li><code>Cpp</code>、<code>OSG</code>、<code>OpenGL</code>、<code>Qt</code>、<code>VS</code>、<code>Git</code>、<code>Math</code>。</li>\n</ul>\n"},{"title":"all of categories","date":"2021-03-17T15:18:00.000Z","type":"categories","comments":0,"layout":"categories","_content":"\n### ","source":"categories/index.md","raw":"---\ntitle: \"all of categories\"\ndate: 2021-03-17 23:18:00\ntype: \"categories\"\ncomments: false\nlayout: \"categories\"\n---\n\n### ","updated":"2022-07-26T00:48:36.878Z","path":"categories/index.html","_id":"cl61k3vb70002ucuu9ljtdnr3","content":"<h3 id><a href=\"#\" class=\"headerlink\" title></a></h3>","site":{"data":{}},"excerpt":"","more":"<h3 id><a href=\"#\" class=\"headerlink\" title></a></h3>"},{"title":"home","date":"2021-03-17T14:45:38.000Z","type":"home","_content":"","source":"home/index.md","raw":"---\ntitle: home\ndate: 2021-03-17 22:45:38\ntype: \"home\"\n---\n","updated":"2022-07-26T00:48:36.880Z","path":"home/index.html","comments":1,"layout":"page","_id":"cl61k3vbe0006ucuu38s04j3e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"万物皆可贴标签","date":"2021-03-17T14:20:05.000Z","type":"tags","comments":0,"layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: 万物皆可贴标签\ndate: 2021-03-17 22:20:05\ntype: \"tags\"\ncomments: false\nlayout: \"tags\"\n---\n\n","updated":"2022-07-26T00:48:36.882Z","path":"tags/index.html","_id":"cl61k3vbg0008ucuug7jwbpm2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2021年终总结","date":"2022-01-15T16:43:19.000Z","_content":"\n### 我起伏的2021年:\n\n- 2021年鸡毛蒜皮\n\n....\n\n### 我的关于2021年的大事件：\n\n#### 1、换了工作\n\n#### 2、离开了那个度过了五年的城市\n\n#### 3、 换了工作的城市\n\n#### 4、告别了好友\n\n#### 5、见了阔怕已久的朋友\n\n#### 6、又一次决定换工作 \n\n- 面试了一个环境可能更好的工作\n\n### 一、我换工作这件事\n\n<p>先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。</p>\n&ensp;&ensp;离开我的上一个岗位的原因颇多,当然究其原因，我觉得`马老板`说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。\n&ensp;&ensp;新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。\n\n### 二、离开济南\n\n&ensp;&ensp;我在这个城市上大学，大学毕业在这里找的工作，也是在这里，度过了我和我对象为期6年的异地恋。\n&ensp;&ensp;若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息......\n&ensp;&ensp;我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以`成都`应该是个不错的选择，我开始面试，将目标公司地域选到了成都.....\n&ensp;&ensp;然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。\n&ensp;&ensp;然后我来了`北京`.....,只能说，造化弄人。\n\n### 三、告别好友\n\n&ensp;&ensp;我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的`二哥`还有`杨哥`,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。\n&ensp;&ensp;从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。\n\n### 四、见了好久不见的朋友\n\n&ensp;&ensp;2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。\n&ensp;&ensp;有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。\n&ensp;&ensp;同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。\n\n### 五、又一次决定换工作\n\n&ensp;&ensp;决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。\n&ensp;&ensp;又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！\n\n\n\n","source":"_posts/2021年终总结.md","raw":"---\ntitle: 2021年终总结\ndate: 2022-01-16 00:43:19\ncategories:\n  - bun\n  - life\ntags:\t\n  - mylife\n---\n\n### 我起伏的2021年:\n\n- 2021年鸡毛蒜皮\n\n....\n\n### 我的关于2021年的大事件：\n\n#### 1、换了工作\n\n#### 2、离开了那个度过了五年的城市\n\n#### 3、 换了工作的城市\n\n#### 4、告别了好友\n\n#### 5、见了阔怕已久的朋友\n\n#### 6、又一次决定换工作 \n\n- 面试了一个环境可能更好的工作\n\n### 一、我换工作这件事\n\n<p>先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。</p>\n&ensp;&ensp;离开我的上一个岗位的原因颇多,当然究其原因，我觉得`马老板`说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。\n&ensp;&ensp;新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。\n\n### 二、离开济南\n\n&ensp;&ensp;我在这个城市上大学，大学毕业在这里找的工作，也是在这里，度过了我和我对象为期6年的异地恋。\n&ensp;&ensp;若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息......\n&ensp;&ensp;我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以`成都`应该是个不错的选择，我开始面试，将目标公司地域选到了成都.....\n&ensp;&ensp;然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。\n&ensp;&ensp;然后我来了`北京`.....,只能说，造化弄人。\n\n### 三、告别好友\n\n&ensp;&ensp;我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的`二哥`还有`杨哥`,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。\n&ensp;&ensp;从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。\n\n### 四、见了好久不见的朋友\n\n&ensp;&ensp;2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。\n&ensp;&ensp;有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。\n&ensp;&ensp;同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。\n\n### 五、又一次决定换工作\n\n&ensp;&ensp;决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。\n&ensp;&ensp;又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！\n\n\n\n","slug":"2021年终总结","published":1,"updated":"2022-07-26T00:48:36.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vb40001ucuu8tu32tv6","content":"<h3 id=\"我起伏的2021年\"><a href=\"#我起伏的2021年\" class=\"headerlink\" title=\"我起伏的2021年:\"></a>我起伏的2021年:</h3><ul>\n<li>2021年鸡毛蒜皮</li>\n</ul>\n<p>….</p>\n<h3 id=\"我的关于2021年的大事件：\"><a href=\"#我的关于2021年的大事件：\" class=\"headerlink\" title=\"我的关于2021年的大事件：\"></a>我的关于2021年的大事件：</h3><h4 id=\"1、换了工作\"><a href=\"#1、换了工作\" class=\"headerlink\" title=\"1、换了工作\"></a>1、换了工作</h4><h4 id=\"2、离开了那个度过了五年的城市\"><a href=\"#2、离开了那个度过了五年的城市\" class=\"headerlink\" title=\"2、离开了那个度过了五年的城市\"></a>2、离开了那个度过了五年的城市</h4><h4 id=\"3、-换了工作的城市\"><a href=\"#3、-换了工作的城市\" class=\"headerlink\" title=\"3、 换了工作的城市\"></a>3、 换了工作的城市</h4><h4 id=\"4、告别了好友\"><a href=\"#4、告别了好友\" class=\"headerlink\" title=\"4、告别了好友\"></a>4、告别了好友</h4><h4 id=\"5、见了阔怕已久的朋友\"><a href=\"#5、见了阔怕已久的朋友\" class=\"headerlink\" title=\"5、见了阔怕已久的朋友\"></a>5、见了阔怕已久的朋友</h4><h4 id=\"6、又一次决定换工作\"><a href=\"#6、又一次决定换工作\" class=\"headerlink\" title=\"6、又一次决定换工作\"></a>6、又一次决定换工作</h4><ul>\n<li>面试了一个环境可能更好的工作</li>\n</ul>\n<h3 id=\"一、我换工作这件事\"><a href=\"#一、我换工作这件事\" class=\"headerlink\" title=\"一、我换工作这件事\"></a>一、我换工作这件事</h3><p>先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。</p>\n&ensp;&ensp;离开我的上一个岗位的原因颇多,当然究其原因，我觉得`马老板`说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。\n&ensp;&ensp;新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。\n\n<h3 id=\"二、离开济南\"><a href=\"#二、离开济南\" class=\"headerlink\" title=\"二、离开济南\"></a>二、离开济南</h3><p>&ensp;&ensp;我在这个城市上大学，大学毕业在这里找的工作，也是在这里，度过了我和我对象为期6年的异地恋。<br>&ensp;&ensp;若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息……<br>&ensp;&ensp;我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以<code>成都</code>应该是个不错的选择，我开始面试，将目标公司地域选到了成都…..<br>&ensp;&ensp;然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。<br>&ensp;&ensp;然后我来了<code>北京</code>…..,只能说，造化弄人。</p>\n<h3 id=\"三、告别好友\"><a href=\"#三、告别好友\" class=\"headerlink\" title=\"三、告别好友\"></a>三、告别好友</h3><p>&ensp;&ensp;我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的<code>二哥</code>还有<code>杨哥</code>,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。<br>&ensp;&ensp;从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。</p>\n<h3 id=\"四、见了好久不见的朋友\"><a href=\"#四、见了好久不见的朋友\" class=\"headerlink\" title=\"四、见了好久不见的朋友\"></a>四、见了好久不见的朋友</h3><p>&ensp;&ensp;2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。<br>&ensp;&ensp;有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。<br>&ensp;&ensp;同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。</p>\n<h3 id=\"五、又一次决定换工作\"><a href=\"#五、又一次决定换工作\" class=\"headerlink\" title=\"五、又一次决定换工作\"></a>五、又一次决定换工作</h3><p>&ensp;&ensp;决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。<br>&ensp;&ensp;又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"我起伏的2021年\"><a href=\"#我起伏的2021年\" class=\"headerlink\" title=\"我起伏的2021年:\"></a>我起伏的2021年:</h3><ul>\n<li>2021年鸡毛蒜皮</li>\n</ul>\n<p>….</p>\n<h3 id=\"我的关于2021年的大事件：\"><a href=\"#我的关于2021年的大事件：\" class=\"headerlink\" title=\"我的关于2021年的大事件：\"></a>我的关于2021年的大事件：</h3><h4 id=\"1、换了工作\"><a href=\"#1、换了工作\" class=\"headerlink\" title=\"1、换了工作\"></a>1、换了工作</h4><h4 id=\"2、离开了那个度过了五年的城市\"><a href=\"#2、离开了那个度过了五年的城市\" class=\"headerlink\" title=\"2、离开了那个度过了五年的城市\"></a>2、离开了那个度过了五年的城市</h4><h4 id=\"3、-换了工作的城市\"><a href=\"#3、-换了工作的城市\" class=\"headerlink\" title=\"3、 换了工作的城市\"></a>3、 换了工作的城市</h4><h4 id=\"4、告别了好友\"><a href=\"#4、告别了好友\" class=\"headerlink\" title=\"4、告别了好友\"></a>4、告别了好友</h4><h4 id=\"5、见了阔怕已久的朋友\"><a href=\"#5、见了阔怕已久的朋友\" class=\"headerlink\" title=\"5、见了阔怕已久的朋友\"></a>5、见了阔怕已久的朋友</h4><h4 id=\"6、又一次决定换工作\"><a href=\"#6、又一次决定换工作\" class=\"headerlink\" title=\"6、又一次决定换工作\"></a>6、又一次决定换工作</h4><ul>\n<li>面试了一个环境可能更好的工作</li>\n</ul>\n<h3 id=\"一、我换工作这件事\"><a href=\"#一、我换工作这件事\" class=\"headerlink\" title=\"一、我换工作这件事\"></a>一、我换工作这件事</h3><p>先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。</p>\n&ensp;&ensp;离开我的上一个岗位的原因颇多,当然究其原因，我觉得`马老板`说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。\n&ensp;&ensp;新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。\n\n<h3 id=\"二、离开济南\"><a href=\"#二、离开济南\" class=\"headerlink\" title=\"二、离开济南\"></a>二、离开济南</h3><p>&ensp;&ensp;我在这个城市上大学，大学毕业在这里找的工作，也是在这里，度过了我和我对象为期6年的异地恋。<br>&ensp;&ensp;若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息……<br>&ensp;&ensp;我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以<code>成都</code>应该是个不错的选择，我开始面试，将目标公司地域选到了成都…..<br>&ensp;&ensp;然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。<br>&ensp;&ensp;然后我来了<code>北京</code>…..,只能说，造化弄人。</p>\n<h3 id=\"三、告别好友\"><a href=\"#三、告别好友\" class=\"headerlink\" title=\"三、告别好友\"></a>三、告别好友</h3><p>&ensp;&ensp;我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的<code>二哥</code>还有<code>杨哥</code>,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。<br>&ensp;&ensp;从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。</p>\n<h3 id=\"四、见了好久不见的朋友\"><a href=\"#四、见了好久不见的朋友\" class=\"headerlink\" title=\"四、见了好久不见的朋友\"></a>四、见了好久不见的朋友</h3><p>&ensp;&ensp;2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。<br>&ensp;&ensp;有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。<br>&ensp;&ensp;同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。</p>\n<h3 id=\"五、又一次决定换工作\"><a href=\"#五、又一次决定换工作\" class=\"headerlink\" title=\"五、又一次决定换工作\"></a>五、又一次决定换工作</h3><p>&ensp;&ensp;决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。<br>&ensp;&ensp;又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！</p>\n"},{"title":"Bucket Sort and Cardinality sort","date":"2021-11-07T13:34:19.000Z","_content":"\n### 桶排序\n\n- `T(N,M) = O(M+N)`,M 个桶的情况\n  - N >> M的时候是相对教优秀的算法\n  - M >> N ???\n\n- 假设我们有N = 10个整数，N ∈ [0,999],(此时 M = 1000)；我们便不能在线性时间下完成排序。\n\n### 基数排序：按照数字的进制排序（10）\n\n- example: \n- input: 64 8 216 512 27 729 0 1 343 125 \n  - 使用次位优先(Least Significant Digit)\n  - 先按照个位数将元素放到对应的桶Pass1\n  - 按照十位放到对应的桶中\n\n| Bucket |            0             |            1             |            2             |             3              |             4             |             5              | 6                          |             7             |            8             |             9              |\n| :----: | :----------------------: | :----------------------: | :----------------------: | :------------------------: | :-----------------------: | :------------------------: | -------------------------- | :-----------------------: | :----------------------: | :------------------------: |\n| Pass 1(个位) | <font color=red>0</font> | <font color=red>1</font> | 51<font color=red>2</font> | 34<font color=red>3</font> | 6<font color=red>4</font> | 12<font color=red>5</font> | 21<font color=red>6</font> | 2<font color=red>7</font> | <font color=red>8</font> | 72<font color=red>9</font> |\n| Pass 2(十位) |         0<br>1<br>8         | 512<br>216 | 125<br>27<br>729 |                            |            343            |                            | 64<br>                     |                           |                          |                            |\n| Pass 3 (百位) | 0<br/>1<br/>8<br/>27<br/>64 | 125 | 216 |            343             |                           |            512             |                            |            729            |                          |                            |\n\n- 最终的顺序，分别从每个桶中顺序读取即可。\n\n#### 时间复杂度： `T= O(P(N+B))`\n\n- 较好情况：取决于基数-多少个桶 (B << N时差不多是一个线性复杂度的算法)\n\n","source":"_posts/Bucket-Sort.md","raw":"---\ntitle: Bucket Sort and Cardinality sort\ndate: 2021-11-07 21:34:19\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n### 桶排序\n\n- `T(N,M) = O(M+N)`,M 个桶的情况\n  - N >> M的时候是相对教优秀的算法\n  - M >> N ???\n\n- 假设我们有N = 10个整数，N ∈ [0,999],(此时 M = 1000)；我们便不能在线性时间下完成排序。\n\n### 基数排序：按照数字的进制排序（10）\n\n- example: \n- input: 64 8 216 512 27 729 0 1 343 125 \n  - 使用次位优先(Least Significant Digit)\n  - 先按照个位数将元素放到对应的桶Pass1\n  - 按照十位放到对应的桶中\n\n| Bucket |            0             |            1             |            2             |             3              |             4             |             5              | 6                          |             7             |            8             |             9              |\n| :----: | :----------------------: | :----------------------: | :----------------------: | :------------------------: | :-----------------------: | :------------------------: | -------------------------- | :-----------------------: | :----------------------: | :------------------------: |\n| Pass 1(个位) | <font color=red>0</font> | <font color=red>1</font> | 51<font color=red>2</font> | 34<font color=red>3</font> | 6<font color=red>4</font> | 12<font color=red>5</font> | 21<font color=red>6</font> | 2<font color=red>7</font> | <font color=red>8</font> | 72<font color=red>9</font> |\n| Pass 2(十位) |         0<br>1<br>8         | 512<br>216 | 125<br>27<br>729 |                            |            343            |                            | 64<br>                     |                           |                          |                            |\n| Pass 3 (百位) | 0<br/>1<br/>8<br/>27<br/>64 | 125 | 216 |            343             |                           |            512             |                            |            729            |                          |                            |\n\n- 最终的顺序，分别从每个桶中顺序读取即可。\n\n#### 时间复杂度： `T= O(P(N+B))`\n\n- 较好情况：取决于基数-多少个桶 (B << N时差不多是一个线性复杂度的算法)\n\n","slug":"Bucket-Sort","published":1,"updated":"2022-07-26T00:48:36.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vb80003ucuu6jl95adi","content":"<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><p><code>T(N,M) = O(M+N)</code>,M 个桶的情况</p>\n<ul>\n<li>N &gt;&gt; M的时候是相对教优秀的算法</li>\n<li>M &gt;&gt; N ???</li>\n</ul>\n</li>\n<li><p>假设我们有N = 10个整数，N ∈ [0,999],(此时 M = 1000)；我们便不能在线性时间下完成排序。</p>\n</li>\n</ul>\n<h3 id=\"基数排序：按照数字的进制排序（10）\"><a href=\"#基数排序：按照数字的进制排序（10）\" class=\"headerlink\" title=\"基数排序：按照数字的进制排序（10）\"></a>基数排序：按照数字的进制排序（10）</h3><ul>\n<li>example: </li>\n<li>input: 64 8 216 512 27 729 0 1 343 125 <ul>\n<li>使用次位优先(Least Significant Digit)</li>\n<li>先按照个位数将元素放到对应的桶Pass1</li>\n<li>按照十位放到对应的桶中</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Bucket</th>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th>6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Pass 1(个位)</td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\">51<font color=\"red\">2</font></td>\n<td align=\"center\">34<font color=\"red\">3</font></td>\n<td align=\"center\">6<font color=\"red\">4</font></td>\n<td align=\"center\">12<font color=\"red\">5</font></td>\n<td>21<font color=\"red\">6</font></td>\n<td align=\"center\">2<font color=\"red\">7</font></td>\n<td align=\"center\"><font color=\"red\">8</font></td>\n<td align=\"center\">72<font color=\"red\">9</font></td>\n</tr>\n<tr>\n<td align=\"center\">Pass 2(十位)</td>\n<td align=\"center\">0<br>1<br>8</td>\n<td align=\"center\">512<br>216</td>\n<td align=\"center\">125<br>27<br>729</td>\n<td align=\"center\"></td>\n<td align=\"center\">343</td>\n<td align=\"center\"></td>\n<td>64<br></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Pass 3 (百位)</td>\n<td align=\"center\">0<br>1<br>8<br>27<br>64</td>\n<td align=\"center\">125</td>\n<td align=\"center\">216</td>\n<td align=\"center\">343</td>\n<td align=\"center\"></td>\n<td align=\"center\">512</td>\n<td></td>\n<td align=\"center\">729</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li>最终的顺序，分别从每个桶中顺序读取即可。</li>\n</ul>\n<h4 id=\"时间复杂度：-T-O-P-N-B\"><a href=\"#时间复杂度：-T-O-P-N-B\" class=\"headerlink\" title=\"时间复杂度： T= O(P(N+B))\"></a>时间复杂度： <code>T= O(P(N+B))</code></h4><ul>\n<li>较好情况：取决于基数-多少个桶 (B &lt;&lt; N时差不多是一个线性复杂度的算法)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><p><code>T(N,M) = O(M+N)</code>,M 个桶的情况</p>\n<ul>\n<li>N &gt;&gt; M的时候是相对教优秀的算法</li>\n<li>M &gt;&gt; N ???</li>\n</ul>\n</li>\n<li><p>假设我们有N = 10个整数，N ∈ [0,999],(此时 M = 1000)；我们便不能在线性时间下完成排序。</p>\n</li>\n</ul>\n<h3 id=\"基数排序：按照数字的进制排序（10）\"><a href=\"#基数排序：按照数字的进制排序（10）\" class=\"headerlink\" title=\"基数排序：按照数字的进制排序（10）\"></a>基数排序：按照数字的进制排序（10）</h3><ul>\n<li>example: </li>\n<li>input: 64 8 216 512 27 729 0 1 343 125 <ul>\n<li>使用次位优先(Least Significant Digit)</li>\n<li>先按照个位数将元素放到对应的桶Pass1</li>\n<li>按照十位放到对应的桶中</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Bucket</th>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th>6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Pass 1(个位)</td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\">51<font color=\"red\">2</font></td>\n<td align=\"center\">34<font color=\"red\">3</font></td>\n<td align=\"center\">6<font color=\"red\">4</font></td>\n<td align=\"center\">12<font color=\"red\">5</font></td>\n<td>21<font color=\"red\">6</font></td>\n<td align=\"center\">2<font color=\"red\">7</font></td>\n<td align=\"center\"><font color=\"red\">8</font></td>\n<td align=\"center\">72<font color=\"red\">9</font></td>\n</tr>\n<tr>\n<td align=\"center\">Pass 2(十位)</td>\n<td align=\"center\">0<br>1<br>8</td>\n<td align=\"center\">512<br>216</td>\n<td align=\"center\">125<br>27<br>729</td>\n<td align=\"center\"></td>\n<td align=\"center\">343</td>\n<td align=\"center\"></td>\n<td>64<br></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Pass 3 (百位)</td>\n<td align=\"center\">0<br>1<br>8<br>27<br>64</td>\n<td align=\"center\">125</td>\n<td align=\"center\">216</td>\n<td align=\"center\">343</td>\n<td align=\"center\"></td>\n<td align=\"center\">512</td>\n<td></td>\n<td align=\"center\">729</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li>最终的顺序，分别从每个桶中顺序读取即可。</li>\n</ul>\n<h4 id=\"时间复杂度：-T-O-P-N-B\"><a href=\"#时间复杂度：-T-O-P-N-B\" class=\"headerlink\" title=\"时间复杂度： T= O(P(N+B))\"></a>时间复杂度： <code>T= O(P(N+B))</code></h4><ul>\n<li>较好情况：取决于基数-多少个桶 (B &lt;&lt; N时差不多是一个线性复杂度的算法)</li>\n</ul>\n"},{"title":"Bug奇遇记-uint16_t","date":"2021-03-19T12:47:11.000Z","_content":"\n### uint16_t \n\n- 标准定义中：\n\n```c++\ntypedef unsigned short  uint16_t; // max == _UI16_MAX 0xffffu \n```\n\n![uint16_t](https://raw.githubusercontent.com/CuntBoy/images/main/uint16_t.png \"uint16\")\n\n#### 问题：\n\n- <font color=red>这是一个粗心的问题</font>\n\n在我正在实现的功能中有一个数据遍历的部分，我使用了`uint16_t`类型作为索引的类型，但是`uint16_t`数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！\n\n---\n\n### 正确的结果展示：\n\n![lum_2](https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_2.png \"result\")\n\n\n\n![right result](https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_1.png \"Result\")\n\n","source":"_posts/Bug奇遇记-uint16-t.md","raw":"---\ntitle: Bug奇遇记-uint16_t\ndate: 2021-03-19 20:47:11\ncategories:\n- works\n- GF\n- data type\n- bugs\ntags:\n - cpp\n - osg\n---\n\n### uint16_t \n\n- 标准定义中：\n\n```c++\ntypedef unsigned short  uint16_t; // max == _UI16_MAX 0xffffu \n```\n\n![uint16_t](https://raw.githubusercontent.com/CuntBoy/images/main/uint16_t.png \"uint16\")\n\n#### 问题：\n\n- <font color=red>这是一个粗心的问题</font>\n\n在我正在实现的功能中有一个数据遍历的部分，我使用了`uint16_t`类型作为索引的类型，但是`uint16_t`数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！\n\n---\n\n### 正确的结果展示：\n\n![lum_2](https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_2.png \"result\")\n\n\n\n![right result](https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_1.png \"Result\")\n\n","slug":"Bug奇遇记-uint16-t","published":1,"updated":"2022-07-26T00:48:36.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbe0007ucuu18ggeu0k","content":"<h3 id=\"uint16-t\"><a href=\"#uint16-t\" class=\"headerlink\" title=\"uint16_t\"></a>uint16_t</h3><ul>\n<li>标准定义中：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>  <span class=\"keyword\">uint16_t</span>; <span class=\"comment\">// max == _UI16_MAX 0xffffu </span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/uint16_t.png\" alt=\"uint16_t\" title=\"uint16\"></p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><ul>\n<li><font color=\"red\">这是一个粗心的问题</font></li>\n</ul>\n<p>在我正在实现的功能中有一个数据遍历的部分，我使用了<code>uint16_t</code>类型作为索引的类型，但是<code>uint16_t</code>数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！</p>\n<hr>\n<h3 id=\"正确的结果展示：\"><a href=\"#正确的结果展示：\" class=\"headerlink\" title=\"正确的结果展示：\"></a>正确的结果展示：</h3><p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_2.png\" alt=\"lum_2\" title=\"result\"></p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_1.png\" alt=\"right result\" title=\"Result\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"uint16-t\"><a href=\"#uint16-t\" class=\"headerlink\" title=\"uint16_t\"></a>uint16_t</h3><ul>\n<li>标准定义中：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span>  <span class=\"keyword\">uint16_t</span>; <span class=\"comment\">// max == _UI16_MAX 0xffffu </span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/uint16_t.png\" alt=\"uint16_t\" title=\"uint16\"></p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><ul>\n<li><font color=\"red\">这是一个粗心的问题</font></li>\n</ul>\n<p>在我正在实现的功能中有一个数据遍历的部分，我使用了<code>uint16_t</code>类型作为索引的类型，但是<code>uint16_t</code>数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！</p>\n<hr>\n<h3 id=\"正确的结果展示：\"><a href=\"#正确的结果展示：\" class=\"headerlink\" title=\"正确的结果展示：\"></a>正确的结果展示：</h3><p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_2.png\" alt=\"lum_2\" title=\"result\"></p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/lum_arrow_1.png\" alt=\"right result\" title=\"Result\"></p>\n"},{"title":"Dynamic drawing of osg vertex buffer objects","date":"2021-11-06T16:36:24.000Z","_content":"\n### `Dynamic drawing of osg vertex buffer objects`\n\n- 使用`显示列表`绘制图形在速度上并没有`vertex buffer object`那么快，所以在更高的`osg`的版本中，推荐使用`vertex buffer object`\n\n- 在使用`vertex buffer object`的情况下，动态更新绘制的数据\n\n- 代码实现：\n```C++\n// 首先- 创建完成 osg::Geometry\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry;\n// 关闭显示列表 并使用vbo(vertex buffer object)\ngeom->setUseDisplayLists(false);\ngeom->setUseVertexBufferObject(true);\n// 修改几何体的绘制数据的类型 \ngeom->setDataVariance(osg::Object::DataVariance::DYNAMIC);\n//================================================================\n// 更新操作 \n// 先获取顶点数组 \nauto varray = dynamic_cast<osg::Vec3Array>(geom->getVertexArray());\n// 需改顶点数据\n// ---------------------你可以想数组中插入顶点-----------------------------------\n// 调用 dirty函数，告诉osg::Geometry你修改了顶点\nvarray->dirty();\n// 修改 PrimitiveSet(OpenGL的DrawArray(图元，开始点，绘制个数))\n// PrimitiveSet* osg::Geometry::getPrimitiveSet  ( unsigned int  pos ) \nauto pri_set = geom->getPrimitiveSet(0);\n// void  setNumInstances (int n) \npri_set->setNumInstances(修改后的顶点个数)；\npri_set->dirty();\n// 更新几何体\ngeom->dirty();\n```\n\n","source":"_posts/Dynamic-drawing-of-osg-vertex-buffer-objects.md","raw":"---\ntitle: Dynamic drawing of osg vertex buffer objects\ndate: 2021-11-07 00:36:24\ncategories: \n- works\n- HJ\n- OSG\ntags: \n- cpp\n- osg\n---\n\n### `Dynamic drawing of osg vertex buffer objects`\n\n- 使用`显示列表`绘制图形在速度上并没有`vertex buffer object`那么快，所以在更高的`osg`的版本中，推荐使用`vertex buffer object`\n\n- 在使用`vertex buffer object`的情况下，动态更新绘制的数据\n\n- 代码实现：\n```C++\n// 首先- 创建完成 osg::Geometry\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry;\n// 关闭显示列表 并使用vbo(vertex buffer object)\ngeom->setUseDisplayLists(false);\ngeom->setUseVertexBufferObject(true);\n// 修改几何体的绘制数据的类型 \ngeom->setDataVariance(osg::Object::DataVariance::DYNAMIC);\n//================================================================\n// 更新操作 \n// 先获取顶点数组 \nauto varray = dynamic_cast<osg::Vec3Array>(geom->getVertexArray());\n// 需改顶点数据\n// ---------------------你可以想数组中插入顶点-----------------------------------\n// 调用 dirty函数，告诉osg::Geometry你修改了顶点\nvarray->dirty();\n// 修改 PrimitiveSet(OpenGL的DrawArray(图元，开始点，绘制个数))\n// PrimitiveSet* osg::Geometry::getPrimitiveSet  ( unsigned int  pos ) \nauto pri_set = geom->getPrimitiveSet(0);\n// void  setNumInstances (int n) \npri_set->setNumInstances(修改后的顶点个数)；\npri_set->dirty();\n// 更新几何体\ngeom->dirty();\n```\n\n","slug":"Dynamic-drawing-of-osg-vertex-buffer-objects","published":1,"updated":"2022-07-26T00:48:36.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbh0009ucuu4004fwr3","content":"<h3 id=\"Dynamic-drawing-of-osg-vertex-buffer-objects\"><a href=\"#Dynamic-drawing-of-osg-vertex-buffer-objects\" class=\"headerlink\" title=\"Dynamic drawing of osg vertex buffer objects\"></a><code>Dynamic drawing of osg vertex buffer objects</code></h3><ul>\n<li><p>使用<code>显示列表</code>绘制图形在速度上并没有<code>vertex buffer object</code>那么快，所以在更高的<code>osg</code>的版本中，推荐使用<code>vertex buffer object</code></p>\n</li>\n<li><p>在使用<code>vertex buffer object</code>的情况下，动态更新绘制的数据</p>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先- 创建完成 osg::Geometry</span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry;</span><br><span class=\"line\"><span class=\"comment\">// 关闭显示列表 并使用vbo(vertex buffer object)</span></span><br><span class=\"line\">geom-&gt;setUseDisplayLists(<span class=\"literal\">false</span>);</span><br><span class=\"line\">geom-&gt;setUseVertexBufferObject(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改几何体的绘制数据的类型 </span></span><br><span class=\"line\">geom-&gt;setDataVariance(osg::Object::DataVariance::DYNAMIC);</span><br><span class=\"line\"><span class=\"comment\">//================================================================</span></span><br><span class=\"line\"><span class=\"comment\">// 更新操作 </span></span><br><span class=\"line\"><span class=\"comment\">// 先获取顶点数组 </span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> varray = <span class=\"keyword\">dynamic_cast</span>&lt;osg::Vec3Array&gt;(geom-&gt;getVertexArray());</span><br><span class=\"line\"><span class=\"comment\">// 需改顶点数据</span></span><br><span class=\"line\"><span class=\"comment\">// ---------------------你可以想数组中插入顶点-----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 调用 dirty函数，告诉osg::Geometry你修改了顶点</span></span><br><span class=\"line\">varray-&gt;dirty();</span><br><span class=\"line\"><span class=\"comment\">// 修改 PrimitiveSet(OpenGL的DrawArray(图元，开始点，绘制个数))</span></span><br><span class=\"line\"><span class=\"comment\">// PrimitiveSet* osg::Geometry::getPrimitiveSet  ( unsigned int  pos ) </span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pri_set = geom-&gt;getPrimitiveSet(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// void  setNumInstances (int n) </span></span><br><span class=\"line\">pri_set-&gt;setNumInstances(修改后的顶点个数)；</span><br><span class=\"line\">pri_set-&gt;dirty();</span><br><span class=\"line\"><span class=\"comment\">// 更新几何体</span></span><br><span class=\"line\">geom-&gt;dirty();</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Dynamic-drawing-of-osg-vertex-buffer-objects\"><a href=\"#Dynamic-drawing-of-osg-vertex-buffer-objects\" class=\"headerlink\" title=\"Dynamic drawing of osg vertex buffer objects\"></a><code>Dynamic drawing of osg vertex buffer objects</code></h3><ul>\n<li><p>使用<code>显示列表</code>绘制图形在速度上并没有<code>vertex buffer object</code>那么快，所以在更高的<code>osg</code>的版本中，推荐使用<code>vertex buffer object</code></p>\n</li>\n<li><p>在使用<code>vertex buffer object</code>的情况下，动态更新绘制的数据</p>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先- 创建完成 osg::Geometry</span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry;</span><br><span class=\"line\"><span class=\"comment\">// 关闭显示列表 并使用vbo(vertex buffer object)</span></span><br><span class=\"line\">geom-&gt;setUseDisplayLists(<span class=\"literal\">false</span>);</span><br><span class=\"line\">geom-&gt;setUseVertexBufferObject(<span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改几何体的绘制数据的类型 </span></span><br><span class=\"line\">geom-&gt;setDataVariance(osg::Object::DataVariance::DYNAMIC);</span><br><span class=\"line\"><span class=\"comment\">//================================================================</span></span><br><span class=\"line\"><span class=\"comment\">// 更新操作 </span></span><br><span class=\"line\"><span class=\"comment\">// 先获取顶点数组 </span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> varray = <span class=\"keyword\">dynamic_cast</span>&lt;osg::Vec3Array&gt;(geom-&gt;getVertexArray());</span><br><span class=\"line\"><span class=\"comment\">// 需改顶点数据</span></span><br><span class=\"line\"><span class=\"comment\">// ---------------------你可以想数组中插入顶点-----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 调用 dirty函数，告诉osg::Geometry你修改了顶点</span></span><br><span class=\"line\">varray-&gt;dirty();</span><br><span class=\"line\"><span class=\"comment\">// 修改 PrimitiveSet(OpenGL的DrawArray(图元，开始点，绘制个数))</span></span><br><span class=\"line\"><span class=\"comment\">// PrimitiveSet* osg::Geometry::getPrimitiveSet  ( unsigned int  pos ) </span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pri_set = geom-&gt;getPrimitiveSet(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// void  setNumInstances (int n) </span></span><br><span class=\"line\">pri_set-&gt;setNumInstances(修改后的顶点个数)；</span><br><span class=\"line\">pri_set-&gt;dirty();</span><br><span class=\"line\"><span class=\"comment\">// 更新几何体</span></span><br><span class=\"line\">geom-&gt;dirty();</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Games202-ShadowMap","date":"2021-12-13T14:25:25.000Z","_content":"\n## Shadow Map\n\n- 记录一下关于`Games202`的学习\n\n#### shadow map\n\n- 实现：通过比较当前的`point`,在光源空间的的深度与深度图中记录的深度的大小，决定当前的`point`是否在阴影中\n\n- 如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：\n\n  ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png)\n\n上图来自`Games202`的课件：\n\n- 阴影图`shadow map`记录了相机在光照位置下的最近最近深度。\n\n- 关于计算当前vertex point 是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-`lightPVM`)，用于将顶点转换到光空间。\n\n- 在`Games202`的作业1中，我们需要使用提供的matrix的接口处理矩阵。\n\n  ```javascript\n  mat.translate() // 设置矩阵的移动 \n  mat4.scale      // 设置矩阵的缩放\n  \n  mat4.lookAt(); // 生成的视图矩阵\n  mat4.ortho();  // 平行投影\n  \n  mat4.multiply(); // 矩阵的乘法\n  ```\n\n  [gl-matrix文档](https://www.icode9.com/content-4-956693.html)\n\n- 深度比较：\n\n  ```glsl\n  sampler2D shadowMap;   // 你的深度图\n  mat4 lightPVM;         // 光空间的变换矩阵\n  vec4 vertexPosition;   // 渲染的顶点坐标\n  \n  // 1： 将顶点变换到光空间 \n  vec4 vertex_light = lightPVM * vertexPosition;\n  // 2: 透视除法将顶点变换到NDC坐标\n  vec3 ndc_pos = vertex_light.xyz / vertex_light.w;\n  // 3: 将深度变到 0-1\n  ndc_pos = ndc_pos * 0.5 + 0.5；\n  // 4：获取深度图中记录的深度\n  // 5: 获取当前点在光空间下的实际深度\n  // 6: 比较两个深度的大小    \n  // 7：返回当前点是否在阴影中    \n  ```\n\n  \n\n- 最终效果\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png)\n","source":"_posts/Games202-ShadowMap.md","raw":"---\ntitle: Games202-ShadowMap\ndate: 2021-12-13 22:25:25\ncategories:\n- Computer Graph\ntags:\n- Games202\n- Shadow\n---\n\n## Shadow Map\n\n- 记录一下关于`Games202`的学习\n\n#### shadow map\n\n- 实现：通过比较当前的`point`,在光源空间的的深度与深度图中记录的深度的大小，决定当前的`point`是否在阴影中\n\n- 如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：\n\n  ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png)\n\n上图来自`Games202`的课件：\n\n- 阴影图`shadow map`记录了相机在光照位置下的最近最近深度。\n\n- 关于计算当前vertex point 是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-`lightPVM`)，用于将顶点转换到光空间。\n\n- 在`Games202`的作业1中，我们需要使用提供的matrix的接口处理矩阵。\n\n  ```javascript\n  mat.translate() // 设置矩阵的移动 \n  mat4.scale      // 设置矩阵的缩放\n  \n  mat4.lookAt(); // 生成的视图矩阵\n  mat4.ortho();  // 平行投影\n  \n  mat4.multiply(); // 矩阵的乘法\n  ```\n\n  [gl-matrix文档](https://www.icode9.com/content-4-956693.html)\n\n- 深度比较：\n\n  ```glsl\n  sampler2D shadowMap;   // 你的深度图\n  mat4 lightPVM;         // 光空间的变换矩阵\n  vec4 vertexPosition;   // 渲染的顶点坐标\n  \n  // 1： 将顶点变换到光空间 \n  vec4 vertex_light = lightPVM * vertexPosition;\n  // 2: 透视除法将顶点变换到NDC坐标\n  vec3 ndc_pos = vertex_light.xyz / vertex_light.w;\n  // 3: 将深度变到 0-1\n  ndc_pos = ndc_pos * 0.5 + 0.5；\n  // 4：获取深度图中记录的深度\n  // 5: 获取当前点在光空间下的实际深度\n  // 6: 比较两个深度的大小    \n  // 7：返回当前点是否在阴影中    \n  ```\n\n  \n\n- 最终效果\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png)\n","slug":"Games202-ShadowMap","published":1,"updated":"2022-07-26T00:48:36.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbi000aucuuek82h5j5","content":"<h2 id=\"Shadow-Map\"><a href=\"#Shadow-Map\" class=\"headerlink\" title=\"Shadow Map\"></a>Shadow Map</h2><ul>\n<li>记录一下关于<code>Games202</code>的学习</li>\n</ul>\n<h4 id=\"shadow-map\"><a href=\"#shadow-map\" class=\"headerlink\" title=\"shadow map\"></a>shadow map</h4><ul>\n<li><p>实现：通过比较当前的<code>point</code>,在光源空间的的深度与深度图中记录的深度的大小，决定当前的<code>point</code>是否在阴影中</p>\n</li>\n<li><p>如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png\"></p>\n</li>\n</ul>\n<p>上图来自<code>Games202</code>的课件：</p>\n<ul>\n<li><p>阴影图<code>shadow map</code>记录了相机在光照位置下的最近最近深度。</p>\n</li>\n<li><p>关于计算当前vertex point 是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-<code>lightPVM</code>)，用于将顶点转换到光空间。</p>\n</li>\n<li><p>在<code>Games202</code>的作业1中，我们需要使用提供的matrix的接口处理矩阵。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat.translate() <span class=\"comment\">// 设置矩阵的移动 </span></span><br><span class=\"line\">mat4.scale      <span class=\"comment\">// 设置矩阵的缩放</span></span><br><span class=\"line\"></span><br><span class=\"line\">mat4.lookAt(); <span class=\"comment\">// 生成的视图矩阵</span></span><br><span class=\"line\">mat4.ortho();  <span class=\"comment\">// 平行投影</span></span><br><span class=\"line\"></span><br><span class=\"line\">mat4.multiply(); <span class=\"comment\">// 矩阵的乘法</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.icode9.com/content-4-956693.html\">gl-matrix文档</a></p>\n</li>\n<li><p>深度比较：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">sampler2D</span> shadowMap;   <span class=\"comment\">// 你的深度图</span></span><br><span class=\"line\"><span class=\"type\">mat4</span> lightPVM;         <span class=\"comment\">// 光空间的变换矩阵</span></span><br><span class=\"line\"><span class=\"type\">vec4</span> vertexPosition;   <span class=\"comment\">// 渲染的顶点坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1： 将顶点变换到光空间 </span></span><br><span class=\"line\"><span class=\"type\">vec4</span> vertex_light = lightPVM * vertexPosition;</span><br><span class=\"line\"><span class=\"comment\">// 2: 透视除法将顶点变换到NDC坐标</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> ndc_pos = vertex_light.xyz / vertex_light.w;</span><br><span class=\"line\"><span class=\"comment\">// 3: 将深度变到 0-1</span></span><br><span class=\"line\">ndc_pos = ndc_pos * <span class=\"number\">0.5</span> + <span class=\"number\">0.5</span>；</span><br><span class=\"line\"><span class=\"comment\">// 4：获取深度图中记录的深度</span></span><br><span class=\"line\"><span class=\"comment\">// 5: 获取当前点在光空间下的实际深度</span></span><br><span class=\"line\"><span class=\"comment\">// 6: 比较两个深度的大小    </span></span><br><span class=\"line\"><span class=\"comment\">// 7：返回当前点是否在阴影中    </span></span><br></pre></td></tr></table></figure></li>\n<li><p>最终效果</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Shadow-Map\"><a href=\"#Shadow-Map\" class=\"headerlink\" title=\"Shadow Map\"></a>Shadow Map</h2><ul>\n<li>记录一下关于<code>Games202</code>的学习</li>\n</ul>\n<h4 id=\"shadow-map\"><a href=\"#shadow-map\" class=\"headerlink\" title=\"shadow map\"></a>shadow map</h4><ul>\n<li><p>实现：通过比较当前的<code>point</code>,在光源空间的的深度与深度图中记录的深度的大小，决定当前的<code>point</code>是否在阴影中</p>\n</li>\n<li><p>如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png\"></p>\n</li>\n</ul>\n<p>上图来自<code>Games202</code>的课件：</p>\n<ul>\n<li><p>阴影图<code>shadow map</code>记录了相机在光照位置下的最近最近深度。</p>\n</li>\n<li><p>关于计算当前vertex point 是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-<code>lightPVM</code>)，用于将顶点转换到光空间。</p>\n</li>\n<li><p>在<code>Games202</code>的作业1中，我们需要使用提供的matrix的接口处理矩阵。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mat.translate() <span class=\"comment\">// 设置矩阵的移动 </span></span><br><span class=\"line\">mat4.scale      <span class=\"comment\">// 设置矩阵的缩放</span></span><br><span class=\"line\"></span><br><span class=\"line\">mat4.lookAt(); <span class=\"comment\">// 生成的视图矩阵</span></span><br><span class=\"line\">mat4.ortho();  <span class=\"comment\">// 平行投影</span></span><br><span class=\"line\"></span><br><span class=\"line\">mat4.multiply(); <span class=\"comment\">// 矩阵的乘法</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.icode9.com/content-4-956693.html\">gl-matrix文档</a></p>\n</li>\n<li><p>深度比较：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">sampler2D</span> shadowMap;   <span class=\"comment\">// 你的深度图</span></span><br><span class=\"line\"><span class=\"type\">mat4</span> lightPVM;         <span class=\"comment\">// 光空间的变换矩阵</span></span><br><span class=\"line\"><span class=\"type\">vec4</span> vertexPosition;   <span class=\"comment\">// 渲染的顶点坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1： 将顶点变换到光空间 </span></span><br><span class=\"line\"><span class=\"type\">vec4</span> vertex_light = lightPVM * vertexPosition;</span><br><span class=\"line\"><span class=\"comment\">// 2: 透视除法将顶点变换到NDC坐标</span></span><br><span class=\"line\"><span class=\"type\">vec3</span> ndc_pos = vertex_light.xyz / vertex_light.w;</span><br><span class=\"line\"><span class=\"comment\">// 3: 将深度变到 0-1</span></span><br><span class=\"line\">ndc_pos = ndc_pos * <span class=\"number\">0.5</span> + <span class=\"number\">0.5</span>；</span><br><span class=\"line\"><span class=\"comment\">// 4：获取深度图中记录的深度</span></span><br><span class=\"line\"><span class=\"comment\">// 5: 获取当前点在光空间下的实际深度</span></span><br><span class=\"line\"><span class=\"comment\">// 6: 比较两个深度的大小    </span></span><br><span class=\"line\"><span class=\"comment\">// 7：返回当前点是否在阴影中    </span></span><br></pre></td></tr></table></figure></li>\n<li><p>最终效果</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png\"></p>\n"},{"title":"Git常用命令(上)","date":"2022-07-24T10:25:51.000Z","_content":"\n# Git常用命令\n---\n### `install Git`\n\n- Git -- [官方网站](https://git-scm.com/)\n\n\n","source":"_posts/Git常用命令-上.md","raw":"---\ntitle: Git常用命令(上)\ndate: 2022-07-24 18:25:51\ncategories:\n- works\n- SCU\ntags:\n- Git\n---\n\n# Git常用命令\n---\n### `install Git`\n\n- Git -- [官方网站](https://git-scm.com/)\n\n\n","slug":"Git常用命令-上","published":1,"updated":"2022-07-26T00:48:36.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbk000eucuuc3fw7ko7","content":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><hr>\n<h3 id=\"install-Git\"><a href=\"#install-Git\" class=\"headerlink\" title=\"install Git\"></a><code>install Git</code></h3><ul>\n<li>Git – <a href=\"https://git-scm.com/\">官方网站</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><hr>\n<h3 id=\"install-Git\"><a href=\"#install-Git\" class=\"headerlink\" title=\"install Git\"></a><code>install Git</code></h3><ul>\n<li>Git – <a href=\"https://git-scm.com/\">官方网站</a></li>\n</ul>\n"},{"title":"Heap","date":"2021-10-24T07:55:06.000Z","_content":"\n## 堆\n\n#### 优先队列(`Pripority Queue`)\n- 特殊的 \"队列\",取出元素的顺序是按照元素的优先级大小，而不是进入队列的先后顺序。\n- 使用数组构建：\n  - 插入：\n   &ensp;&ensp;&ensp;&ensp;&ensp;总是插入数组的尾部`T = O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：`T=O(N)`\n\t  &ensp;&ensp;&ensp;&ensp;&ensp;从数组中删除元素，需要将元素移动位置：`T=O(N)`\n- 链表构建：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;&ensp;总是插入链表的头部`T = O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：`T=O(N)`\n\t  &ensp;&ensp;&ensp;&ensp;&ensp;删除元素：`T=O(1)`\n- 有序数组：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;找到合适的位置:`T = O(N) or O(log2(N))`\n   &ensp;&ensp;&ensp;&ensp;移动元素并插入`T=O(N)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;删除最后一个元素：`T=O(1)`\n- 有序链表：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;找到合适的位置:`T = O(N)`\n   &ensp;&ensp;&ensp;&ensp;插入`T=O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;删除最后一个元素(或者首元素)：`T=O(1)`\n\n#### 最大堆 - 完全二叉树（大顶堆）\n\n- 根元素是当前树中最大的\n\n##### 1、堆的创建 -- 创建空堆\n\n```C++\ntypedef strut HeapStruct * MaxHeap;\nstruct HeadStruct{\n    ElementType * Elements;   // 存储元素的数组 \n    int Size;                 // 当前元素个数\n    int Capacity;             // 堆的最大容量\n}\n\n// 创建堆\nMaxHeap create(int MaxSize)\n{\n    MaxHeap H = malloc(sizeof(struct HeapStruct));\n    H->Elements = malloc((MaxSize+1) * sizeof(ElementType));\n    H->size = 0;\n    H->Capactity = MaxSize;\n    H->Elements[0] = MaxData;  // O号位置存储的是哨兵 不是个元素 \n\treturn H;\n}\n\n```\n\n\n\n##### 2，堆的插入\n\n```C++ \nvoid Insert(MaxHeap H,ElementType item)\n{\n    int i;\n    if(isFull(H))\n    {\n        std::cout<<\"最大堆已经满了\"<<std::endl;\n    }\n    i = ++H->Size;  // i等于 插入元素后的堆中的最后一个元素的下标\n    // 交换节点的位置 \n    for(;H->Elements[i/2] < item; i = i/2) // 如果I对应的那个插入元素 大于其父节点的数据 交换两个元素的值\n    {\n        H->Elements[i] = H->Elements[i/2];  // 覆盖结果\n    }\n    H->Elements[i] = item;\n}\n\n```\n\n##### 3、堆的删除\n\n```C++ \n// 取出根节点\n// 将最后一个元素放到根节点(保留树的特性)\n// 修改使其具有最大（最小）堆的特性\n\nEleementType deleteMax(MaxHeap H)\n{\n    int parent,child;\n    ElementType MaxChild,temp;\n    if(IsEmpty(H))\n    {\n        std::cout<<\"堆为空\"<<std::endl;\n        return ;\n    }\n    MaxItem = H->Elements[1]; // 取出根的最大值 \n    // 取出堆中最后一个元素， 并将Size - 1\n    temp = H->Elements[H->Size --];\n    // 调整数据的大小关系 \n    for(parent = 1; parent*2 < H->Size;parent = child)  // 是不是存在左孩子 \n    {\n        child = parent * 2;\n        // 比较左右孩子的大小\n        if((child != H->Size)) && (H->Elements[child] < H->Elements[child+1]))  // 当前child不是最后一个元素 \n        {\n            child++; \n        }\n        // 不满足交换条件 - 结束循环\n        if(temp > H->Elements[child])\n        {\n            break;\n        }\n        else\n        {\n            // 交换元素 \n            H->Elements[parent] = H->Elements[child];\n            \n        }\n    }\n    // 循环结束代表找到temp元素的合适安置位置 -- 放到合适的位置即可\n    H->Elements[parent] = temp;\n    return MaxItem;\n}\n\n```\n\n##### 4、最大堆的建立\n\n&ensp;&ensp;建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中\n\n&ensp;&ensp;1、通过插入操作，将N个元素一个一个的插入到空堆中去：`T = O(NlogN)`\n\n&ensp;&ensp;2、线性时间复杂度下建立最大堆\n\n​\t&ensp;&ensp;1、将元素安顺序输入，先构建完全二叉树（下标为1开始）\n\n&ensp;\t&ensp;2、调整元素位置，使其满足最大堆\n\n<a href=https://github.com/CuntBoy/Sort_Algorithm/tree/main/heap style=\"color:red\">Heap C++ 实现  </a>\n\n#### 最小堆- 完全二叉树（小顶堆）\n\n- 可以参照最大堆写\n\n","source":"_posts/Heap.md","raw":"---\ntitle: Heap \ndate: 2021-10-24 15:55:06\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n## 堆\n\n#### 优先队列(`Pripority Queue`)\n- 特殊的 \"队列\",取出元素的顺序是按照元素的优先级大小，而不是进入队列的先后顺序。\n- 使用数组构建：\n  - 插入：\n   &ensp;&ensp;&ensp;&ensp;&ensp;总是插入数组的尾部`T = O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：`T=O(N)`\n\t  &ensp;&ensp;&ensp;&ensp;&ensp;从数组中删除元素，需要将元素移动位置：`T=O(N)`\n- 链表构建：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;&ensp;总是插入链表的头部`T = O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：`T=O(N)`\n\t  &ensp;&ensp;&ensp;&ensp;&ensp;删除元素：`T=O(1)`\n- 有序数组：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;找到合适的位置:`T = O(N) or O(log2(N))`\n   &ensp;&ensp;&ensp;&ensp;移动元素并插入`T=O(N)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;删除最后一个元素：`T=O(1)`\n- 有序链表：\n    - 插入：\n   &ensp;&ensp;&ensp;&ensp;找到合适的位置:`T = O(N)`\n   &ensp;&ensp;&ensp;&ensp;插入`T=O(1)`\n  - 删除：\n\t &ensp;&ensp;&ensp;&ensp;删除最后一个元素(或者首元素)：`T=O(1)`\n\n#### 最大堆 - 完全二叉树（大顶堆）\n\n- 根元素是当前树中最大的\n\n##### 1、堆的创建 -- 创建空堆\n\n```C++\ntypedef strut HeapStruct * MaxHeap;\nstruct HeadStruct{\n    ElementType * Elements;   // 存储元素的数组 \n    int Size;                 // 当前元素个数\n    int Capacity;             // 堆的最大容量\n}\n\n// 创建堆\nMaxHeap create(int MaxSize)\n{\n    MaxHeap H = malloc(sizeof(struct HeapStruct));\n    H->Elements = malloc((MaxSize+1) * sizeof(ElementType));\n    H->size = 0;\n    H->Capactity = MaxSize;\n    H->Elements[0] = MaxData;  // O号位置存储的是哨兵 不是个元素 \n\treturn H;\n}\n\n```\n\n\n\n##### 2，堆的插入\n\n```C++ \nvoid Insert(MaxHeap H,ElementType item)\n{\n    int i;\n    if(isFull(H))\n    {\n        std::cout<<\"最大堆已经满了\"<<std::endl;\n    }\n    i = ++H->Size;  // i等于 插入元素后的堆中的最后一个元素的下标\n    // 交换节点的位置 \n    for(;H->Elements[i/2] < item; i = i/2) // 如果I对应的那个插入元素 大于其父节点的数据 交换两个元素的值\n    {\n        H->Elements[i] = H->Elements[i/2];  // 覆盖结果\n    }\n    H->Elements[i] = item;\n}\n\n```\n\n##### 3、堆的删除\n\n```C++ \n// 取出根节点\n// 将最后一个元素放到根节点(保留树的特性)\n// 修改使其具有最大（最小）堆的特性\n\nEleementType deleteMax(MaxHeap H)\n{\n    int parent,child;\n    ElementType MaxChild,temp;\n    if(IsEmpty(H))\n    {\n        std::cout<<\"堆为空\"<<std::endl;\n        return ;\n    }\n    MaxItem = H->Elements[1]; // 取出根的最大值 \n    // 取出堆中最后一个元素， 并将Size - 1\n    temp = H->Elements[H->Size --];\n    // 调整数据的大小关系 \n    for(parent = 1; parent*2 < H->Size;parent = child)  // 是不是存在左孩子 \n    {\n        child = parent * 2;\n        // 比较左右孩子的大小\n        if((child != H->Size)) && (H->Elements[child] < H->Elements[child+1]))  // 当前child不是最后一个元素 \n        {\n            child++; \n        }\n        // 不满足交换条件 - 结束循环\n        if(temp > H->Elements[child])\n        {\n            break;\n        }\n        else\n        {\n            // 交换元素 \n            H->Elements[parent] = H->Elements[child];\n            \n        }\n    }\n    // 循环结束代表找到temp元素的合适安置位置 -- 放到合适的位置即可\n    H->Elements[parent] = temp;\n    return MaxItem;\n}\n\n```\n\n##### 4、最大堆的建立\n\n&ensp;&ensp;建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中\n\n&ensp;&ensp;1、通过插入操作，将N个元素一个一个的插入到空堆中去：`T = O(NlogN)`\n\n&ensp;&ensp;2、线性时间复杂度下建立最大堆\n\n​\t&ensp;&ensp;1、将元素安顺序输入，先构建完全二叉树（下标为1开始）\n\n&ensp;\t&ensp;2、调整元素位置，使其满足最大堆\n\n<a href=https://github.com/CuntBoy/Sort_Algorithm/tree/main/heap style=\"color:red\">Heap C++ 实现  </a>\n\n#### 最小堆- 完全二叉树（小顶堆）\n\n- 可以参照最大堆写\n\n","slug":"Heap","published":1,"updated":"2022-07-26T00:48:36.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbl000fucuu00shevux","content":"<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h4 id=\"优先队列-Pripority-Queue\"><a href=\"#优先队列-Pripority-Queue\" class=\"headerlink\" title=\"优先队列(Pripority Queue)\"></a>优先队列(<code>Pripority Queue</code>)</h4><ul>\n<li>特殊的 “队列”,取出元素的顺序是按照元素的优先级大小，而不是进入队列的先后顺序。</li>\n<li>使用数组构建：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;&ensp;总是插入数组的尾部<code>T = O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：<code>T=O(N)</code><br>  &ensp;&ensp;&ensp;&ensp;&ensp;从数组中删除元素，需要将元素移动位置：<code>T=O(N)</code></li>\n</ul>\n</li>\n<li>链表构建：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;&ensp;总是插入链表的头部<code>T = O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：<code>T=O(N)</code><br>  &ensp;&ensp;&ensp;&ensp;&ensp;删除元素：<code>T=O(1)</code></li>\n</ul>\n</li>\n<li>有序数组：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;找到合适的位置:<code>T = O(N) or O(log2(N))</code><br>&ensp;&ensp;&ensp;&ensp;移动元素并插入<code>T=O(N)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;删除最后一个元素：<code>T=O(1)</code></li>\n</ul>\n</li>\n<li>有序链表：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;找到合适的位置:<code>T = O(N)</code><br>&ensp;&ensp;&ensp;&ensp;插入<code>T=O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;删除最后一个元素(或者首元素)：<code>T=O(1)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"最大堆-完全二叉树（大顶堆）\"><a href=\"#最大堆-完全二叉树（大顶堆）\" class=\"headerlink\" title=\"最大堆 - 完全二叉树（大顶堆）\"></a>最大堆 - 完全二叉树（大顶堆）</h4><ul>\n<li>根元素是当前树中最大的</li>\n</ul>\n<h5 id=\"1、堆的创建-–-创建空堆\"><a href=\"#1、堆的创建-–-创建空堆\" class=\"headerlink\" title=\"1、堆的创建 – 创建空堆\"></a>1、堆的创建 – 创建空堆</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> strut HeapStruct * MaxHeap;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeadStruct</span>&#123;</span></span><br><span class=\"line\">    ElementType * Elements;   <span class=\"comment\">// 存储元素的数组 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Size;                 <span class=\"comment\">// 当前元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Capacity;             <span class=\"comment\">// 堆的最大容量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\">MaxHeap <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MaxHeap H = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct HeapStruct));</span><br><span class=\"line\">    H-&gt;Elements = <span class=\"built_in\">malloc</span>((MaxSize+<span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(ElementType));</span><br><span class=\"line\">    H-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    H-&gt;Capactity = MaxSize;</span><br><span class=\"line\">    H-&gt;Elements[<span class=\"number\">0</span>] = MaxData;  <span class=\"comment\">// O号位置存储的是哨兵 不是个元素 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> H;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2，堆的插入\"><a href=\"#2，堆的插入\" class=\"headerlink\" title=\"2，堆的插入\"></a>2，堆的插入</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(MaxHeap H,ElementType item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFull(H))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;最大堆已经满了&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = ++H-&gt;Size;  <span class=\"comment\">// i等于 插入元素后的堆中的最后一个元素的下标</span></span><br><span class=\"line\">    <span class=\"comment\">// 交换节点的位置 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;H-&gt;Elements[i/<span class=\"number\">2</span>] &lt; item; i = i/<span class=\"number\">2</span>) <span class=\"comment\">// 如果I对应的那个插入元素 大于其父节点的数据 交换两个元素的值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class=\"number\">2</span>];  <span class=\"comment\">// 覆盖结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    H-&gt;Elements[i] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3、堆的删除\"><a href=\"#3、堆的删除\" class=\"headerlink\" title=\"3、堆的删除\"></a>3、堆的删除</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取出根节点</span></span><br><span class=\"line\"><span class=\"comment\">// 将最后一个元素放到根节点(保留树的特性)</span></span><br><span class=\"line\"><span class=\"comment\">// 修改使其具有最大（最小）堆的特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EleementType <span class=\"title\">deleteMax</span><span class=\"params\">(MaxHeap H)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> parent,child;</span><br><span class=\"line\">    ElementType MaxChild,temp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(IsEmpty(H))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;堆为空&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MaxItem = H-&gt;Elements[<span class=\"number\">1</span>]; <span class=\"comment\">// 取出根的最大值 </span></span><br><span class=\"line\">    <span class=\"comment\">// 取出堆中最后一个元素， 并将Size - 1</span></span><br><span class=\"line\">    temp = H-&gt;Elements[H-&gt;Size --];</span><br><span class=\"line\">    <span class=\"comment\">// 调整数据的大小关系 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(parent = <span class=\"number\">1</span>; parent*<span class=\"number\">2</span> &lt; H-&gt;Size;parent = child)  <span class=\"comment\">// 是不是存在左孩子 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 比较左右孩子的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((child != H-&gt;Size)) &amp;&amp; (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class=\"number\">1</span>]))  <span class=\"comment\">// 当前child不是最后一个元素 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            child++; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不满足交换条件 - 结束循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp &gt; H-&gt;Elements[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 交换元素 </span></span><br><span class=\"line\">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环结束代表找到temp元素的合适安置位置 -- 放到合适的位置即可</span></span><br><span class=\"line\">    H-&gt;Elements[parent] = temp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4、最大堆的建立\"><a href=\"#4、最大堆的建立\" class=\"headerlink\" title=\"4、最大堆的建立\"></a>4、最大堆的建立</h5><p>&ensp;&ensp;建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中</p>\n<p>&ensp;&ensp;1、通过插入操作，将N个元素一个一个的插入到空堆中去：<code>T = O(NlogN)</code></p>\n<p>&ensp;&ensp;2、线性时间复杂度下建立最大堆</p>\n<p>​    &ensp;&ensp;1、将元素安顺序输入，先构建完全二叉树（下标为1开始）</p>\n<p>&ensp;    &ensp;2、调整元素位置，使其满足最大堆</p>\n<p><a href=\"https://github.com/CuntBoy/Sort_Algorithm/tree/main/heap\" style=\"color:red\">Heap C++ 实现  </a></p>\n<h4 id=\"最小堆-完全二叉树（小顶堆）\"><a href=\"#最小堆-完全二叉树（小顶堆）\" class=\"headerlink\" title=\"最小堆- 完全二叉树（小顶堆）\"></a>最小堆- 完全二叉树（小顶堆）</h4><ul>\n<li>可以参照最大堆写</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><h4 id=\"优先队列-Pripority-Queue\"><a href=\"#优先队列-Pripority-Queue\" class=\"headerlink\" title=\"优先队列(Pripority Queue)\"></a>优先队列(<code>Pripority Queue</code>)</h4><ul>\n<li>特殊的 “队列”,取出元素的顺序是按照元素的优先级大小，而不是进入队列的先后顺序。</li>\n<li>使用数组构建：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;&ensp;总是插入数组的尾部<code>T = O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：<code>T=O(N)</code><br>  &ensp;&ensp;&ensp;&ensp;&ensp;从数组中删除元素，需要将元素移动位置：<code>T=O(N)</code></li>\n</ul>\n</li>\n<li>链表构建：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;&ensp;总是插入链表的头部<code>T = O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;&ensp;查找到最大的(最小的元素)：<code>T=O(N)</code><br>  &ensp;&ensp;&ensp;&ensp;&ensp;删除元素：<code>T=O(1)</code></li>\n</ul>\n</li>\n<li>有序数组：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;找到合适的位置:<code>T = O(N) or O(log2(N))</code><br>&ensp;&ensp;&ensp;&ensp;移动元素并插入<code>T=O(N)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;删除最后一个元素：<code>T=O(1)</code></li>\n</ul>\n</li>\n<li>有序链表：<ul>\n<li>插入：<br>&ensp;&ensp;&ensp;&ensp;找到合适的位置:<code>T = O(N)</code><br>&ensp;&ensp;&ensp;&ensp;插入<code>T=O(1)</code></li>\n<li>删除：<br> &ensp;&ensp;&ensp;&ensp;删除最后一个元素(或者首元素)：<code>T=O(1)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"最大堆-完全二叉树（大顶堆）\"><a href=\"#最大堆-完全二叉树（大顶堆）\" class=\"headerlink\" title=\"最大堆 - 完全二叉树（大顶堆）\"></a>最大堆 - 完全二叉树（大顶堆）</h4><ul>\n<li>根元素是当前树中最大的</li>\n</ul>\n<h5 id=\"1、堆的创建-–-创建空堆\"><a href=\"#1、堆的创建-–-创建空堆\" class=\"headerlink\" title=\"1、堆的创建 – 创建空堆\"></a>1、堆的创建 – 创建空堆</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> strut HeapStruct * MaxHeap;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HeadStruct</span>&#123;</span></span><br><span class=\"line\">    ElementType * Elements;   <span class=\"comment\">// 存储元素的数组 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Size;                 <span class=\"comment\">// 当前元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> Capacity;             <span class=\"comment\">// 堆的最大容量</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\">MaxHeap <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">int</span> MaxSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MaxHeap H = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(struct HeapStruct));</span><br><span class=\"line\">    H-&gt;Elements = <span class=\"built_in\">malloc</span>((MaxSize+<span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(ElementType));</span><br><span class=\"line\">    H-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    H-&gt;Capactity = MaxSize;</span><br><span class=\"line\">    H-&gt;Elements[<span class=\"number\">0</span>] = MaxData;  <span class=\"comment\">// O号位置存储的是哨兵 不是个元素 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> H;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2，堆的插入\"><a href=\"#2，堆的插入\" class=\"headerlink\" title=\"2，堆的插入\"></a>2，堆的插入</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insert</span><span class=\"params\">(MaxHeap H,ElementType item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFull(H))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;最大堆已经满了&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i = ++H-&gt;Size;  <span class=\"comment\">// i等于 插入元素后的堆中的最后一个元素的下标</span></span><br><span class=\"line\">    <span class=\"comment\">// 交换节点的位置 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;H-&gt;Elements[i/<span class=\"number\">2</span>] &lt; item; i = i/<span class=\"number\">2</span>) <span class=\"comment\">// 如果I对应的那个插入元素 大于其父节点的数据 交换两个元素的值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class=\"number\">2</span>];  <span class=\"comment\">// 覆盖结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    H-&gt;Elements[i] = item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3、堆的删除\"><a href=\"#3、堆的删除\" class=\"headerlink\" title=\"3、堆的删除\"></a>3、堆的删除</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取出根节点</span></span><br><span class=\"line\"><span class=\"comment\">// 将最后一个元素放到根节点(保留树的特性)</span></span><br><span class=\"line\"><span class=\"comment\">// 修改使其具有最大（最小）堆的特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EleementType <span class=\"title\">deleteMax</span><span class=\"params\">(MaxHeap H)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> parent,child;</span><br><span class=\"line\">    ElementType MaxChild,temp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(IsEmpty(H))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;堆为空&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    MaxItem = H-&gt;Elements[<span class=\"number\">1</span>]; <span class=\"comment\">// 取出根的最大值 </span></span><br><span class=\"line\">    <span class=\"comment\">// 取出堆中最后一个元素， 并将Size - 1</span></span><br><span class=\"line\">    temp = H-&gt;Elements[H-&gt;Size --];</span><br><span class=\"line\">    <span class=\"comment\">// 调整数据的大小关系 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(parent = <span class=\"number\">1</span>; parent*<span class=\"number\">2</span> &lt; H-&gt;Size;parent = child)  <span class=\"comment\">// 是不是存在左孩子 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        child = parent * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 比较左右孩子的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((child != H-&gt;Size)) &amp;&amp; (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class=\"number\">1</span>]))  <span class=\"comment\">// 当前child不是最后一个元素 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            child++; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不满足交换条件 - 结束循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp &gt; H-&gt;Elements[child])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 交换元素 </span></span><br><span class=\"line\">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环结束代表找到temp元素的合适安置位置 -- 放到合适的位置即可</span></span><br><span class=\"line\">    H-&gt;Elements[parent] = temp;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxItem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4、最大堆的建立\"><a href=\"#4、最大堆的建立\" class=\"headerlink\" title=\"4、最大堆的建立\"></a>4、最大堆的建立</h5><p>&ensp;&ensp;建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中</p>\n<p>&ensp;&ensp;1、通过插入操作，将N个元素一个一个的插入到空堆中去：<code>T = O(NlogN)</code></p>\n<p>&ensp;&ensp;2、线性时间复杂度下建立最大堆</p>\n<p>​    &ensp;&ensp;1、将元素安顺序输入，先构建完全二叉树（下标为1开始）</p>\n<p>&ensp;    &ensp;2、调整元素位置，使其满足最大堆</p>\n<p><a href=\"https://github.com/CuntBoy/Sort_Algorithm/tree/main/heap\" style=\"color:red\">Heap C++ 实现  </a></p>\n<h4 id=\"最小堆-完全二叉树（小顶堆）\"><a href=\"#最小堆-完全二叉树（小顶堆）\" class=\"headerlink\" title=\"最小堆- 完全二叉树（小顶堆）\"></a>最小堆- 完全二叉树（小顶堆）</h4><ul>\n<li>可以参照最大堆写</li>\n</ul>\n"},{"title":"Multi KeyWord Sort","date":"2021-11-07T14:18:51.000Z","_content":"\n### 多关键字排序\n\n- 扑克牌的例子\n\n- 一副扑克牌是按照两种顺序排的：\n  - K0,花色：梅花 < 方块 < 红桃 < 黑桃\n  - k1，面值: 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < 10 < J < Q < K < A\n- 主位优先：（Most Significant Digit）\n  - 先用四个花色建桶，然后使用面值建桶\n\n#### 一个更好的方法：\n\n- 依旧使用次位优先：\n\n  - 先使用面值建桶\n\n  - 然后按照大小将结果合并，使用花色建桶。\n\n  - 最终的输出结果便是有序的\n\n    \n","source":"_posts/Multi-KeyWord-Sort.md","raw":"---\ntitle: Multi KeyWord Sort\ndate: 2021-11-07 22:18:51\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n### 多关键字排序\n\n- 扑克牌的例子\n\n- 一副扑克牌是按照两种顺序排的：\n  - K0,花色：梅花 < 方块 < 红桃 < 黑桃\n  - k1，面值: 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < 10 < J < Q < K < A\n- 主位优先：（Most Significant Digit）\n  - 先用四个花色建桶，然后使用面值建桶\n\n#### 一个更好的方法：\n\n- 依旧使用次位优先：\n\n  - 先使用面值建桶\n\n  - 然后按照大小将结果合并，使用花色建桶。\n\n  - 最终的输出结果便是有序的\n\n    \n","slug":"Multi-KeyWord-Sort","published":1,"updated":"2022-07-26T00:48:36.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbn000iucuu0k9i2qdz","content":"<h3 id=\"多关键字排序\"><a href=\"#多关键字排序\" class=\"headerlink\" title=\"多关键字排序\"></a>多关键字排序</h3><ul>\n<li><p>扑克牌的例子</p>\n</li>\n<li><p>一副扑克牌是按照两种顺序排的：</p>\n<ul>\n<li>K0,花色：梅花 &lt; 方块 &lt; 红桃 &lt; 黑桃</li>\n<li>k1，面值: 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</li>\n</ul>\n</li>\n<li><p>主位优先：（Most Significant Digit）</p>\n<ul>\n<li>先用四个花色建桶，然后使用面值建桶</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"一个更好的方法：\"><a href=\"#一个更好的方法：\" class=\"headerlink\" title=\"一个更好的方法：\"></a>一个更好的方法：</h4><ul>\n<li><p>依旧使用次位优先：</p>\n<ul>\n<li><p>先使用面值建桶</p>\n</li>\n<li><p>然后按照大小将结果合并，使用花色建桶。</p>\n</li>\n<li><p>最终的输出结果便是有序的</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"多关键字排序\"><a href=\"#多关键字排序\" class=\"headerlink\" title=\"多关键字排序\"></a>多关键字排序</h3><ul>\n<li><p>扑克牌的例子</p>\n</li>\n<li><p>一副扑克牌是按照两种顺序排的：</p>\n<ul>\n<li>K0,花色：梅花 &lt; 方块 &lt; 红桃 &lt; 黑桃</li>\n<li>k1，面值: 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</li>\n</ul>\n</li>\n<li><p>主位优先：（Most Significant Digit）</p>\n<ul>\n<li>先用四个花色建桶，然后使用面值建桶</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"一个更好的方法：\"><a href=\"#一个更好的方法：\" class=\"headerlink\" title=\"一个更好的方法：\"></a>一个更好的方法：</h4><ul>\n<li><p>依旧使用次位优先：</p>\n<ul>\n<li><p>先使用面值建桶</p>\n</li>\n<li><p>然后按照大小将结果合并，使用花色建桶。</p>\n</li>\n<li><p>最终的输出结果便是有序的</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"OSG-HUD","date":"2021-07-26T14:40:11.000Z","_content":"\n# OSG-HUD\n\n- <p>\"HUD\"在渲染的场景中算是比较常见的存在: 游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...</p>\n\n<b style=\"color:red\">如何创建HUD ？</b> \n\n<p>本质上说，HUD就是一个相机( 在`OSG`中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行</p>\n\n<b style=\"color:red\">实现要点，如下：</b>\n\n- 关闭节点的光照，保证整个视口显示的场景的亮度是一样的。\n- 关闭深度测试\n- 调整渲染的顺序为最后渲染，让`HUD`显示在整个场景的最前方\n- 设置参考帧为绝对参考帧\n- 设置变换矩阵,不受父节点的影响\n- 设置投影矩阵(平行投影或者透视),设置视口的大小。\n\n\n\n## Create HUD\n\n### 1、创建相机节点\n\n```C++\nosg::ref_ptr<osg::Camera> hud_camera = new osg::Camera;   // 创建相机的节点\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry;      // 创建绘制的节点(也可以是文字)\n```\n\n### 2、设置投影矩阵\n\n```C++\nhud_camera->setProjectionMatrixAsOrtho2D(-3, 4, -3, 4, -1.0, 100);  // 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小\n```\n\n### 3、设置视口大小(ViewPort)\n\n```C++\n// void setViewport(osg::Viewport* viewport);\n// void setViewport(int x,int y,int width,int height);\nhud_camera->setviewport();  // 两种方式都是可以的 \n```\n\n### 4、设置渲染的顺序\n\n```C++\nhud_camera->setRenderOrder(osg::Camera::POST_RENDER);\n```\n\n### 5、设置参考帧\n\n```C++\nhud_camera->setReferenceFrame(osg::Transform::ABSOLUTE_RF);\n```\n\n### 6、设置不受父节点的影响\n\n```C++\nhud_camera->setViewMatrix(osg::Matrix::identity());\n```\n\n### 7、设置不获取焦点\n\n```C++\nhud_camera->setAllowEventFocus(false);\n```\n\n### 8、设置节点的更新回调\n\n```C++\n// void setUpdateCallback(Callback* nc);\n// 需要重写一个节点的更新回调 修改节点的视图矩阵 \n// 设置相机的三个参数  \n// 视点 相机的位置 相机的向上方向\nhud_camera->setUpdateCallback();\n```\n\n## 挂载节点\n\n### 1、将前面创建的几何节点挂载到 相机上\n\n```C++\nosg::ref_ptr<osg::Geode> node = new osg::Geode;\nnode->addChild(geom.get());\nhud_camera->addChild(node.get());\n```\n\n### 2、设置节点的属性\n\n- 关闭光照 深度测试 & 打开混溶\n\n```C++\nauto states = node->getOrCreateStateSet();\nstates->setMode(GL_LIGHTING, osg::StateAttribute::ON);   //关闭灯光\nstates->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);//关闭深度测试\nstates->setMode(GL_BLEND, osg::StateAttribute::ON);  \n```\n\n\n\n","source":"_posts/OSG-HUD.md","raw":"---\ntitle: OSG-HUD\ndate: 2021-07-26 22:40:11\ncategories:\n - works\n - GF\ntags:\n- cpp\n- osg\n---\n\n# OSG-HUD\n\n- <p>\"HUD\"在渲染的场景中算是比较常见的存在: 游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...</p>\n\n<b style=\"color:red\">如何创建HUD ？</b> \n\n<p>本质上说，HUD就是一个相机( 在`OSG`中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行</p>\n\n<b style=\"color:red\">实现要点，如下：</b>\n\n- 关闭节点的光照，保证整个视口显示的场景的亮度是一样的。\n- 关闭深度测试\n- 调整渲染的顺序为最后渲染，让`HUD`显示在整个场景的最前方\n- 设置参考帧为绝对参考帧\n- 设置变换矩阵,不受父节点的影响\n- 设置投影矩阵(平行投影或者透视),设置视口的大小。\n\n\n\n## Create HUD\n\n### 1、创建相机节点\n\n```C++\nosg::ref_ptr<osg::Camera> hud_camera = new osg::Camera;   // 创建相机的节点\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry;      // 创建绘制的节点(也可以是文字)\n```\n\n### 2、设置投影矩阵\n\n```C++\nhud_camera->setProjectionMatrixAsOrtho2D(-3, 4, -3, 4, -1.0, 100);  // 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小\n```\n\n### 3、设置视口大小(ViewPort)\n\n```C++\n// void setViewport(osg::Viewport* viewport);\n// void setViewport(int x,int y,int width,int height);\nhud_camera->setviewport();  // 两种方式都是可以的 \n```\n\n### 4、设置渲染的顺序\n\n```C++\nhud_camera->setRenderOrder(osg::Camera::POST_RENDER);\n```\n\n### 5、设置参考帧\n\n```C++\nhud_camera->setReferenceFrame(osg::Transform::ABSOLUTE_RF);\n```\n\n### 6、设置不受父节点的影响\n\n```C++\nhud_camera->setViewMatrix(osg::Matrix::identity());\n```\n\n### 7、设置不获取焦点\n\n```C++\nhud_camera->setAllowEventFocus(false);\n```\n\n### 8、设置节点的更新回调\n\n```C++\n// void setUpdateCallback(Callback* nc);\n// 需要重写一个节点的更新回调 修改节点的视图矩阵 \n// 设置相机的三个参数  \n// 视点 相机的位置 相机的向上方向\nhud_camera->setUpdateCallback();\n```\n\n## 挂载节点\n\n### 1、将前面创建的几何节点挂载到 相机上\n\n```C++\nosg::ref_ptr<osg::Geode> node = new osg::Geode;\nnode->addChild(geom.get());\nhud_camera->addChild(node.get());\n```\n\n### 2、设置节点的属性\n\n- 关闭光照 深度测试 & 打开混溶\n\n```C++\nauto states = node->getOrCreateStateSet();\nstates->setMode(GL_LIGHTING, osg::StateAttribute::ON);   //关闭灯光\nstates->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);//关闭深度测试\nstates->setMode(GL_BLEND, osg::StateAttribute::ON);  \n```\n\n\n\n","slug":"OSG-HUD","published":1,"updated":"2022-07-26T00:48:36.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbr000jucuu07436xgb","content":"<h1 id=\"OSG-HUD\"><a href=\"#OSG-HUD\" class=\"headerlink\" title=\"OSG-HUD\"></a>OSG-HUD</h1><ul>\n<li><p>\"HUD\"在渲染的场景中算是比较常见的存在: 游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...</p></li>\n</ul>\n<p><b style=\"color:red\">如何创建HUD ？</b> </p>\n<p>本质上说，HUD就是一个相机( 在`OSG`中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行</p>\n\n<p><b style=\"color:red\">实现要点，如下：</b></p>\n<ul>\n<li>关闭节点的光照，保证整个视口显示的场景的亮度是一样的。</li>\n<li>关闭深度测试</li>\n<li>调整渲染的顺序为最后渲染，让<code>HUD</code>显示在整个场景的最前方</li>\n<li>设置参考帧为绝对参考帧</li>\n<li>设置变换矩阵,不受父节点的影响</li>\n<li>设置投影矩阵(平行投影或者透视),设置视口的大小。</li>\n</ul>\n<h2 id=\"Create-HUD\"><a href=\"#Create-HUD\" class=\"headerlink\" title=\"Create HUD\"></a>Create HUD</h2><h3 id=\"1、创建相机节点\"><a href=\"#1、创建相机节点\" class=\"headerlink\" title=\"1、创建相机节点\"></a>1、创建相机节点</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::ref_ptr&lt;osg::Camera&gt; hud_camera = <span class=\"keyword\">new</span> osg::Camera;   <span class=\"comment\">// 创建相机的节点</span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry;      <span class=\"comment\">// 创建绘制的节点(也可以是文字)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、设置投影矩阵\"><a href=\"#2、设置投影矩阵\" class=\"headerlink\" title=\"2、设置投影矩阵\"></a>2、设置投影矩阵</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setProjectionMatrixAsOrtho2D(<span class=\"number\">-3</span>, <span class=\"number\">4</span>, <span class=\"number\">-3</span>, <span class=\"number\">4</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">100</span>);  <span class=\"comment\">// 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、设置视口大小-ViewPort\"><a href=\"#3、设置视口大小-ViewPort\" class=\"headerlink\" title=\"3、设置视口大小(ViewPort)\"></a>3、设置视口大小(ViewPort)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void setViewport(osg::Viewport* viewport);</span></span><br><span class=\"line\"><span class=\"comment\">// void setViewport(int x,int y,int width,int height);</span></span><br><span class=\"line\">hud_camera-&gt;setviewport();  <span class=\"comment\">// 两种方式都是可以的 </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、设置渲染的顺序\"><a href=\"#4、设置渲染的顺序\" class=\"headerlink\" title=\"4、设置渲染的顺序\"></a>4、设置渲染的顺序</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setRenderOrder(osg::Camera::POST_RENDER);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、设置参考帧\"><a href=\"#5、设置参考帧\" class=\"headerlink\" title=\"5、设置参考帧\"></a>5、设置参考帧</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、设置不受父节点的影响\"><a href=\"#6、设置不受父节点的影响\" class=\"headerlink\" title=\"6、设置不受父节点的影响\"></a>6、设置不受父节点的影响</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setViewMatrix(osg::Matrix::identity());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、设置不获取焦点\"><a href=\"#7、设置不获取焦点\" class=\"headerlink\" title=\"7、设置不获取焦点\"></a>7、设置不获取焦点</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setAllowEventFocus(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8、设置节点的更新回调\"><a href=\"#8、设置节点的更新回调\" class=\"headerlink\" title=\"8、设置节点的更新回调\"></a>8、设置节点的更新回调</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void setUpdateCallback(Callback* nc);</span></span><br><span class=\"line\"><span class=\"comment\">// 需要重写一个节点的更新回调 修改节点的视图矩阵 </span></span><br><span class=\"line\"><span class=\"comment\">// 设置相机的三个参数  </span></span><br><span class=\"line\"><span class=\"comment\">// 视点 相机的位置 相机的向上方向</span></span><br><span class=\"line\">hud_camera-&gt;setUpdateCallback();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"挂载节点\"><a href=\"#挂载节点\" class=\"headerlink\" title=\"挂载节点\"></a>挂载节点</h2><h3 id=\"1、将前面创建的几何节点挂载到-相机上\"><a href=\"#1、将前面创建的几何节点挂载到-相机上\" class=\"headerlink\" title=\"1、将前面创建的几何节点挂载到 相机上\"></a>1、将前面创建的几何节点挂载到 相机上</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::ref_ptr&lt;osg::Geode&gt; node = <span class=\"keyword\">new</span> osg::Geode;</span><br><span class=\"line\">node-&gt;addChild(geom.get());</span><br><span class=\"line\">hud_camera-&gt;addChild(node.get());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、设置节点的属性\"><a href=\"#2、设置节点的属性\" class=\"headerlink\" title=\"2、设置节点的属性\"></a>2、设置节点的属性</h3><ul>\n<li>关闭光照 深度测试 &amp; 打开混溶</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> states = node-&gt;getOrCreateStateSet();</span><br><span class=\"line\">states-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON);   <span class=\"comment\">//关闭灯光</span></span><br><span class=\"line\">states-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);<span class=\"comment\">//关闭深度测试</span></span><br><span class=\"line\">states-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);  </span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"OSG-HUD\"><a href=\"#OSG-HUD\" class=\"headerlink\" title=\"OSG-HUD\"></a>OSG-HUD</h1><ul>\n<li><p>\"HUD\"在渲染的场景中算是比较常见的存在: 游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...</p></li>\n</ul>\n<p><b style=\"color:red\">如何创建HUD ？</b> </p>\n<p>本质上说，HUD就是一个相机( 在`OSG`中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行</p>\n\n<p><b style=\"color:red\">实现要点，如下：</b></p>\n<ul>\n<li>关闭节点的光照，保证整个视口显示的场景的亮度是一样的。</li>\n<li>关闭深度测试</li>\n<li>调整渲染的顺序为最后渲染，让<code>HUD</code>显示在整个场景的最前方</li>\n<li>设置参考帧为绝对参考帧</li>\n<li>设置变换矩阵,不受父节点的影响</li>\n<li>设置投影矩阵(平行投影或者透视),设置视口的大小。</li>\n</ul>\n<h2 id=\"Create-HUD\"><a href=\"#Create-HUD\" class=\"headerlink\" title=\"Create HUD\"></a>Create HUD</h2><h3 id=\"1、创建相机节点\"><a href=\"#1、创建相机节点\" class=\"headerlink\" title=\"1、创建相机节点\"></a>1、创建相机节点</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::ref_ptr&lt;osg::Camera&gt; hud_camera = <span class=\"keyword\">new</span> osg::Camera;   <span class=\"comment\">// 创建相机的节点</span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry;      <span class=\"comment\">// 创建绘制的节点(也可以是文字)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、设置投影矩阵\"><a href=\"#2、设置投影矩阵\" class=\"headerlink\" title=\"2、设置投影矩阵\"></a>2、设置投影矩阵</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setProjectionMatrixAsOrtho2D(<span class=\"number\">-3</span>, <span class=\"number\">4</span>, <span class=\"number\">-3</span>, <span class=\"number\">4</span>, <span class=\"number\">-1.0</span>, <span class=\"number\">100</span>);  <span class=\"comment\">// 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、设置视口大小-ViewPort\"><a href=\"#3、设置视口大小-ViewPort\" class=\"headerlink\" title=\"3、设置视口大小(ViewPort)\"></a>3、设置视口大小(ViewPort)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void setViewport(osg::Viewport* viewport);</span></span><br><span class=\"line\"><span class=\"comment\">// void setViewport(int x,int y,int width,int height);</span></span><br><span class=\"line\">hud_camera-&gt;setviewport();  <span class=\"comment\">// 两种方式都是可以的 </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、设置渲染的顺序\"><a href=\"#4、设置渲染的顺序\" class=\"headerlink\" title=\"4、设置渲染的顺序\"></a>4、设置渲染的顺序</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setRenderOrder(osg::Camera::POST_RENDER);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、设置参考帧\"><a href=\"#5、设置参考帧\" class=\"headerlink\" title=\"5、设置参考帧\"></a>5、设置参考帧</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、设置不受父节点的影响\"><a href=\"#6、设置不受父节点的影响\" class=\"headerlink\" title=\"6、设置不受父节点的影响\"></a>6、设置不受父节点的影响</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setViewMatrix(osg::Matrix::identity());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7、设置不获取焦点\"><a href=\"#7、设置不获取焦点\" class=\"headerlink\" title=\"7、设置不获取焦点\"></a>7、设置不获取焦点</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hud_camera-&gt;setAllowEventFocus(<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8、设置节点的更新回调\"><a href=\"#8、设置节点的更新回调\" class=\"headerlink\" title=\"8、设置节点的更新回调\"></a>8、设置节点的更新回调</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// void setUpdateCallback(Callback* nc);</span></span><br><span class=\"line\"><span class=\"comment\">// 需要重写一个节点的更新回调 修改节点的视图矩阵 </span></span><br><span class=\"line\"><span class=\"comment\">// 设置相机的三个参数  </span></span><br><span class=\"line\"><span class=\"comment\">// 视点 相机的位置 相机的向上方向</span></span><br><span class=\"line\">hud_camera-&gt;setUpdateCallback();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"挂载节点\"><a href=\"#挂载节点\" class=\"headerlink\" title=\"挂载节点\"></a>挂载节点</h2><h3 id=\"1、将前面创建的几何节点挂载到-相机上\"><a href=\"#1、将前面创建的几何节点挂载到-相机上\" class=\"headerlink\" title=\"1、将前面创建的几何节点挂载到 相机上\"></a>1、将前面创建的几何节点挂载到 相机上</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::ref_ptr&lt;osg::Geode&gt; node = <span class=\"keyword\">new</span> osg::Geode;</span><br><span class=\"line\">node-&gt;addChild(geom.get());</span><br><span class=\"line\">hud_camera-&gt;addChild(node.get());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、设置节点的属性\"><a href=\"#2、设置节点的属性\" class=\"headerlink\" title=\"2、设置节点的属性\"></a>2、设置节点的属性</h3><ul>\n<li>关闭光照 深度测试 &amp; 打开混溶</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> states = node-&gt;getOrCreateStateSet();</span><br><span class=\"line\">states-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON);   <span class=\"comment\">//关闭灯光</span></span><br><span class=\"line\">states-&gt;setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);<span class=\"comment\">//关闭深度测试</span></span><br><span class=\"line\">states-&gt;setMode(GL_BLEND, osg::StateAttribute::ON);  </span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"OSG踩坑记-模型共享&模型颜色修改","date":"2021-03-20T12:54:22.000Z","_content":"\n###  简单概述\n\n在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。\n\n### 伪代码：\n\n#### 1、读入模型\n\n```c++\n// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。\n// 使用osg自带读取模型的函数读取模型\n// 推荐使用 osg 的智能指针\n// 此处使用一个 内嵌的几何体 代替模型 \n\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry; \n// osg 的智能指针采用引用计数的方式决定当前对象是否释放\n```\n\n#### 2、计算对模型的旋转、缩放、平移的操作矩阵\n\n```C++\n// osg 有专门用户模型操作的类  osg::MatrixTransform \n// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 \nosg::ref_ptr<osg::MatrixTransform> trans = new osg::MatrixTransform;\n// 对于模型的操作，有PVM矩阵的意思 \n\n// 创建旋转矩阵 \nosg::Matrix matrix_rotate;\n// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  \nmatrix_rotate.makeRotate(osg::vec3(0,0,1),osg::vec3(1,0,0));  // 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向\n// 你也可以直接选择使用\nosg::Matrix::rotate(osg::Vec3(),osg::Vec3()); // 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵\n\n// ==============================================================================================\n// 也可以直接 设置最终的变换矩阵 \ntrans->setMatrix(matrix_rotate * osg::Martix::scale(1.0,1.0,1.0) * osg::translate(osg::Vec3()));\n// trans 已经存储了 我们对于模型的操作 \n```\n\n#### 3、对trans节点设置材料等属性 \n\n```C++\n// 创建材质对象\nosg::Material* mat = new osg::Material();\nmat->setColorMode(osg::Material::ColorMode::DIFFUSE);   // 设置绘制颜色的模式 \nmat->setDiffuse(osg::Material::FRONT, osg::Vec4());      // 设置此种模式下的颜色 \n\ntrans->getOrCreateStateSet()->setAttribute(mat);        // 将材质设置给 节点 \n```\n\n#### 4、将对象作为节点添加\n\n```C++\ntrans.addchild(geom.get());\n```\n\n#### 5、将操作节点添加到绘制的根节点或者是其他的叶节点\n\n```C++\n// ......\n```\n\n","source":"_posts/OSG踩坑记-模型共享-模型颜色修改.md","raw":"---\ntitle: OSG踩坑记-模型共享&模型颜色修改\ndate: 2021-03-20 20:54:22\ncategories: \n- works\n- GF\n- OSG\ntags: \n- cpp\n- osg\n---\n\n###  简单概述\n\n在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。\n\n### 伪代码：\n\n#### 1、读入模型\n\n```c++\n// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。\n// 使用osg自带读取模型的函数读取模型\n// 推荐使用 osg 的智能指针\n// 此处使用一个 内嵌的几何体 代替模型 \n\nosg::ref_ptr<osg::Geometry> geom = new osg::Geometry; \n// osg 的智能指针采用引用计数的方式决定当前对象是否释放\n```\n\n#### 2、计算对模型的旋转、缩放、平移的操作矩阵\n\n```C++\n// osg 有专门用户模型操作的类  osg::MatrixTransform \n// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 \nosg::ref_ptr<osg::MatrixTransform> trans = new osg::MatrixTransform;\n// 对于模型的操作，有PVM矩阵的意思 \n\n// 创建旋转矩阵 \nosg::Matrix matrix_rotate;\n// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  \nmatrix_rotate.makeRotate(osg::vec3(0,0,1),osg::vec3(1,0,0));  // 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向\n// 你也可以直接选择使用\nosg::Matrix::rotate(osg::Vec3(),osg::Vec3()); // 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵\n\n// ==============================================================================================\n// 也可以直接 设置最终的变换矩阵 \ntrans->setMatrix(matrix_rotate * osg::Martix::scale(1.0,1.0,1.0) * osg::translate(osg::Vec3()));\n// trans 已经存储了 我们对于模型的操作 \n```\n\n#### 3、对trans节点设置材料等属性 \n\n```C++\n// 创建材质对象\nosg::Material* mat = new osg::Material();\nmat->setColorMode(osg::Material::ColorMode::DIFFUSE);   // 设置绘制颜色的模式 \nmat->setDiffuse(osg::Material::FRONT, osg::Vec4());      // 设置此种模式下的颜色 \n\ntrans->getOrCreateStateSet()->setAttribute(mat);        // 将材质设置给 节点 \n```\n\n#### 4、将对象作为节点添加\n\n```C++\ntrans.addchild(geom.get());\n```\n\n#### 5、将操作节点添加到绘制的根节点或者是其他的叶节点\n\n```C++\n// ......\n```\n\n","slug":"OSG踩坑记-模型共享-模型颜色修改","published":1,"updated":"2022-07-26T00:48:36.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbv000oucuugvmxe6us","content":"<h3 id=\"简单概述\"><a href=\"#简单概述\" class=\"headerlink\" title=\"简单概述\"></a>简单概述</h3><p>在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。</p>\n<h3 id=\"伪代码：\"><a href=\"#伪代码：\" class=\"headerlink\" title=\"伪代码：\"></a>伪代码：</h3><h4 id=\"1、读入模型\"><a href=\"#1、读入模型\" class=\"headerlink\" title=\"1、读入模型\"></a>1、读入模型</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。</span></span><br><span class=\"line\"><span class=\"comment\">// 使用osg自带读取模型的函数读取模型</span></span><br><span class=\"line\"><span class=\"comment\">// 推荐使用 osg 的智能指针</span></span><br><span class=\"line\"><span class=\"comment\">// 此处使用一个 内嵌的几何体 代替模型 </span></span><br><span class=\"line\"></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry; </span><br><span class=\"line\"><span class=\"comment\">// osg 的智能指针采用引用计数的方式决定当前对象是否释放</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、计算对模型的旋转、缩放、平移的操作矩阵\"><a href=\"#2、计算对模型的旋转、缩放、平移的操作矩阵\" class=\"headerlink\" title=\"2、计算对模型的旋转、缩放、平移的操作矩阵\"></a>2、计算对模型的旋转、缩放、平移的操作矩阵</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osg 有专门用户模型操作的类  osg::MatrixTransform </span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 </span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::MatrixTransform&gt; trans = <span class=\"keyword\">new</span> osg::MatrixTransform;</span><br><span class=\"line\"><span class=\"comment\">// 对于模型的操作，有PVM矩阵的意思 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建旋转矩阵 </span></span><br><span class=\"line\">osg::Matrix matrix_rotate;</span><br><span class=\"line\"><span class=\"comment\">// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  </span></span><br><span class=\"line\">matrix_rotate.makeRotate(osg::vec3(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>),osg::vec3(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>));  <span class=\"comment\">// 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向</span></span><br><span class=\"line\"><span class=\"comment\">// 你也可以直接选择使用</span></span><br><span class=\"line\">osg::Matrix::rotate(osg::Vec3(),osg::Vec3()); <span class=\"comment\">// 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ==============================================================================================</span></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接 设置最终的变换矩阵 </span></span><br><span class=\"line\">trans-&gt;setMatrix(matrix_rotate * osg::Martix::scale(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>) * osg::translate(osg::Vec3()));</span><br><span class=\"line\"><span class=\"comment\">// trans 已经存储了 我们对于模型的操作 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、对trans节点设置材料等属性\"><a href=\"#3、对trans节点设置材料等属性\" class=\"headerlink\" title=\"3、对trans节点设置材料等属性\"></a>3、对trans节点设置材料等属性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建材质对象</span></span><br><span class=\"line\">osg::Material* mat = <span class=\"keyword\">new</span> osg::Material();</span><br><span class=\"line\">mat-&gt;setColorMode(osg::Material::ColorMode::DIFFUSE);   <span class=\"comment\">// 设置绘制颜色的模式 </span></span><br><span class=\"line\">mat-&gt;setDiffuse(osg::Material::FRONT, osg::Vec4());      <span class=\"comment\">// 设置此种模式下的颜色 </span></span><br><span class=\"line\"></span><br><span class=\"line\">trans-&gt;getOrCreateStateSet()-&gt;setAttribute(mat);        <span class=\"comment\">// 将材质设置给 节点 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、将对象作为节点添加\"><a href=\"#4、将对象作为节点添加\" class=\"headerlink\" title=\"4、将对象作为节点添加\"></a>4、将对象作为节点添加</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trans.addchild(geom.get());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、将操作节点添加到绘制的根节点或者是其他的叶节点\"><a href=\"#5、将操作节点添加到绘制的根节点或者是其他的叶节点\" class=\"headerlink\" title=\"5、将操作节点添加到绘制的根节点或者是其他的叶节点\"></a>5、将操作节点添加到绘制的根节点或者是其他的叶节点</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单概述\"><a href=\"#简单概述\" class=\"headerlink\" title=\"简单概述\"></a>简单概述</h3><p>在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。</p>\n<h3 id=\"伪代码：\"><a href=\"#伪代码：\" class=\"headerlink\" title=\"伪代码：\"></a>伪代码：</h3><h4 id=\"1、读入模型\"><a href=\"#1、读入模型\" class=\"headerlink\" title=\"1、读入模型\"></a>1、读入模型</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。</span></span><br><span class=\"line\"><span class=\"comment\">// 使用osg自带读取模型的函数读取模型</span></span><br><span class=\"line\"><span class=\"comment\">// 推荐使用 osg 的智能指针</span></span><br><span class=\"line\"><span class=\"comment\">// 此处使用一个 内嵌的几何体 代替模型 </span></span><br><span class=\"line\"></span><br><span class=\"line\">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class=\"keyword\">new</span> osg::Geometry; </span><br><span class=\"line\"><span class=\"comment\">// osg 的智能指针采用引用计数的方式决定当前对象是否释放</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、计算对模型的旋转、缩放、平移的操作矩阵\"><a href=\"#2、计算对模型的旋转、缩放、平移的操作矩阵\" class=\"headerlink\" title=\"2、计算对模型的旋转、缩放、平移的操作矩阵\"></a>2、计算对模型的旋转、缩放、平移的操作矩阵</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// osg 有专门用户模型操作的类  osg::MatrixTransform </span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 </span></span><br><span class=\"line\">osg::ref_ptr&lt;osg::MatrixTransform&gt; trans = <span class=\"keyword\">new</span> osg::MatrixTransform;</span><br><span class=\"line\"><span class=\"comment\">// 对于模型的操作，有PVM矩阵的意思 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建旋转矩阵 </span></span><br><span class=\"line\">osg::Matrix matrix_rotate;</span><br><span class=\"line\"><span class=\"comment\">// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  </span></span><br><span class=\"line\">matrix_rotate.makeRotate(osg::vec3(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>),osg::vec3(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>));  <span class=\"comment\">// 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向</span></span><br><span class=\"line\"><span class=\"comment\">// 你也可以直接选择使用</span></span><br><span class=\"line\">osg::Matrix::rotate(osg::Vec3(),osg::Vec3()); <span class=\"comment\">// 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ==============================================================================================</span></span><br><span class=\"line\"><span class=\"comment\">// 也可以直接 设置最终的变换矩阵 </span></span><br><span class=\"line\">trans-&gt;setMatrix(matrix_rotate * osg::Martix::scale(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>) * osg::translate(osg::Vec3()));</span><br><span class=\"line\"><span class=\"comment\">// trans 已经存储了 我们对于模型的操作 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、对trans节点设置材料等属性\"><a href=\"#3、对trans节点设置材料等属性\" class=\"headerlink\" title=\"3、对trans节点设置材料等属性\"></a>3、对trans节点设置材料等属性</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建材质对象</span></span><br><span class=\"line\">osg::Material* mat = <span class=\"keyword\">new</span> osg::Material();</span><br><span class=\"line\">mat-&gt;setColorMode(osg::Material::ColorMode::DIFFUSE);   <span class=\"comment\">// 设置绘制颜色的模式 </span></span><br><span class=\"line\">mat-&gt;setDiffuse(osg::Material::FRONT, osg::Vec4());      <span class=\"comment\">// 设置此种模式下的颜色 </span></span><br><span class=\"line\"></span><br><span class=\"line\">trans-&gt;getOrCreateStateSet()-&gt;setAttribute(mat);        <span class=\"comment\">// 将材质设置给 节点 </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、将对象作为节点添加\"><a href=\"#4、将对象作为节点添加\" class=\"headerlink\" title=\"4、将对象作为节点添加\"></a>4、将对象作为节点添加</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trans.addchild(geom.get());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、将操作节点添加到绘制的根节点或者是其他的叶节点\"><a href=\"#5、将操作节点添加到绘制的根节点或者是其他的叶节点\" class=\"headerlink\" title=\"5、将操作节点添加到绘制的根节点或者是其他的叶节点\"></a>5、将操作节点添加到绘制的根节点或者是其他的叶节点</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ......</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"OSG踩坑记-默认光源","date":"2021-04-03T16:10:50.000Z","mathjax":true,"_content":"\n### OSG-Viewer默认光源\n\n```C++\nosg::Node->getOrCreateStateSet()->setMode(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    // 法线随着模型大小变化而变化。\nosg::Node->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); // 关闭节点光源 并遵从父节点的光照设置\n```\n\n---\n\n##### `不指定法向` -- <font color=red>仍然可以看到 光照效果 但是无法看到明暗变化 </font> \n\n### Viewer 默认光源的使用\n\n#### 1、设置光照的相关的信息 \n\n- `osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配`\n\n- 你需要设置的信息包括: ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。\n\n> 设置光照  -- <font color=Green>衰减公式</font>\n> $$\n> F = \\frac{1}{(k_c + k_l*d + k_q*d^2)}\n> $$\n>\n\n```C++ \n\t// 1. 获取缺省的光照\n\tosg::Light *light = viewer->getLight(); // 从当前的查看器 获取光照设置 \n\tlight->setAmbient(osg::Vec4(0.4, 0.4, 0.4, 1.0));   // 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);\n\tlight->setDiffuse(osg::Vec4(0.5, 0.5, 0.5, 1.0));   // 漫反射   直接来源于光源\n\tlight->setSpecular(osg::Vec4(0.2, 0.2, 0.2, 1.0));  // specular   高光 此处给的很低  \n\t// 由于此处我们使用的是平行光\n\tosg::Vec4 lightpos(x, y, z, 0.0f);   // 记住: 平行光的位置的最后一个分量必须是 0 \n\tlight->setPosition(lightpos);        // 设置光照位置 \n\t// 光照方向设置\n\t// 需要用到高度角和方位角 -- 计算一个你需要方向 \n\t\n\n\t// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减\n\tlight->setConstantAttenuation(1.0f);\n\tlight->setLinearAttenuation(0.0f);\n\tlight->setQuadraticAttenuation(0.f);\n```\n\n<font color=red> 产生平行光，位置分量的第四分量必须是0 </font>\n\n#### 2、对节点设置好材料属性\n\n- 材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。","source":"_posts/OSG踩坑记-默认光源.md","raw":"---\ntitle: OSG踩坑记-默认光源\ndate: 2021-04-04 00:10:50\ncategories: \n- works\n- GF\n- OSG\ntags:\n- cpp\n- osg\nmathjax: true\n---\n\n### OSG-Viewer默认光源\n\n```C++\nosg::Node->getOrCreateStateSet()->setMode(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    // 法线随着模型大小变化而变化。\nosg::Node->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); // 关闭节点光源 并遵从父节点的光照设置\n```\n\n---\n\n##### `不指定法向` -- <font color=red>仍然可以看到 光照效果 但是无法看到明暗变化 </font> \n\n### Viewer 默认光源的使用\n\n#### 1、设置光照的相关的信息 \n\n- `osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配`\n\n- 你需要设置的信息包括: ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。\n\n> 设置光照  -- <font color=Green>衰减公式</font>\n> $$\n> F = \\frac{1}{(k_c + k_l*d + k_q*d^2)}\n> $$\n>\n\n```C++ \n\t// 1. 获取缺省的光照\n\tosg::Light *light = viewer->getLight(); // 从当前的查看器 获取光照设置 \n\tlight->setAmbient(osg::Vec4(0.4, 0.4, 0.4, 1.0));   // 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);\n\tlight->setDiffuse(osg::Vec4(0.5, 0.5, 0.5, 1.0));   // 漫反射   直接来源于光源\n\tlight->setSpecular(osg::Vec4(0.2, 0.2, 0.2, 1.0));  // specular   高光 此处给的很低  \n\t// 由于此处我们使用的是平行光\n\tosg::Vec4 lightpos(x, y, z, 0.0f);   // 记住: 平行光的位置的最后一个分量必须是 0 \n\tlight->setPosition(lightpos);        // 设置光照位置 \n\t// 光照方向设置\n\t// 需要用到高度角和方位角 -- 计算一个你需要方向 \n\t\n\n\t// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减\n\tlight->setConstantAttenuation(1.0f);\n\tlight->setLinearAttenuation(0.0f);\n\tlight->setQuadraticAttenuation(0.f);\n```\n\n<font color=red> 产生平行光，位置分量的第四分量必须是0 </font>\n\n#### 2、对节点设置好材料属性\n\n- 材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。","slug":"OSG踩坑记-默认光源","published":1,"updated":"2022-07-26T00:48:36.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbx000rucuugt2hgpuc","content":"<h3 id=\"OSG-Viewer默认光源\"><a href=\"#OSG-Viewer默认光源\" class=\"headerlink\" title=\"OSG-Viewer默认光源\"></a>OSG-Viewer默认光源</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    <span class=\"comment\">// 法线随着模型大小变化而变化。</span></span><br><span class=\"line\">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); <span class=\"comment\">// 关闭节点光源 并遵从父节点的光照设置</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化\"><a href=\"#不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化\" class=\"headerlink\" title=\"不指定法向 – 仍然可以看到 光照效果 但是无法看到明暗变化 \"></a><code>不指定法向</code> – <font color=\"red\">仍然可以看到 光照效果 但是无法看到明暗变化 </font></h5><h3 id=\"Viewer-默认光源的使用\"><a href=\"#Viewer-默认光源的使用\" class=\"headerlink\" title=\"Viewer 默认光源的使用\"></a>Viewer 默认光源的使用</h3><h4 id=\"1、设置光照的相关的信息\"><a href=\"#1、设置光照的相关的信息\" class=\"headerlink\" title=\"1、设置光照的相关的信息\"></a>1、设置光照的相关的信息</h4><ul>\n<li><p><code>osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配</code></p>\n</li>\n<li><p>你需要设置的信息包括: ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。</p>\n</li>\n</ul>\n<blockquote>\n<p>设置光照  – <font color=\"Green\">衰减公式</font><br>$$<br>F = \\frac{1}{(k_c + k_l<em>d + k_q</em>d^2)}<br>$$</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 获取缺省的光照</span></span><br><span class=\"line\">osg::Light *light = viewer-&gt;getLight(); <span class=\"comment\">// 从当前的查看器 获取光照设置 </span></span><br><span class=\"line\">light-&gt;setAmbient(osg::Vec4(<span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>));   <span class=\"comment\">// 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);</span></span><br><span class=\"line\">light-&gt;setDiffuse(osg::Vec4(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">1.0</span>));   <span class=\"comment\">// 漫反射   直接来源于光源</span></span><br><span class=\"line\">light-&gt;setSpecular(osg::Vec4(<span class=\"number\">0.2</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.2</span>, <span class=\"number\">1.0</span>));  <span class=\"comment\">// specular   高光 此处给的很低  </span></span><br><span class=\"line\"><span class=\"comment\">// 由于此处我们使用的是平行光</span></span><br><span class=\"line\"><span class=\"function\">osg::Vec4 <span class=\"title\">lightpos</span><span class=\"params\">(x, y, z, <span class=\"number\">0.0f</span>)</span></span>;   <span class=\"comment\">// 记住: 平行光的位置的最后一个分量必须是 0 </span></span><br><span class=\"line\">light-&gt;setPosition(lightpos);        <span class=\"comment\">// 设置光照位置 </span></span><br><span class=\"line\"><span class=\"comment\">// 光照方向设置</span></span><br><span class=\"line\"><span class=\"comment\">// 需要用到高度角和方位角 -- 计算一个你需要方向 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减</span></span><br><span class=\"line\">light-&gt;setConstantAttenuation(<span class=\"number\">1.0f</span>);</span><br><span class=\"line\">light-&gt;setLinearAttenuation(<span class=\"number\">0.0f</span>);</span><br><span class=\"line\">light-&gt;setQuadraticAttenuation(<span class=\"number\">0.f</span>);</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\"> 产生平行光，位置分量的第四分量必须是0 </font></p>\n<h4 id=\"2、对节点设置好材料属性\"><a href=\"#2、对节点设置好材料属性\" class=\"headerlink\" title=\"2、对节点设置好材料属性\"></a>2、对节点设置好材料属性</h4><ul>\n<li>材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"OSG-Viewer默认光源\"><a href=\"#OSG-Viewer默认光源\" class=\"headerlink\" title=\"OSG-Viewer默认光源\"></a>OSG-Viewer默认光源</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    <span class=\"comment\">// 法线随着模型大小变化而变化。</span></span><br><span class=\"line\">osg::Node-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); <span class=\"comment\">// 关闭节点光源 并遵从父节点的光照设置</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化\"><a href=\"#不指定法向-–-仍然可以看到-光照效果-但是无法看到明暗变化\" class=\"headerlink\" title=\"不指定法向 – 仍然可以看到 光照效果 但是无法看到明暗变化 \"></a><code>不指定法向</code> – <font color=\"red\">仍然可以看到 光照效果 但是无法看到明暗变化 </font></h5><h3 id=\"Viewer-默认光源的使用\"><a href=\"#Viewer-默认光源的使用\" class=\"headerlink\" title=\"Viewer 默认光源的使用\"></a>Viewer 默认光源的使用</h3><h4 id=\"1、设置光照的相关的信息\"><a href=\"#1、设置光照的相关的信息\" class=\"headerlink\" title=\"1、设置光照的相关的信息\"></a>1、设置光照的相关的信息</h4><ul>\n<li><p><code>osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配</code></p>\n</li>\n<li><p>你需要设置的信息包括: ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。</p>\n</li>\n</ul>\n<blockquote>\n<p>设置光照  – <font color=\"Green\">衰减公式</font><br>$$<br>F = \\frac{1}{(k_c + k_l<em>d + k_q</em>d^2)}<br>$$</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 获取缺省的光照</span></span><br><span class=\"line\">osg::Light *light = viewer-&gt;getLight(); <span class=\"comment\">// 从当前的查看器 获取光照设置 </span></span><br><span class=\"line\">light-&gt;setAmbient(osg::Vec4(<span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.4</span>, <span class=\"number\">1.0</span>));   <span class=\"comment\">// 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);</span></span><br><span class=\"line\">light-&gt;setDiffuse(osg::Vec4(<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">1.0</span>));   <span class=\"comment\">// 漫反射   直接来源于光源</span></span><br><span class=\"line\">light-&gt;setSpecular(osg::Vec4(<span class=\"number\">0.2</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.2</span>, <span class=\"number\">1.0</span>));  <span class=\"comment\">// specular   高光 此处给的很低  </span></span><br><span class=\"line\"><span class=\"comment\">// 由于此处我们使用的是平行光</span></span><br><span class=\"line\"><span class=\"function\">osg::Vec4 <span class=\"title\">lightpos</span><span class=\"params\">(x, y, z, <span class=\"number\">0.0f</span>)</span></span>;   <span class=\"comment\">// 记住: 平行光的位置的最后一个分量必须是 0 </span></span><br><span class=\"line\">light-&gt;setPosition(lightpos);        <span class=\"comment\">// 设置光照位置 </span></span><br><span class=\"line\"><span class=\"comment\">// 光照方向设置</span></span><br><span class=\"line\"><span class=\"comment\">// 需要用到高度角和方位角 -- 计算一个你需要方向 </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减</span></span><br><span class=\"line\">light-&gt;setConstantAttenuation(<span class=\"number\">1.0f</span>);</span><br><span class=\"line\">light-&gt;setLinearAttenuation(<span class=\"number\">0.0f</span>);</span><br><span class=\"line\">light-&gt;setQuadraticAttenuation(<span class=\"number\">0.f</span>);</span><br></pre></td></tr></table></figure>\n\n<p><font color=\"red\"> 产生平行光，位置分量的第四分量必须是0 </font></p>\n<h4 id=\"2、对节点设置好材料属性\"><a href=\"#2、对节点设置好材料属性\" class=\"headerlink\" title=\"2、对节点设置好材料属性\"></a>2、对节点设置好材料属性</h4><ul>\n<li>材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。</li>\n</ul>\n"},{"title":"Physical Sort","date":"2021-11-07T10:05:13.000Z","_content":"\n### 物理排序\n\n- 我们从上一节的知识开始 {% post_link  Table-Sort 表排序 %}，在某些需求下，我们需要实在的交换表中元素的物理地址，不能通过一张额外的table来达到我们的目的。物理排序可以到达我们的要求\n- 排序完成的结果如下，并且这个排序结果必然有若干个相互独立的环组成\n\n|   A   |           A[0]           |           A[1]           |            A[2]             |           A[3]           |           A[4]            |           A[5]           |           A[6]            |           A[7]            |           A[8]            |              A[9]              |\n| :---: | :----------------------: | :----------------------: | :-------------------------: | :----------------------: | :-----------------------: | :----------------------: | :-----------------------: | :-----------------------: | :-----------------------: | :----------------------------: |\n|  Key  |            f             |            d             |              c              |            a             |             g             |            b             |             h             |             e             |             i             |               u                |\n| table |            0             |            1             |              2              |            3             |             4             |            5             |             6             |             7             |             8             |               9                |\n|  环   | <font color=red>3</font> | <font color=red>5</font> | <font color=yellow>2</font> | <font color=red>1</font> | <font color=blue>7</font> | <font color=red>0</font> | <font color=blue>4</font> | <font color=blue>6</font> | <font color=pink>8</font> | <font color=\"#32FF00\">9</font> |\n\n- 我们从`table[0]= 3` 开始,我们从不同的环的任意一个元素开始切入，遍历元素，最后我们都将回到这个元素，这就是环\n\n  ```C++ \n  // table[0] -> table[3] -> table[1] -> table[0]\n  // 上述序列构成了一个环\n  ```\n\n- 排序，按环处理：\n\n  - 首先，取一个临时变量`temp`随机存储，环中的任意一个元素，以A[0]为例：\n\n    ```C++ \n    temp  = f;  // 此时A[0] 为空 \n    ```\n\n  - 将table中的元素放到`A[0],A[0] = A[table[0]];`\n  \n  - |    A    |           A[0]           |           A[1]           | A[2] |           A[3]           | A[4] |           A[5]           | A[6] | A[7] | A[8] | A[9] |\n    | :-----: | :----------------------: | :----------------------: | :--: | :----------------------: | :--: | :----------------------: | :--: | :--: | :--: | :--: |\n    |   Key   |            f             |            d             |  c   |            a             |  g   |            b             |  h   |  e   |  i   |  u   |\n    |  table  |            0             |            1             |  2   |            3             |  4   |            5             |  6   |  7   |  8   |  9   |\n    |   环    | <font color=red>3</font> | <font color=red>5</font> |      | <font color=red>1</font> |      | <font color=red>0</font> |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |                          |      |           null           |      |                          |      |      |      |      |\n    |  table  |            0             |                          |      |            1             |      |                          |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |           null           |      |            d             |      |                          |      |      |      |      |\n    |  table  |            0             |            5             |      |            3             |      |                          |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |            b             |      |            d             |      |           null           |      |      |      |      |\n    |  table  |            0             |            1             |      |            3             |      |            0             |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |            b             |      |            d             |      |            f             |      |      |      |      |\n    |  table  |            0             |            1             |      |            3             |      |            5             |      |      |      |      |\n    \n  - 判断环结束：\n  \n    - `table[i] == i`，此时环结束\n  \n- 复杂度分析：\n\n  - 最好： 初始的时候都有序\n  - 最坏：两本书(a,b)发生交换，需要三个步骤：\n    - 两本书发生交换：\n      - 取出一本(a)，temp\n      - a = b;\n      - b = temp;\n    - 存在[N/2]个环，每个环两个元素，需要[3N/2]此移动\n  - `T = O(mN)`,m是每个元素A的复制时间\n","source":"_posts/Physical-Sort.md","raw":"---\ntitle: Physical Sort\ndate: 2021-11-07 18:05:13\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n### 物理排序\n\n- 我们从上一节的知识开始 {% post_link  Table-Sort 表排序 %}，在某些需求下，我们需要实在的交换表中元素的物理地址，不能通过一张额外的table来达到我们的目的。物理排序可以到达我们的要求\n- 排序完成的结果如下，并且这个排序结果必然有若干个相互独立的环组成\n\n|   A   |           A[0]           |           A[1]           |            A[2]             |           A[3]           |           A[4]            |           A[5]           |           A[6]            |           A[7]            |           A[8]            |              A[9]              |\n| :---: | :----------------------: | :----------------------: | :-------------------------: | :----------------------: | :-----------------------: | :----------------------: | :-----------------------: | :-----------------------: | :-----------------------: | :----------------------------: |\n|  Key  |            f             |            d             |              c              |            a             |             g             |            b             |             h             |             e             |             i             |               u                |\n| table |            0             |            1             |              2              |            3             |             4             |            5             |             6             |             7             |             8             |               9                |\n|  环   | <font color=red>3</font> | <font color=red>5</font> | <font color=yellow>2</font> | <font color=red>1</font> | <font color=blue>7</font> | <font color=red>0</font> | <font color=blue>4</font> | <font color=blue>6</font> | <font color=pink>8</font> | <font color=\"#32FF00\">9</font> |\n\n- 我们从`table[0]= 3` 开始,我们从不同的环的任意一个元素开始切入，遍历元素，最后我们都将回到这个元素，这就是环\n\n  ```C++ \n  // table[0] -> table[3] -> table[1] -> table[0]\n  // 上述序列构成了一个环\n  ```\n\n- 排序，按环处理：\n\n  - 首先，取一个临时变量`temp`随机存储，环中的任意一个元素，以A[0]为例：\n\n    ```C++ \n    temp  = f;  // 此时A[0] 为空 \n    ```\n\n  - 将table中的元素放到`A[0],A[0] = A[table[0]];`\n  \n  - |    A    |           A[0]           |           A[1]           | A[2] |           A[3]           | A[4] |           A[5]           | A[6] | A[7] | A[8] | A[9] |\n    | :-----: | :----------------------: | :----------------------: | :--: | :----------------------: | :--: | :----------------------: | :--: | :--: | :--: | :--: |\n    |   Key   |            f             |            d             |  c   |            a             |  g   |            b             |  h   |  e   |  i   |  u   |\n    |  table  |            0             |            1             |  2   |            3             |  4   |            5             |  6   |  7   |  8   |  9   |\n    |   环    | <font color=red>3</font> | <font color=red>5</font> |      | <font color=red>1</font> |      | <font color=red>0</font> |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |                          |      |           null           |      |                          |      |      |      |      |\n    |  table  |            0             |                          |      |            1             |      |                          |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |           null           |      |            d             |      |                          |      |      |      |      |\n    |  table  |            0             |            5             |      |            3             |      |                          |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |            b             |      |            d             |      |           null           |      |      |      |      |\n    |  table  |            0             |            1             |      |            3             |      |            0             |      |      |      |      |\n    |         |                          |                          |      |                          |      |                          |      |      |      |      |\n    | new key |            a             |            b             |      |            d             |      |            f             |      |      |      |      |\n    |  table  |            0             |            1             |      |            3             |      |            5             |      |      |      |      |\n    \n  - 判断环结束：\n  \n    - `table[i] == i`，此时环结束\n  \n- 复杂度分析：\n\n  - 最好： 初始的时候都有序\n  - 最坏：两本书(a,b)发生交换，需要三个步骤：\n    - 两本书发生交换：\n      - 取出一本(a)，temp\n      - a = b;\n      - b = temp;\n    - 存在[N/2]个环，每个环两个元素，需要[3N/2]此移动\n  - `T = O(mN)`,m是每个元素A的复制时间\n","slug":"Physical-Sort","published":1,"updated":"2022-07-26T00:48:36.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vbz000wucuu1ask77it","content":"<h3 id=\"物理排序\"><a href=\"#物理排序\" class=\"headerlink\" title=\"物理排序\"></a>物理排序</h3><ul>\n<li>我们从上一节的知识开始 <a href=\"/2021/11/07/Table-Sort/\" title=\"表排序\">表排序</a>，在某些需求下，我们需要实在的交换表中元素的物理地址，不能通过一张额外的table来达到我们的目的。物理排序可以到达我们的要求</li>\n<li>排序完成的结果如下，并且这个排序结果必然有若干个相互独立的环组成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">环</td>\n<td align=\"center\"><font color=\"red\">3</font></td>\n<td align=\"center\"><font color=\"red\">5</font></td>\n<td align=\"center\"><font color=\"yellow\">2</font></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\"><font color=\"blue\">7</font></td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"><font color=\"blue\">4</font></td>\n<td align=\"center\"><font color=\"blue\">6</font></td>\n<td align=\"center\"><font color=\"pink\">8</font></td>\n<td align=\"center\"><font color=\"#32FF00\">9</font></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>我们从<code>table[0]= 3</code> 开始,我们从不同的环的任意一个元素开始切入，遍历元素，最后我们都将回到这个元素，这就是环</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// table[0] -&gt; table[3] -&gt; table[1] -&gt; table[0]</span></span><br><span class=\"line\"><span class=\"comment\">// 上述序列构成了一个环</span></span><br></pre></td></tr></table></figure></li>\n<li><p>排序，按环处理：</p>\n<ul>\n<li><p>首先，取一个临时变量<code>temp</code>随机存储，环中的任意一个元素，以A[0]为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">temp  = f;  <span class=\"comment\">// 此时A[0] 为空 </span></span><br></pre></td></tr></table></figure></li>\n<li><p>将table中的元素放到<code>A[0],A[0] = A[table[0]];</code></p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">环</td>\n<td align=\"center\"><font color=\"red\">3</font></td>\n<td align=\"center\"><font color=\"red\">5</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">5</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\">f</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\">5</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>判断环结束：</p>\n<ul>\n<li><code>table[i] == i</code>，此时环结束</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析：</p>\n<ul>\n<li>最好： 初始的时候都有序</li>\n<li>最坏：两本书(a,b)发生交换，需要三个步骤：<ul>\n<li>两本书发生交换：<ul>\n<li>取出一本(a)，temp</li>\n<li>a = b;</li>\n<li>b = temp;</li>\n</ul>\n</li>\n<li>存在[N/2]个环，每个环两个元素，需要[3N/2]此移动</li>\n</ul>\n</li>\n<li><code>T = O(mN)</code>,m是每个元素A的复制时间</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"物理排序\"><a href=\"#物理排序\" class=\"headerlink\" title=\"物理排序\"></a>物理排序</h3><ul>\n<li>我们从上一节的知识开始 <a href=\"/2021/11/07/Table-Sort/\" title=\"表排序\">表排序</a>，在某些需求下，我们需要实在的交换表中元素的物理地址，不能通过一张额外的table来达到我们的目的。物理排序可以到达我们的要求</li>\n<li>排序完成的结果如下，并且这个排序结果必然有若干个相互独立的环组成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">环</td>\n<td align=\"center\"><font color=\"red\">3</font></td>\n<td align=\"center\"><font color=\"red\">5</font></td>\n<td align=\"center\"><font color=\"yellow\">2</font></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\"><font color=\"blue\">7</font></td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"><font color=\"blue\">4</font></td>\n<td align=\"center\"><font color=\"blue\">6</font></td>\n<td align=\"center\"><font color=\"pink\">8</font></td>\n<td align=\"center\"><font color=\"#32FF00\">9</font></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>我们从<code>table[0]= 3</code> 开始,我们从不同的环的任意一个元素开始切入，遍历元素，最后我们都将回到这个元素，这就是环</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// table[0] -&gt; table[3] -&gt; table[1] -&gt; table[0]</span></span><br><span class=\"line\"><span class=\"comment\">// 上述序列构成了一个环</span></span><br></pre></td></tr></table></figure></li>\n<li><p>排序，按环处理：</p>\n<ul>\n<li><p>首先，取一个临时变量<code>temp</code>随机存储，环中的任意一个元素，以A[0]为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">temp  = f;  <span class=\"comment\">// 此时A[0] 为空 </span></span><br></pre></td></tr></table></figure></li>\n<li><p>将table中的元素放到<code>A[0],A[0] = A[table[0]];</code></p>\n</li>\n<li><table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">环</td>\n<td align=\"center\"><font color=\"red\">3</font></td>\n<td align=\"center\"><font color=\"red\">5</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"><font color=\"red\">1</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"><font color=\"red\">0</font></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">5</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\">null</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">new key</td>\n<td align=\"center\">a</td>\n<td align=\"center\">b</td>\n<td align=\"center\"></td>\n<td align=\"center\">d</td>\n<td align=\"center\"></td>\n<td align=\"center\">f</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n<td align=\"center\">3</td>\n<td align=\"center\"></td>\n<td align=\"center\">5</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>判断环结束：</p>\n<ul>\n<li><code>table[i] == i</code>，此时环结束</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>复杂度分析：</p>\n<ul>\n<li>最好： 初始的时候都有序</li>\n<li>最坏：两本书(a,b)发生交换，需要三个步骤：<ul>\n<li>两本书发生交换：<ul>\n<li>取出一本(a)，temp</li>\n<li>a = b;</li>\n<li>b = temp;</li>\n</ul>\n</li>\n<li>存在[N/2]个环，每个环两个元素，需要[3N/2]此移动</li>\n</ul>\n</li>\n<li><code>T = O(mN)</code>,m是每个元素A的复制时间</li>\n</ul>\n</li>\n</ul>\n"},{"title":"QuickSort","date":"2021-10-28T14:28:59.000Z","_content":"\n## Quick Sort\n\n#### 1、快速排序概述\n\n- 快速排序也是采用分治的思想实现的，首先你有一组无序的数据，然后通过某种方法，取一个这组数据的中间数（M），然后对这组数据进行分组，大于M放到M的右边，小于M放到M的左边。然后通过相同的方法对这两组数分别做相同的处理，直到数据有序。\n\n- 伪码实现\n\n```C++ \nvoid QuickSort(ElementType A[],int N)\n{\n    if(N < 2)\n    {\n        return ; //数据有序 不需要排序\n    }\n    // 计算主元 -- 将数据分组\n    pivot = {A|A中的一个元素}\n    将A（S）分成两个独立的子集{A[] \\ pivot}；\n    A1 = {a∈S|a < pivot};\n    A2 = {a∈S|a > pivot};\n    // 递归调用QuickSort\n}\n```\n\n#### 2、选主元\n\n- 选择一个合适的主元是快速排序算法实现的关键，不能草率的取一个数作为主元。\n\n- 下面介绍一种主元的选取方法：\n\n  - 取头，中，尾的中位数\n\n  - 伪码描述：\n  ```C++\n  ElementType Media3(ElementType A[],int left,int right)\n  {\n      int center = (left + right) / 2;\n      \n      // 如果坐标的比中间的大\n      if(A[left] > A[center])\n      {\n          Swap(&A[left],&A[center]);  // 交换 左中的值 \n          //此后 A[center] > A[left]\n      }\n      // 交换后的左 依旧大于右边\n      if(A[left] > A[right])\n      {\n           Swap(&A[left],&A[right]); \n      }\n      if(A[center] > A[right])\n      {\n           Swap(&A[center],&A[right]); \n      }\n      // A[right] > A[center] 此时我们将center的元素放到此位置，可以只考虑 left+1 -- right-2的元素\n      swap(&A[center],&A[right - 1]);\n      \n      return A[rigjt -1 ];  // 返回我们得到的主元 \n  }\n  ```\n\n#### 3、子集划分\n\n- 每次完成子集划分，主元会放到一个在全局中都正确的位置，将不会在改变。\n\n#### 4、算法实现\n\n```C++ \nvoid QuickSort(ElementType A[], int left,int right)\n{\n    if(Cutoff <= right - left)\n    {\n        // 主元\n        poivt = Media3(A,left,right);\n        int i = left;        // i 当前指向第一个元素的位置 \n        int j = right - 1;   // J 指向主元的位置 \n        for(;;)\n        {\n            while(A[++i] < poivt){}\n            while(A[--j] > poivt){}\n            if(i < j)\n            {\n                swap(&A[i],A[j]);\n            }\n            else\n            {\n                break;\n            }\n        }\n        swap(&A[i],&A[right - 1]);\n        // 递归 \n        QuickSort(A,left,i-1);\n        QuickSort(A,i,right);\n    }\n    else\n    {\n        Insert_selection(A+left,right - left + 1);\n    }\n    \n}\n\n```\n\n","source":"_posts/QuickSort.md","raw":"---\ntitle: QuickSort\ndate: 2021-10-28 22:28:59\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n## Quick Sort\n\n#### 1、快速排序概述\n\n- 快速排序也是采用分治的思想实现的，首先你有一组无序的数据，然后通过某种方法，取一个这组数据的中间数（M），然后对这组数据进行分组，大于M放到M的右边，小于M放到M的左边。然后通过相同的方法对这两组数分别做相同的处理，直到数据有序。\n\n- 伪码实现\n\n```C++ \nvoid QuickSort(ElementType A[],int N)\n{\n    if(N < 2)\n    {\n        return ; //数据有序 不需要排序\n    }\n    // 计算主元 -- 将数据分组\n    pivot = {A|A中的一个元素}\n    将A（S）分成两个独立的子集{A[] \\ pivot}；\n    A1 = {a∈S|a < pivot};\n    A2 = {a∈S|a > pivot};\n    // 递归调用QuickSort\n}\n```\n\n#### 2、选主元\n\n- 选择一个合适的主元是快速排序算法实现的关键，不能草率的取一个数作为主元。\n\n- 下面介绍一种主元的选取方法：\n\n  - 取头，中，尾的中位数\n\n  - 伪码描述：\n  ```C++\n  ElementType Media3(ElementType A[],int left,int right)\n  {\n      int center = (left + right) / 2;\n      \n      // 如果坐标的比中间的大\n      if(A[left] > A[center])\n      {\n          Swap(&A[left],&A[center]);  // 交换 左中的值 \n          //此后 A[center] > A[left]\n      }\n      // 交换后的左 依旧大于右边\n      if(A[left] > A[right])\n      {\n           Swap(&A[left],&A[right]); \n      }\n      if(A[center] > A[right])\n      {\n           Swap(&A[center],&A[right]); \n      }\n      // A[right] > A[center] 此时我们将center的元素放到此位置，可以只考虑 left+1 -- right-2的元素\n      swap(&A[center],&A[right - 1]);\n      \n      return A[rigjt -1 ];  // 返回我们得到的主元 \n  }\n  ```\n\n#### 3、子集划分\n\n- 每次完成子集划分，主元会放到一个在全局中都正确的位置，将不会在改变。\n\n#### 4、算法实现\n\n```C++ \nvoid QuickSort(ElementType A[], int left,int right)\n{\n    if(Cutoff <= right - left)\n    {\n        // 主元\n        poivt = Media3(A,left,right);\n        int i = left;        // i 当前指向第一个元素的位置 \n        int j = right - 1;   // J 指向主元的位置 \n        for(;;)\n        {\n            while(A[++i] < poivt){}\n            while(A[--j] > poivt){}\n            if(i < j)\n            {\n                swap(&A[i],A[j]);\n            }\n            else\n            {\n                break;\n            }\n        }\n        swap(&A[i],&A[right - 1]);\n        // 递归 \n        QuickSort(A,left,i-1);\n        QuickSort(A,i,right);\n    }\n    else\n    {\n        Insert_selection(A+left,right - left + 1);\n    }\n    \n}\n\n```\n\n","slug":"QuickSort","published":1,"updated":"2022-07-26T00:48:36.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vc1000yucuu5boj73aw","content":"<h2 id=\"Quick-Sort\"><a href=\"#Quick-Sort\" class=\"headerlink\" title=\"Quick Sort\"></a>Quick Sort</h2><h4 id=\"1、快速排序概述\"><a href=\"#1、快速排序概述\" class=\"headerlink\" title=\"1、快速排序概述\"></a>1、快速排序概述</h4><ul>\n<li><p>快速排序也是采用分治的思想实现的，首先你有一组无序的数据，然后通过某种方法，取一个这组数据的中间数（M），然后对这组数据进行分组，大于M放到M的右边，小于M放到M的左边。然后通过相同的方法对这两组数分别做相同的处理，直到数据有序。</p>\n</li>\n<li><p>伪码实现</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(N &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ; <span class=\"comment\">//数据有序 不需要排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算主元 -- 将数据分组</span></span><br><span class=\"line\">    pivot = &#123;A|A中的一个元素&#125;</span><br><span class=\"line\">    将A（S）分成两个独立的子集&#123;A[] \\ pivot&#125;；</span><br><span class=\"line\">    A1 = &#123;a∈S|a &lt; pivot&#125;;</span><br><span class=\"line\">    A2 = &#123;a∈S|a &gt; pivot&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 递归调用QuickSort</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、选主元\"><a href=\"#2、选主元\" class=\"headerlink\" title=\"2、选主元\"></a>2、选主元</h4><ul>\n<li><p>选择一个合适的主元是快速排序算法实现的关键，不能草率的取一个数作为主元。</p>\n</li>\n<li><p>下面介绍一种主元的选取方法：</p>\n<ul>\n<li><p>取头，中，尾的中位数</p>\n</li>\n<li><p>伪码描述：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Media3</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果坐标的比中间的大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[left] &gt; A[center])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Swap(&amp;A[left],&amp;A[center]);  <span class=\"comment\">// 交换 左中的值 </span></span><br><span class=\"line\">        <span class=\"comment\">//此后 A[center] &gt; A[left]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交换后的左 依旧大于右边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[left] &gt; A[right])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         Swap(&amp;A[left],&amp;A[right]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[center] &gt; A[right])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         Swap(&amp;A[center],&amp;A[right]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// A[right] &gt; A[center] 此时我们将center的元素放到此位置，可以只考虑 left+1 -- right-2的元素</span></span><br><span class=\"line\">    swap(&amp;A[center],&amp;A[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[rigjt <span class=\"number\">-1</span> ];  <span class=\"comment\">// 返回我们得到的主元 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3、子集划分\"><a href=\"#3、子集划分\" class=\"headerlink\" title=\"3、子集划分\"></a>3、子集划分</h4><ul>\n<li>每次完成子集划分，主元会放到一个在全局中都正确的位置，将不会在改变。</li>\n</ul>\n<h4 id=\"4、算法实现\"><a href=\"#4、算法实现\" class=\"headerlink\" title=\"4、算法实现\"></a>4、算法实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(ElementType A[], <span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Cutoff &lt;= right - left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主元</span></span><br><span class=\"line\">        poivt = Media3(A,left,right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = left;        <span class=\"comment\">// i 当前指向第一个元素的位置 </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = right - <span class=\"number\">1</span>;   <span class=\"comment\">// J 指向主元的位置 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(A[++i] &lt; poivt)&#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(A[--j] &gt; poivt)&#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;A[i],A[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(&amp;A[i],&amp;A[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 递归 </span></span><br><span class=\"line\">        QuickSort(A,left,i<span class=\"number\">-1</span>);</span><br><span class=\"line\">        QuickSort(A,i,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Insert_selection(A+left,right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Quick-Sort\"><a href=\"#Quick-Sort\" class=\"headerlink\" title=\"Quick Sort\"></a>Quick Sort</h2><h4 id=\"1、快速排序概述\"><a href=\"#1、快速排序概述\" class=\"headerlink\" title=\"1、快速排序概述\"></a>1、快速排序概述</h4><ul>\n<li><p>快速排序也是采用分治的思想实现的，首先你有一组无序的数据，然后通过某种方法，取一个这组数据的中间数（M），然后对这组数据进行分组，大于M放到M的右边，小于M放到M的左边。然后通过相同的方法对这两组数分别做相同的处理，直到数据有序。</p>\n</li>\n<li><p>伪码实现</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(N &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ; <span class=\"comment\">//数据有序 不需要排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算主元 -- 将数据分组</span></span><br><span class=\"line\">    pivot = &#123;A|A中的一个元素&#125;</span><br><span class=\"line\">    将A（S）分成两个独立的子集&#123;A[] \\ pivot&#125;；</span><br><span class=\"line\">    A1 = &#123;a∈S|a &lt; pivot&#125;;</span><br><span class=\"line\">    A2 = &#123;a∈S|a &gt; pivot&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 递归调用QuickSort</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、选主元\"><a href=\"#2、选主元\" class=\"headerlink\" title=\"2、选主元\"></a>2、选主元</h4><ul>\n<li><p>选择一个合适的主元是快速排序算法实现的关键，不能草率的取一个数作为主元。</p>\n</li>\n<li><p>下面介绍一种主元的选取方法：</p>\n<ul>\n<li><p>取头，中，尾的中位数</p>\n</li>\n<li><p>伪码描述：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ElementType <span class=\"title\">Media3</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果坐标的比中间的大</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[left] &gt; A[center])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Swap(&amp;A[left],&amp;A[center]);  <span class=\"comment\">// 交换 左中的值 </span></span><br><span class=\"line\">        <span class=\"comment\">//此后 A[center] &gt; A[left]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交换后的左 依旧大于右边</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[left] &gt; A[right])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         Swap(&amp;A[left],&amp;A[right]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(A[center] &gt; A[right])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">         Swap(&amp;A[center],&amp;A[right]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// A[right] &gt; A[center] 此时我们将center的元素放到此位置，可以只考虑 left+1 -- right-2的元素</span></span><br><span class=\"line\">    swap(&amp;A[center],&amp;A[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[rigjt <span class=\"number\">-1</span> ];  <span class=\"comment\">// 返回我们得到的主元 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3、子集划分\"><a href=\"#3、子集划分\" class=\"headerlink\" title=\"3、子集划分\"></a>3、子集划分</h4><ul>\n<li>每次完成子集划分，主元会放到一个在全局中都正确的位置，将不会在改变。</li>\n</ul>\n<h4 id=\"4、算法实现\"><a href=\"#4、算法实现\" class=\"headerlink\" title=\"4、算法实现\"></a>4、算法实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(ElementType A[], <span class=\"keyword\">int</span> left,<span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Cutoff &lt;= right - left)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 主元</span></span><br><span class=\"line\">        poivt = Media3(A,left,right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = left;        <span class=\"comment\">// i 当前指向第一个元素的位置 </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = right - <span class=\"number\">1</span>;   <span class=\"comment\">// J 指向主元的位置 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;;)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(A[++i] &lt; poivt)&#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(A[--j] &gt; poivt)&#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; j)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(&amp;A[i],A[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(&amp;A[i],&amp;A[right - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">// 递归 </span></span><br><span class=\"line\">        QuickSort(A,left,i<span class=\"number\">-1</span>);</span><br><span class=\"line\">        QuickSort(A,i,right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Insert_selection(A+left,right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Selection_sort","date":"2021-10-25T14:25:09.000Z","_content":"\n## 选择排序  \n\n- 选择排序，每次从无序的数据中选择一个`最大的`或者是`最小的`,放到合适的位置。\n\n- 代码实现：\n\n    ```C++ \n    // 这里为了使用最大堆-我们倒着排序 \n    void Selection_Sort(ElementType A[], int N)\n    {  \n        for(auto i = N-1;i >= 0；i--)\n        {\n        \t  max_postion = scanForMax(A,0,i); //获取最大元素的下标 \n              swap(&A[i],&A[max_position]);    // 交换元素    \n        }\n    }\n    ```\n\n- `scanForMax`\n  - 查找当前无序元素中最大的元素，并返回元素的下标\n    - 常规下，直接对数组元素进行扫描，时间复杂度`O(N)`,整个算法的时间复杂度`T=O(N^2)`\n    - 优化方案：如何快速找到最大值 -- 最大堆or最小堆。\n\n","source":"_posts/Selection-sort.md","raw":"---\ntitle: Selection_sort\ndate: 2021-10-25 22:25:09\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n## 选择排序  \n\n- 选择排序，每次从无序的数据中选择一个`最大的`或者是`最小的`,放到合适的位置。\n\n- 代码实现：\n\n    ```C++ \n    // 这里为了使用最大堆-我们倒着排序 \n    void Selection_Sort(ElementType A[], int N)\n    {  \n        for(auto i = N-1;i >= 0；i--)\n        {\n        \t  max_postion = scanForMax(A,0,i); //获取最大元素的下标 \n              swap(&A[i],&A[max_position]);    // 交换元素    \n        }\n    }\n    ```\n\n- `scanForMax`\n  - 查找当前无序元素中最大的元素，并返回元素的下标\n    - 常规下，直接对数组元素进行扫描，时间复杂度`O(N)`,整个算法的时间复杂度`T=O(N^2)`\n    - 优化方案：如何快速找到最大值 -- 最大堆or最小堆。\n\n","slug":"Selection-sort","published":1,"updated":"2022-07-26T00:48:36.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vc20012ucuudle1c4mt","content":"<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><ul>\n<li><p>选择排序，每次从无序的数据中选择一个<code>最大的</code>或者是<code>最小的</code>,放到合适的位置。</p>\n</li>\n<li><p>代码实现：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里为了使用最大堆-我们倒着排序 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Selection_Sort</span><span class=\"params\">(ElementType A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i = N<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>；i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t  max_postion = scanForMax(A,<span class=\"number\">0</span>,i); <span class=\"comment\">//获取最大元素的下标 </span></span><br><span class=\"line\">          swap(&amp;A[i],&amp;A[max_position]);    <span class=\"comment\">// 交换元素    </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>scanForMax</code></p>\n<ul>\n<li>查找当前无序元素中最大的元素，并返回元素的下标<ul>\n<li>常规下，直接对数组元素进行扫描，时间复杂度<code>O(N)</code>,整个算法的时间复杂度<code>T=O(N^2)</code></li>\n<li>优化方案：如何快速找到最大值 – 最大堆or最小堆。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><ul>\n<li><p>选择排序，每次从无序的数据中选择一个<code>最大的</code>或者是<code>最小的</code>,放到合适的位置。</p>\n</li>\n<li><p>代码实现：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里为了使用最大堆-我们倒着排序 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Selection_Sort</span><span class=\"params\">(ElementType A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i = N<span class=\"number\">-1</span>;i &gt;= <span class=\"number\">0</span>；i--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \t  max_postion = scanForMax(A,<span class=\"number\">0</span>,i); <span class=\"comment\">//获取最大元素的下标 </span></span><br><span class=\"line\">          swap(&amp;A[i],&amp;A[max_position]);    <span class=\"comment\">// 交换元素    </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>scanForMax</code></p>\n<ul>\n<li>查找当前无序元素中最大的元素，并返回元素的下标<ul>\n<li>常规下，直接对数组元素进行扫描，时间复杂度<code>O(N)</code>,整个算法的时间复杂度<code>T=O(N^2)</code></li>\n<li>优化方案：如何快速找到最大值 – 最大堆or最小堆。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Shell-Sort","date":"2021-10-26T12:25:46.000Z","_content":"\n###  希尔排序\n\n- 希尔排序：预先定义一系列间隔(增量序列)DK，按照间隔，进行间隔排序\n  - `DK[i-1]`有序后，执行`DK[i]`的排序后，`DK[i-1]`依旧是有序的\n\n#### 1、原始的希尔排序\n\n- `DK[i-1] = 取整(N/2),DK[i] = 取整(DK[i-1]/2)`\n\n```C++\nvoid Shell_sort(ElementTypes A[], int N)\n{\n    int D;  // 当前次序的间隔\n    int P,i;\n    ElementType temp;\n    for(P=N/2;D>0;D/=2) // 间隔的变换\n    {\n        // 插入排序 \n        for(P = D; P<N; P++)\n        {\n        \ttemp = A[P];  // 当前要插入的元素 \n            for(i = P; i >= D && A[i-D] > temp;i -= D)  // 和已经有序的元素进行比较\n            // 前一个元素A[i-D]如果大于temp，temp放置的位置在i-D之前，i-D位置的元素向后移动\n            {\n                A[i] = A[i-D];\n            }\n            A[i] = temp;  // temp 放到正确位置\n        }\n    }\n}\n\n```\n\n- 复杂度分析： 当所有大于的增量的序列的数据都是有序的时候，所有的交换操作都会在增量为1的时候执行，这回导致一个不怎么好的结果，时间复杂度会达到`O(N^2)`。\n\n","source":"_posts/Shell-Sort.md","raw":"---\ntitle: Shell-Sort\ndate: 2021-10-26 20:25:46\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n###  希尔排序\n\n- 希尔排序：预先定义一系列间隔(增量序列)DK，按照间隔，进行间隔排序\n  - `DK[i-1]`有序后，执行`DK[i]`的排序后，`DK[i-1]`依旧是有序的\n\n#### 1、原始的希尔排序\n\n- `DK[i-1] = 取整(N/2),DK[i] = 取整(DK[i-1]/2)`\n\n```C++\nvoid Shell_sort(ElementTypes A[], int N)\n{\n    int D;  // 当前次序的间隔\n    int P,i;\n    ElementType temp;\n    for(P=N/2;D>0;D/=2) // 间隔的变换\n    {\n        // 插入排序 \n        for(P = D; P<N; P++)\n        {\n        \ttemp = A[P];  // 当前要插入的元素 \n            for(i = P; i >= D && A[i-D] > temp;i -= D)  // 和已经有序的元素进行比较\n            // 前一个元素A[i-D]如果大于temp，temp放置的位置在i-D之前，i-D位置的元素向后移动\n            {\n                A[i] = A[i-D];\n            }\n            A[i] = temp;  // temp 放到正确位置\n        }\n    }\n}\n\n```\n\n- 复杂度分析： 当所有大于的增量的序列的数据都是有序的时候，所有的交换操作都会在增量为1的时候执行，这回导致一个不怎么好的结果，时间复杂度会达到`O(N^2)`。\n\n","slug":"Shell-Sort","published":1,"updated":"2022-07-26T00:48:36.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vc50014ucuu322tb77u","content":"<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>希尔排序：预先定义一系列间隔(增量序列)DK，按照间隔，进行间隔排序<ul>\n<li><code>DK[i-1]</code>有序后，执行<code>DK[i]</code>的排序后，<code>DK[i-1]</code>依旧是有序的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1、原始的希尔排序\"><a href=\"#1、原始的希尔排序\" class=\"headerlink\" title=\"1、原始的希尔排序\"></a>1、原始的希尔排序</h4><ul>\n<li><code>DK[i-1] = 取整(N/2),DK[i] = 取整(DK[i-1]/2)</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Shell_sort</span><span class=\"params\">(ElementTypes A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> D;  <span class=\"comment\">// 当前次序的间隔</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> P,i;</span><br><span class=\"line\">    ElementType temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(P=N/<span class=\"number\">2</span>;D&gt;<span class=\"number\">0</span>;D/=<span class=\"number\">2</span>) <span class=\"comment\">// 间隔的变换</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 插入排序 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(P = D; P&lt;N; P++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \ttemp = A[P];  <span class=\"comment\">// 当前要插入的元素 </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i = P; i &gt;= D &amp;&amp; A[i-D] &gt; temp;i -= D)  <span class=\"comment\">// 和已经有序的元素进行比较</span></span><br><span class=\"line\">            <span class=\"comment\">// 前一个元素A[i-D]如果大于temp，temp放置的位置在i-D之前，i-D位置的元素向后移动</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                A[i] = A[i-D];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            A[i] = temp;  <span class=\"comment\">// temp 放到正确位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>复杂度分析： 当所有大于的增量的序列的数据都是有序的时候，所有的交换操作都会在增量为1的时候执行，这回导致一个不怎么好的结果，时间复杂度会达到<code>O(N^2)</code>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>希尔排序：预先定义一系列间隔(增量序列)DK，按照间隔，进行间隔排序<ul>\n<li><code>DK[i-1]</code>有序后，执行<code>DK[i]</code>的排序后，<code>DK[i-1]</code>依旧是有序的</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1、原始的希尔排序\"><a href=\"#1、原始的希尔排序\" class=\"headerlink\" title=\"1、原始的希尔排序\"></a>1、原始的希尔排序</h4><ul>\n<li><code>DK[i-1] = 取整(N/2),DK[i] = 取整(DK[i-1]/2)</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Shell_sort</span><span class=\"params\">(ElementTypes A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> D;  <span class=\"comment\">// 当前次序的间隔</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> P,i;</span><br><span class=\"line\">    ElementType temp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(P=N/<span class=\"number\">2</span>;D&gt;<span class=\"number\">0</span>;D/=<span class=\"number\">2</span>) <span class=\"comment\">// 间隔的变换</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 插入排序 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(P = D; P&lt;N; P++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        \ttemp = A[P];  <span class=\"comment\">// 当前要插入的元素 </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(i = P; i &gt;= D &amp;&amp; A[i-D] &gt; temp;i -= D)  <span class=\"comment\">// 和已经有序的元素进行比较</span></span><br><span class=\"line\">            <span class=\"comment\">// 前一个元素A[i-D]如果大于temp，temp放置的位置在i-D之前，i-D位置的元素向后移动</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                A[i] = A[i-D];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            A[i] = temp;  <span class=\"comment\">// temp 放到正确位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>复杂度分析： 当所有大于的增量的序列的数据都是有序的时候，所有的交换操作都会在增量为1的时候执行，这回导致一个不怎么好的结果，时间复杂度会达到<code>O(N^2)</code>。</li>\n</ul>\n"},{"title":"Table-Sort","date":"2021-11-06T16:30:03.000Z","_content":"\n### 表排序\n\n- 某些场景，移动元素的成本比较大，元素移动的时间是不可以俘忽略的，为了节省时间，我们不得不寻求其他的办法。\n  - 定义一个指针数组作为\"表\"（table）\n- 概述，存在表A，存储的是对应的关键字，每个关键字代表具体的实体，我们根据关键字进行排序，这样省去额外的数据交换的时间。\n  - 我们定义一个新的部分`table`记录数组中每个元素的下标\n\n| A | A[0] | A[1] | A[2] | A[3] | A[4] | A[5] | A[6] | A[7]  | A[8] | A[9] |\n|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|\n|  Key  | f | d | c | a | g | b | h | e | i | u |\n| table | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n\n  - - 初始状态下，`table[index]` 等于A 的`index`\n    - 然后我们同通过任意一种排序比较`A[table]`对应的关键字的大小，从而交换`table`中的值——排序\n\n- 排序结果 -- 使用插入排序\n\n  |     A      | A[0] | A[1] | A[2] | A[3] | A[4] | A[5] | A[6] | A[7] | A[8] | A[9] |\n  | :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n  |    Key     |  f   |  d   |  c   |  a   |  g   |  b   |  h   |  e   |  i   |  u   |\n  |   table    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n  | 第零次插入 |  0   |      |      |      |      |      |      |      |      |      |\n  | 第一次插入 |  1   |  0   |      |      |      |      |      |      |      |      |\n  | 第二次插入 |  2   |  1   |  0   |      |      |      |      |      |      |      |\n  | 第三次插入 |  3   |  2   |  1   |  0   |      |      |      |      |      |      |\n  | 第四次插入 |  3   |  2   |  1   |  0   |  4   |      |      |      |      |      |\n  | 第五次插入 |  3   |  5   |  2   |  1   |  0   |  4   |      |      |      |      |\n  | 第六次插入 |  3   |  5   |  2   |  1   |  0   |  4   |  6   |      |      |      |\n  | 第七次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |      |      |\n  | 第八次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |      |\n  | 第九次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |  9   |\n  |   table    |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |  9   |\n\n- 到此，上述表变得有序：\n- 正确的输出结果是:\n  - `A[table[0]],A[table[0]]........`\n\n","source":"_posts/Table-Sort.md","raw":"---\ntitle: Table-Sort\ndate: 2021-11-07 00:30:03\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n### 表排序\n\n- 某些场景，移动元素的成本比较大，元素移动的时间是不可以俘忽略的，为了节省时间，我们不得不寻求其他的办法。\n  - 定义一个指针数组作为\"表\"（table）\n- 概述，存在表A，存储的是对应的关键字，每个关键字代表具体的实体，我们根据关键字进行排序，这样省去额外的数据交换的时间。\n  - 我们定义一个新的部分`table`记录数组中每个元素的下标\n\n| A | A[0] | A[1] | A[2] | A[3] | A[4] | A[5] | A[6] | A[7]  | A[8] | A[9] |\n|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|\n|  Key  | f | d | c | a | g | b | h | e | i | u |\n| table | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |\n\n  - - 初始状态下，`table[index]` 等于A 的`index`\n    - 然后我们同通过任意一种排序比较`A[table]`对应的关键字的大小，从而交换`table`中的值——排序\n\n- 排序结果 -- 使用插入排序\n\n  |     A      | A[0] | A[1] | A[2] | A[3] | A[4] | A[5] | A[6] | A[7] | A[8] | A[9] |\n  | :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n  |    Key     |  f   |  d   |  c   |  a   |  g   |  b   |  h   |  e   |  i   |  u   |\n  |   table    |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |\n  | 第零次插入 |  0   |      |      |      |      |      |      |      |      |      |\n  | 第一次插入 |  1   |  0   |      |      |      |      |      |      |      |      |\n  | 第二次插入 |  2   |  1   |  0   |      |      |      |      |      |      |      |\n  | 第三次插入 |  3   |  2   |  1   |  0   |      |      |      |      |      |      |\n  | 第四次插入 |  3   |  2   |  1   |  0   |  4   |      |      |      |      |      |\n  | 第五次插入 |  3   |  5   |  2   |  1   |  0   |  4   |      |      |      |      |\n  | 第六次插入 |  3   |  5   |  2   |  1   |  0   |  4   |  6   |      |      |      |\n  | 第七次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |      |      |\n  | 第八次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |      |\n  | 第九次插入 |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |  9   |\n  |   table    |  3   |  5   |  2   |  1   |  7   |  0   |  4   |  6   |  8   |  9   |\n\n- 到此，上述表变得有序：\n- 正确的输出结果是:\n  - `A[table[0]],A[table[0]]........`\n\n","slug":"Table-Sort","published":1,"updated":"2022-07-26T00:48:36.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vc70018ucuu8lyz8nqg","content":"<h3 id=\"表排序\"><a href=\"#表排序\" class=\"headerlink\" title=\"表排序\"></a>表排序</h3><ul>\n<li>某些场景，移动元素的成本比较大，元素移动的时间是不可以俘忽略的，为了节省时间，我们不得不寻求其他的办法。<ul>\n<li>定义一个指针数组作为”表”（table）</li>\n</ul>\n</li>\n<li>概述，存在表A，存储的是对应的关键字，每个关键字代表具体的实体，我们根据关键字进行排序，这样省去额外的数据交换的时间。<ul>\n<li>我们定义一个新的部分<code>table</code>记录数组中每个元素的下标</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n<ul>\n<li><ul>\n<li>初始状态下，<code>table[index]</code> 等于A 的<code>index</code></li>\n<li>然后我们同通过任意一种排序比较<code>A[table]</code>对应的关键字的大小，从而交换<code>table</code>中的值——排序</li>\n</ul>\n</li>\n<li><p>排序结果 – 使用插入排序</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">第零次插入</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第一次插入</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第二次插入</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第三次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第四次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第五次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第六次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第七次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第八次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第九次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>到此，上述表变得有序：</p>\n</li>\n<li><p>正确的输出结果是:</p>\n<ul>\n<li><code>A[table[0]],A[table[0]]........</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"表排序\"><a href=\"#表排序\" class=\"headerlink\" title=\"表排序\"></a>表排序</h3><ul>\n<li>某些场景，移动元素的成本比较大，元素移动的时间是不可以俘忽略的，为了节省时间，我们不得不寻求其他的办法。<ul>\n<li>定义一个指针数组作为”表”（table）</li>\n</ul>\n</li>\n<li>概述，存在表A，存储的是对应的关键字，每个关键字代表具体的实体，我们根据关键字进行排序，这样省去额外的数据交换的时间。<ul>\n<li>我们定义一个新的部分<code>table</code>记录数组中每个元素的下标</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n<ul>\n<li><ul>\n<li>初始状态下，<code>table[index]</code> 等于A 的<code>index</code></li>\n<li>然后我们同通过任意一种排序比较<code>A[table]</code>对应的关键字的大小，从而交换<code>table</code>中的值——排序</li>\n</ul>\n</li>\n<li><p>排序结果 – 使用插入排序</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">A</th>\n<th align=\"center\">A[0]</th>\n<th align=\"center\">A[1]</th>\n<th align=\"center\">A[2]</th>\n<th align=\"center\">A[3]</th>\n<th align=\"center\">A[4]</th>\n<th align=\"center\">A[5]</th>\n<th align=\"center\">A[6]</th>\n<th align=\"center\">A[7]</th>\n<th align=\"center\">A[8]</th>\n<th align=\"center\">A[9]</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Key</td>\n<td align=\"center\">f</td>\n<td align=\"center\">d</td>\n<td align=\"center\">c</td>\n<td align=\"center\">a</td>\n<td align=\"center\">g</td>\n<td align=\"center\">b</td>\n<td align=\"center\">h</td>\n<td align=\"center\">e</td>\n<td align=\"center\">i</td>\n<td align=\"center\">u</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">第零次插入</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第一次插入</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第二次插入</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第三次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第四次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第五次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第六次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第七次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第八次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">第九次插入</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>到此，上述表变得有序：</p>\n</li>\n<li><p>正确的输出结果是:</p>\n<ul>\n<li><code>A[table[0]],A[table[0]]........</code></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Boy","date":"2021-03-16T13:53:58.000Z","_content":"\n####  About this Blog\n\n- 个人博客，分享我的日常与一些工作内容\n\n","source":"_posts/baozi.md","raw":"---\ntitle: \"Boy\"\ndate: 2021-03-16 21:53:58\ncategories:\n- bun\n- life\ntags:\n - intraduce\n---\n\n####  About this Blog\n\n- 个人博客，分享我的日常与一些工作内容\n\n","slug":"baozi","published":1,"updated":"2022-07-26T00:48:36.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vc9001cucuug8313eri","content":"<h4 id=\"About-this-Blog\"><a href=\"#About-this-Blog\" class=\"headerlink\" title=\"About this Blog\"></a>About this Blog</h4><ul>\n<li>个人博客，分享我的日常与一些工作内容</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"About-this-Blog\"><a href=\"#About-this-Blog\" class=\"headerlink\" title=\"About this Blog\"></a>About this Blog</h4><ul>\n<li>个人博客，分享我的日常与一些工作内容</li>\n</ul>\n"},{"title":"简单排序-冒泡&插入","date":"2021-10-19T15:41:14.000Z","_content":"\n## 简单排序:\n\n- 冒泡排序\n- 插入排序\n\n上述两种排序是相对基础的简单排序,通过交换逆序对逐渐使序列有序。\n\n在常规的排序算法中：我们默认的顺序是从小到大\n\n#### 1、冒泡排序\n\n&ensp;&ensp;原理： 冒泡排序是一个两重的`for`循环，外面一层每循环一次就代表有一个元素被放好，第二重循环做的事情是从没有排好序的元素中取出一个，然后依次和后面的元素作比较，将这些元素中最大的一个放到这些无序元素的最后一个元素的位置，标志着这个元素完成排序——变得有序。\n\n- C++实现 -- 初始版本\n\n```c++\nvoid swap(int * a,int * b)；\nvoid bubble_Sort(ElementTYpe A[],int N)  // A是待排序的数据 N代表的是数据的个数\n{\n    int p = 0,i = 0;\n  \tfor(p = N - 1;p>=0;p--)\n    {\n        for(i = 0;i < p;i++) // 从无序的数据中抛出最大的\n        {\n            if(A[i] > A[i+1])  // 比较元素\n            {\n                swap(A+i,(A+(i+1))); // 交换元素 \n            }\n        }\n    }\n}\n\nvoid swap(int * a,int * b)\n{\n    *a ^= *b;\n    *b ^= *a;\n    *a ^= *b;\n}\n```\n\n- 优化版本\n\n如是在某一次循环中，提前让数组有序，但是在上述的代码中，即使数据有序了，循环依旧会继续执行，我们需要一个标志，来知道数据已经有序：\n\n```C++\nvoid bubble_Sort(ElementTYpe A[],int N)  // A是待排序的数据 N代表的是数据的个数\n{\n    int p = 0,i = 0;\n    bool flag = false;       // 标识数组是否有序\n  \tfor(p = N - 1;p>=0;p--)\n    {\n        for(i = 0;i < p;i++) // 从无序的数据中抛出最大的\n        {\n            if(A[i] > A[i+1])  // 比较元素\n            {\n                swap(A+i,(A+(i+1))); // 交换元素\n                flag = true;\n            }\n        }\n        if(!flag)  // 满足退出条件 结束循环\n        {\n            break; \n        }\n    }\n}\n```\n- 结果展示\n  - 输入与数据：`int a[7] = {3,1,2,98,30,8,90};`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/bubble_sort.png)\n\n- 复杂度分析 - 优化版本\n\n最好的情况：默认传输进来的元素是有序的，我们只需要，经历一次数据的遍历`flag`变量会触发循环结束，复杂度：\n\n<center>T = O(N)</center>\n\n最坏情况：元素逆序，需要遍历比较所有的元素\n\n<center>T = O(N^2)</center>\n\n#### 2、插入排序\n\n插入排序：不发生元素的交换，但是会发生元素的移动，每次获取一个元素(P)，将这个P插入到一个有序的序列中，插入的过程是一个比较+覆盖的过程。\n\n- C++实现 \n\n  ```C++\n  void Insertion_Sort(ElementType A[],int N)\n  {\n      int p,i，tmp;\n      for(p = 1;p < N;p++)\n      {\n          tmp = A[p];  // 获取插入的元素 \n          for(i = p;i > 0 && A[i - 1] > tmp;i--) // A[i-1]表示的是有序序列中的最大元素\n          {\n              A[i] = A[i-1];\n          }\n          // 比较结束后，当前 i - 1指向位置的元素是小于 tmp的，所以：\n          A[i] = tmp;\n      }\n  }\n  ```\n\n- 结果展示\n\n  - 输入与数据：`int a[7] = {3,1,1,98,30,8,90};`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/insertion_sort.png)\n\n- 复杂度分析：\n\n  最好情况，每次进来的元素不需要，比较。直接插入到相应的位置，此时时间复杂度：\n\n  <center>T = O(N)</center>\n\n  最坏情况，数据逆序，每一次的元素都需要遍历所有的有序元素，此时时间复杂度：\n\n  <center>T = O(N^2)</center>\n\n#### 补充说明：\n\n- 时间复杂度下界\n\n&ensp;&ensp;&ensp;&ensp;概念：对于下边`i<j`如果A[i] > A[j]，则称`(i,j)`是一对逆序对<font color=red>逆序对(inversion)</font>\n\n- 在上述的排序中，相邻元素的交换其实是消掉逆序对的操作！<font color=red>如果序列基本有序，那么插入排序简单且高效</font>\n\n<center>插入排序：T(N,I) = O(N+I)</center>\n\n- 对于N个不同元素组成的序列，平均具有`N(N-1)/4`个逆序对。\n\n- 对于仅以交换相邻元素来排序的算法，其平均时间复杂度为婐`Ω(N^2)`\n\n基于上面的描述，我们要提高此类算法的效率，必须每次消去的逆序对数大于1。\n\n### 下面将会介绍，希尔排序！\n\n","source":"_posts/sort-bubble-insertion.md","raw":"---\ntitle: 简单排序-冒泡&插入\ndate: 2021-10-19 23:41:14\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n## 简单排序:\n\n- 冒泡排序\n- 插入排序\n\n上述两种排序是相对基础的简单排序,通过交换逆序对逐渐使序列有序。\n\n在常规的排序算法中：我们默认的顺序是从小到大\n\n#### 1、冒泡排序\n\n&ensp;&ensp;原理： 冒泡排序是一个两重的`for`循环，外面一层每循环一次就代表有一个元素被放好，第二重循环做的事情是从没有排好序的元素中取出一个，然后依次和后面的元素作比较，将这些元素中最大的一个放到这些无序元素的最后一个元素的位置，标志着这个元素完成排序——变得有序。\n\n- C++实现 -- 初始版本\n\n```c++\nvoid swap(int * a,int * b)；\nvoid bubble_Sort(ElementTYpe A[],int N)  // A是待排序的数据 N代表的是数据的个数\n{\n    int p = 0,i = 0;\n  \tfor(p = N - 1;p>=0;p--)\n    {\n        for(i = 0;i < p;i++) // 从无序的数据中抛出最大的\n        {\n            if(A[i] > A[i+1])  // 比较元素\n            {\n                swap(A+i,(A+(i+1))); // 交换元素 \n            }\n        }\n    }\n}\n\nvoid swap(int * a,int * b)\n{\n    *a ^= *b;\n    *b ^= *a;\n    *a ^= *b;\n}\n```\n\n- 优化版本\n\n如是在某一次循环中，提前让数组有序，但是在上述的代码中，即使数据有序了，循环依旧会继续执行，我们需要一个标志，来知道数据已经有序：\n\n```C++\nvoid bubble_Sort(ElementTYpe A[],int N)  // A是待排序的数据 N代表的是数据的个数\n{\n    int p = 0,i = 0;\n    bool flag = false;       // 标识数组是否有序\n  \tfor(p = N - 1;p>=0;p--)\n    {\n        for(i = 0;i < p;i++) // 从无序的数据中抛出最大的\n        {\n            if(A[i] > A[i+1])  // 比较元素\n            {\n                swap(A+i,(A+(i+1))); // 交换元素\n                flag = true;\n            }\n        }\n        if(!flag)  // 满足退出条件 结束循环\n        {\n            break; \n        }\n    }\n}\n```\n- 结果展示\n  - 输入与数据：`int a[7] = {3,1,2,98,30,8,90};`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/bubble_sort.png)\n\n- 复杂度分析 - 优化版本\n\n最好的情况：默认传输进来的元素是有序的，我们只需要，经历一次数据的遍历`flag`变量会触发循环结束，复杂度：\n\n<center>T = O(N)</center>\n\n最坏情况：元素逆序，需要遍历比较所有的元素\n\n<center>T = O(N^2)</center>\n\n#### 2、插入排序\n\n插入排序：不发生元素的交换，但是会发生元素的移动，每次获取一个元素(P)，将这个P插入到一个有序的序列中，插入的过程是一个比较+覆盖的过程。\n\n- C++实现 \n\n  ```C++\n  void Insertion_Sort(ElementType A[],int N)\n  {\n      int p,i，tmp;\n      for(p = 1;p < N;p++)\n      {\n          tmp = A[p];  // 获取插入的元素 \n          for(i = p;i > 0 && A[i - 1] > tmp;i--) // A[i-1]表示的是有序序列中的最大元素\n          {\n              A[i] = A[i-1];\n          }\n          // 比较结束后，当前 i - 1指向位置的元素是小于 tmp的，所以：\n          A[i] = tmp;\n      }\n  }\n  ```\n\n- 结果展示\n\n  - 输入与数据：`int a[7] = {3,1,1,98,30,8,90};`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/insertion_sort.png)\n\n- 复杂度分析：\n\n  最好情况，每次进来的元素不需要，比较。直接插入到相应的位置，此时时间复杂度：\n\n  <center>T = O(N)</center>\n\n  最坏情况，数据逆序，每一次的元素都需要遍历所有的有序元素，此时时间复杂度：\n\n  <center>T = O(N^2)</center>\n\n#### 补充说明：\n\n- 时间复杂度下界\n\n&ensp;&ensp;&ensp;&ensp;概念：对于下边`i<j`如果A[i] > A[j]，则称`(i,j)`是一对逆序对<font color=red>逆序对(inversion)</font>\n\n- 在上述的排序中，相邻元素的交换其实是消掉逆序对的操作！<font color=red>如果序列基本有序，那么插入排序简单且高效</font>\n\n<center>插入排序：T(N,I) = O(N+I)</center>\n\n- 对于N个不同元素组成的序列，平均具有`N(N-1)/4`个逆序对。\n\n- 对于仅以交换相邻元素来排序的算法，其平均时间复杂度为婐`Ω(N^2)`\n\n基于上面的描述，我们要提高此类算法的效率，必须每次消去的逆序对数大于1。\n\n### 下面将会介绍，希尔排序！\n\n","slug":"sort-bubble-insertion","published":1,"updated":"2022-07-26T00:48:36.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vca001gucuu3hs992hp","content":"<h2 id=\"简单排序\"><a href=\"#简单排序\" class=\"headerlink\" title=\"简单排序:\"></a>简单排序:</h2><ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n</ul>\n<p>上述两种排序是相对基础的简单排序,通过交换逆序对逐渐使序列有序。</p>\n<p>在常规的排序算法中：我们默认的顺序是从小到大</p>\n<h4 id=\"1、冒泡排序\"><a href=\"#1、冒泡排序\" class=\"headerlink\" title=\"1、冒泡排序\"></a>1、冒泡排序</h4><p>&ensp;&ensp;原理： 冒泡排序是一个两重的<code>for</code>循环，外面一层每循环一次就代表有一个元素被放好，第二重循环做的事情是从没有排好序的元素中取出一个，然后依次和后面的元素作比较，将这些元素中最大的一个放到这些无序元素的最后一个元素的位置，标志着这个元素完成排序——变得有序。</p>\n<ul>\n<li>C++实现 – 初始版本</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap(int * a,int * b)；</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_Sort</span><span class=\"params\">(ElementTYpe A[],<span class=\"keyword\">int</span> N)</span>  <span class=\"comment\">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(p = N - <span class=\"number\">1</span>;p&gt;=<span class=\"number\">0</span>;p--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; p;i++) <span class=\"comment\">// 从无序的数据中抛出最大的</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i] &gt; A[i+<span class=\"number\">1</span>])  <span class=\"comment\">// 比较元素</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(A+i,(A+(i+<span class=\"number\">1</span>))); <span class=\"comment\">// 交换元素 </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> * a,<span class=\"keyword\">int</span> * b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    *a ^= *b;</span><br><span class=\"line\">    *b ^= *a;</span><br><span class=\"line\">    *a ^= *b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优化版本</li>\n</ul>\n<p>如是在某一次循环中，提前让数组有序，但是在上述的代码中，即使数据有序了，循环依旧会继续执行，我们需要一个标志，来知道数据已经有序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_Sort</span><span class=\"params\">(ElementTYpe A[],<span class=\"keyword\">int</span> N)</span>  <span class=\"comment\">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;       <span class=\"comment\">// 标识数组是否有序</span></span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(p = N - <span class=\"number\">1</span>;p&gt;=<span class=\"number\">0</span>;p--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; p;i++) <span class=\"comment\">// 从无序的数据中抛出最大的</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i] &gt; A[i+<span class=\"number\">1</span>])  <span class=\"comment\">// 比较元素</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(A+i,(A+(i+<span class=\"number\">1</span>))); <span class=\"comment\">// 交换元素</span></span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag)  <span class=\"comment\">// 满足退出条件 结束循环</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果展示<ul>\n<li>输入与数据：<code>int a[7] = &#123;3,1,2,98,30,8,90&#125;;</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/bubble_sort.png\"></p>\n<ul>\n<li>复杂度分析 - 优化版本</li>\n</ul>\n<p>最好的情况：默认传输进来的元素是有序的，我们只需要，经历一次数据的遍历<code>flag</code>变量会触发循环结束，复杂度：</p>\n<center>T = O(N)</center>\n\n<p>最坏情况：元素逆序，需要遍历比较所有的元素</p>\n<center>T = O(N^2)</center>\n\n<h4 id=\"2、插入排序\"><a href=\"#2、插入排序\" class=\"headerlink\" title=\"2、插入排序\"></a>2、插入排序</h4><p>插入排序：不发生元素的交换，但是会发生元素的移动，每次获取一个元素(P)，将这个P插入到一个有序的序列中，插入的过程是一个比较+覆盖的过程。</p>\n<ul>\n<li><p>C++实现 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insertion_Sort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p,i，tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = <span class=\"number\">1</span>;p &lt; N;p++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp = A[p];  <span class=\"comment\">// 获取插入的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = p;i &gt; <span class=\"number\">0</span> &amp;&amp; A[i - <span class=\"number\">1</span>] &gt; tmp;i--) <span class=\"comment\">// A[i-1]表示的是有序序列中的最大元素</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            A[i] = A[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 比较结束后，当前 i - 1指向位置的元素是小于 tmp的，所以：</span></span><br><span class=\"line\">        A[i] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结果展示</p>\n<ul>\n<li>输入与数据：<code>int a[7] = &#123;3,1,1,98,30,8,90&#125;;</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/insertion_sort.png\"></p>\n<ul>\n<li><p>复杂度分析：</p>\n<p>最好情况，每次进来的元素不需要，比较。直接插入到相应的位置，此时时间复杂度：</p>\n<center>T = O(N)</center>\n\n<p>最坏情况，数据逆序，每一次的元素都需要遍历所有的有序元素，此时时间复杂度：</p>\n<center>T = O(N^2)</center></li>\n</ul>\n<h4 id=\"补充说明：\"><a href=\"#补充说明：\" class=\"headerlink\" title=\"补充说明：\"></a>补充说明：</h4><ul>\n<li>时间复杂度下界</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;概念：对于下边<code>i&lt;j</code>如果A[i] &gt; A[j]，则称<code>(i,j)</code>是一对逆序对<font color=\"red\">逆序对(inversion)</font></p>\n<ul>\n<li>在上述的排序中，相邻元素的交换其实是消掉逆序对的操作！<font color=\"red\">如果序列基本有序，那么插入排序简单且高效</font></li>\n</ul>\n<center>插入排序：T(N,I) = O(N+I)</center>\n\n<ul>\n<li><p>对于N个不同元素组成的序列，平均具有<code>N(N-1)/4</code>个逆序对。</p>\n</li>\n<li><p>对于仅以交换相邻元素来排序的算法，其平均时间复杂度为婐<code>Ω(N^2)</code></p>\n</li>\n</ul>\n<p>基于上面的描述，我们要提高此类算法的效率，必须每次消去的逆序对数大于1。</p>\n<h3 id=\"下面将会介绍，希尔排序！\"><a href=\"#下面将会介绍，希尔排序！\" class=\"headerlink\" title=\"下面将会介绍，希尔排序！\"></a>下面将会介绍，希尔排序！</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单排序\"><a href=\"#简单排序\" class=\"headerlink\" title=\"简单排序:\"></a>简单排序:</h2><ul>\n<li>冒泡排序</li>\n<li>插入排序</li>\n</ul>\n<p>上述两种排序是相对基础的简单排序,通过交换逆序对逐渐使序列有序。</p>\n<p>在常规的排序算法中：我们默认的顺序是从小到大</p>\n<h4 id=\"1、冒泡排序\"><a href=\"#1、冒泡排序\" class=\"headerlink\" title=\"1、冒泡排序\"></a>1、冒泡排序</h4><p>&ensp;&ensp;原理： 冒泡排序是一个两重的<code>for</code>循环，外面一层每循环一次就代表有一个元素被放好，第二重循环做的事情是从没有排好序的元素中取出一个，然后依次和后面的元素作比较，将这些元素中最大的一个放到这些无序元素的最后一个元素的位置，标志着这个元素完成排序——变得有序。</p>\n<ul>\n<li>C++实现 – 初始版本</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void swap(int * a,int * b)；</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_Sort</span><span class=\"params\">(ElementTYpe A[],<span class=\"keyword\">int</span> N)</span>  <span class=\"comment\">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(p = N - <span class=\"number\">1</span>;p&gt;=<span class=\"number\">0</span>;p--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; p;i++) <span class=\"comment\">// 从无序的数据中抛出最大的</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i] &gt; A[i+<span class=\"number\">1</span>])  <span class=\"comment\">// 比较元素</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(A+i,(A+(i+<span class=\"number\">1</span>))); <span class=\"comment\">// 交换元素 </span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span> * a,<span class=\"keyword\">int</span> * b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    *a ^= *b;</span><br><span class=\"line\">    *b ^= *a;</span><br><span class=\"line\">    *a ^= *b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优化版本</li>\n</ul>\n<p>如是在某一次循环中，提前让数组有序，但是在上述的代码中，即使数据有序了，循环依旧会继续执行，我们需要一个标志，来知道数据已经有序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bubble_Sort</span><span class=\"params\">(ElementTYpe A[],<span class=\"keyword\">int</span> N)</span>  <span class=\"comment\">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag = <span class=\"literal\">false</span>;       <span class=\"comment\">// 标识数组是否有序</span></span><br><span class=\"line\">  \t<span class=\"keyword\">for</span>(p = N - <span class=\"number\">1</span>;p&gt;=<span class=\"number\">0</span>;p--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; p;i++) <span class=\"comment\">// 从无序的数据中抛出最大的</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(A[i] &gt; A[i+<span class=\"number\">1</span>])  <span class=\"comment\">// 比较元素</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                swap(A+i,(A+(i+<span class=\"number\">1</span>))); <span class=\"comment\">// 交换元素</span></span><br><span class=\"line\">                flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag)  <span class=\"comment\">// 满足退出条件 结束循环</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果展示<ul>\n<li>输入与数据：<code>int a[7] = &#123;3,1,2,98,30,8,90&#125;;</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/bubble_sort.png\"></p>\n<ul>\n<li>复杂度分析 - 优化版本</li>\n</ul>\n<p>最好的情况：默认传输进来的元素是有序的，我们只需要，经历一次数据的遍历<code>flag</code>变量会触发循环结束，复杂度：</p>\n<center>T = O(N)</center>\n\n<p>最坏情况：元素逆序，需要遍历比较所有的元素</p>\n<center>T = O(N^2)</center>\n\n<h4 id=\"2、插入排序\"><a href=\"#2、插入排序\" class=\"headerlink\" title=\"2、插入排序\"></a>2、插入排序</h4><p>插入排序：不发生元素的交换，但是会发生元素的移动，每次获取一个元素(P)，将这个P插入到一个有序的序列中，插入的过程是一个比较+覆盖的过程。</p>\n<ul>\n<li><p>C++实现 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Insertion_Sort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p,i，tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = <span class=\"number\">1</span>;p &lt; N;p++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tmp = A[p];  <span class=\"comment\">// 获取插入的元素 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = p;i &gt; <span class=\"number\">0</span> &amp;&amp; A[i - <span class=\"number\">1</span>] &gt; tmp;i--) <span class=\"comment\">// A[i-1]表示的是有序序列中的最大元素</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            A[i] = A[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 比较结束后，当前 i - 1指向位置的元素是小于 tmp的，所以：</span></span><br><span class=\"line\">        A[i] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结果展示</p>\n<ul>\n<li>输入与数据：<code>int a[7] = &#123;3,1,1,98,30,8,90&#125;;</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/insertion_sort.png\"></p>\n<ul>\n<li><p>复杂度分析：</p>\n<p>最好情况，每次进来的元素不需要，比较。直接插入到相应的位置，此时时间复杂度：</p>\n<center>T = O(N)</center>\n\n<p>最坏情况，数据逆序，每一次的元素都需要遍历所有的有序元素，此时时间复杂度：</p>\n<center>T = O(N^2)</center></li>\n</ul>\n<h4 id=\"补充说明：\"><a href=\"#补充说明：\" class=\"headerlink\" title=\"补充说明：\"></a>补充说明：</h4><ul>\n<li>时间复杂度下界</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;概念：对于下边<code>i&lt;j</code>如果A[i] &gt; A[j]，则称<code>(i,j)</code>是一对逆序对<font color=\"red\">逆序对(inversion)</font></p>\n<ul>\n<li>在上述的排序中，相邻元素的交换其实是消掉逆序对的操作！<font color=\"red\">如果序列基本有序，那么插入排序简单且高效</font></li>\n</ul>\n<center>插入排序：T(N,I) = O(N+I)</center>\n\n<ul>\n<li><p>对于N个不同元素组成的序列，平均具有<code>N(N-1)/4</code>个逆序对。</p>\n</li>\n<li><p>对于仅以交换相邻元素来排序的算法，其平均时间复杂度为婐<code>Ω(N^2)</code></p>\n</li>\n</ul>\n<p>基于上面的描述，我们要提高此类算法的效率，必须每次消去的逆序对数大于1。</p>\n<h3 id=\"下面将会介绍，希尔排序！\"><a href=\"#下面将会介绍，希尔排序！\" class=\"headerlink\" title=\"下面将会介绍，希尔排序！\"></a>下面将会介绍，希尔排序！</h3>"},{"title":"归并排序","date":"2021-10-26T15:53:24.000Z","_content":"\n## 归并排序\n\n- 归并算法，核心机制是分而治之，每次对数据进行拆分，然后合并，每次拆分直到每次排序的元素个数为1，的时候，单个元素必然是有序的，然后合并便可。\n\n#### 1、有序子列的归并 - 伪代码 \n\n```C++ \n// L 左边的起始位置 R 右边的起始位置 RightEnd 右边的终点位置\nvoid Merge(ElementType A[],ElementType tempA[],int L,int R,int RightEnd)\n{\n    leftEnd = R - 1  // 左边部分有序元素的结束位置\n    temp_index = L;  // 存放结果数组的初始位置\n    NumElements = RightEnd - L + 1;   // 计算元素的总个数 - 左右两部份紧挨着 \n\n    while(L <= LeftEnd && R <= RightEnd)\n    {\n        if(A[L] < A[R])\n        {\n            tempA[temp_index++] = A[L++];\n        }\n        else  // A[L] > A[R]\n        {\n            tempA[temp_index++] = A[R++];\n        }\n    }\n    while(L <= LeftEnd)\n    {\n        tempA[temp_index++] = A[L++];\n    }\n    while(R <= RightEnd)\n    {\n        tempA[temp_index++] = A[R++];\n    }\n    // 将有序的元素写回到A中\n    for(int i =0;i < NumElements;i++,RightEnd--)\n    {\n        A[RightEnd] = tempA[RightEnd];\n    }\n}\n\n```\n\n#### 2、归并的实现 - 递归\n\n- 归并算法的实现有不同的方式，相比之下递归的实现方式相对直观，此处是递归实现的伪代码：\n\n```C++ \nvoid Msort(ElementType A[],ElementType tempA[],int L,int RightEnd)\n{\n    int center;  // 每次将元素对半砍开 \n    if(L < RightEnd)\n    {\n        center = (L + RightEnd) / 2;          // 中间位置的元素\n        MSort(A,tempA,L,center);              //左半部分 \n        MSort(A,tempA,center+1，RightEnd);    //右半部分 \n    \tMerge(A,tempA,L,center+1,RightEnd);   // 合并两部分 \n    }\n}\n```\n\n#### 2、归并的实现 - 非递归\n\n```C++ \nvoid Merge_Sort(ElementType A[],int N)\n{\n    int length = 1;   // 最开始 有序子列的长度\n    ElementType * tempA;   // 一个辅助交换的和A等大小的空间\n    tempA = new ElementType[N];\n    if(tempA != nullptr)\n    {\n        while(length < N)  // 随着有序子列的扩大，最终一定大于等于N\n        {\n            Merge_pass(A,tempA,N,length);\n            length *= 2;\n            Merge_pass(tempA,A,N,length);\n            length *= 2;\n        }\n        delete [] tempA;\n    }\n    else\n    {\n        std::cout<<\"error\"<<std::endl;\n    }\n}\n\n// 源元素位置 目标元素位置 元素个数 有序子列的大小\nvoid Merge_pass(ElementType A,ElementType tempA,int N,int length)\n{\n    for(i = 0;i <= N - 2*length;i += 2*length)   // 2*length 每次合并的元素的个数 \n    {\n        Merge_(A,tempA,i,i+length,i+2*length - 1);  // 合并\n    }\n    if(i+legnth < N)  // 剩下的元素个数 > length, 表示还可以进行一次合并： 一组的个数\n    {\n        // 此时最后被合并的数据 个数 < 2*length \n\t\tMerge_(A,tempA,i,i+length,N - 1);  // 合并\n    }\n    else\n    {\n        // 合并最后部分的元素\n        for(j = i; j < N;j++)\n        {\n            tempA[j] = A[j];\n        }\n    }\n}\n\nvoid Merge_(ElementType A[],ElementType tempA[],int L,int R,int RightEnd)\n{\n    leftEnd = R - 1  // 左边部分有序元素的结束位置\n    temp_index = L;  // 存放结果数组的初始位置\n    NumElements = RightEnd - L + 1;   // 计算元素的总个数 - 左右两部份紧挨着 \n\n    while(L <= LeftEnd && R <= RightEnd)\n    {\n        if(A[L] < A[R])\n        {\n            tempA[temp_index++] = A[L++];\n        }\n        else  // A[L] > A[R]\n        {\n            tempA[temp_index++] = A[R++];\n        }\n    }\n    while(L <= LeftEnd)\n    {\n        tempA[temp_index++] = A[L++];\n    }\n    while(R <= RightEnd)\n    {\n        tempA[temp_index++] = A[R++];\n    }\n}\n```\n\n","source":"_posts/归并排序.md","raw":"---\ntitle: 归并排序\ndate: 2021-10-26 23:53:24\ncategories:\n- Algorithm\ntags:\n- cpp\n- sort\n---\n\n## 归并排序\n\n- 归并算法，核心机制是分而治之，每次对数据进行拆分，然后合并，每次拆分直到每次排序的元素个数为1，的时候，单个元素必然是有序的，然后合并便可。\n\n#### 1、有序子列的归并 - 伪代码 \n\n```C++ \n// L 左边的起始位置 R 右边的起始位置 RightEnd 右边的终点位置\nvoid Merge(ElementType A[],ElementType tempA[],int L,int R,int RightEnd)\n{\n    leftEnd = R - 1  // 左边部分有序元素的结束位置\n    temp_index = L;  // 存放结果数组的初始位置\n    NumElements = RightEnd - L + 1;   // 计算元素的总个数 - 左右两部份紧挨着 \n\n    while(L <= LeftEnd && R <= RightEnd)\n    {\n        if(A[L] < A[R])\n        {\n            tempA[temp_index++] = A[L++];\n        }\n        else  // A[L] > A[R]\n        {\n            tempA[temp_index++] = A[R++];\n        }\n    }\n    while(L <= LeftEnd)\n    {\n        tempA[temp_index++] = A[L++];\n    }\n    while(R <= RightEnd)\n    {\n        tempA[temp_index++] = A[R++];\n    }\n    // 将有序的元素写回到A中\n    for(int i =0;i < NumElements;i++,RightEnd--)\n    {\n        A[RightEnd] = tempA[RightEnd];\n    }\n}\n\n```\n\n#### 2、归并的实现 - 递归\n\n- 归并算法的实现有不同的方式，相比之下递归的实现方式相对直观，此处是递归实现的伪代码：\n\n```C++ \nvoid Msort(ElementType A[],ElementType tempA[],int L,int RightEnd)\n{\n    int center;  // 每次将元素对半砍开 \n    if(L < RightEnd)\n    {\n        center = (L + RightEnd) / 2;          // 中间位置的元素\n        MSort(A,tempA,L,center);              //左半部分 \n        MSort(A,tempA,center+1，RightEnd);    //右半部分 \n    \tMerge(A,tempA,L,center+1,RightEnd);   // 合并两部分 \n    }\n}\n```\n\n#### 2、归并的实现 - 非递归\n\n```C++ \nvoid Merge_Sort(ElementType A[],int N)\n{\n    int length = 1;   // 最开始 有序子列的长度\n    ElementType * tempA;   // 一个辅助交换的和A等大小的空间\n    tempA = new ElementType[N];\n    if(tempA != nullptr)\n    {\n        while(length < N)  // 随着有序子列的扩大，最终一定大于等于N\n        {\n            Merge_pass(A,tempA,N,length);\n            length *= 2;\n            Merge_pass(tempA,A,N,length);\n            length *= 2;\n        }\n        delete [] tempA;\n    }\n    else\n    {\n        std::cout<<\"error\"<<std::endl;\n    }\n}\n\n// 源元素位置 目标元素位置 元素个数 有序子列的大小\nvoid Merge_pass(ElementType A,ElementType tempA,int N,int length)\n{\n    for(i = 0;i <= N - 2*length;i += 2*length)   // 2*length 每次合并的元素的个数 \n    {\n        Merge_(A,tempA,i,i+length,i+2*length - 1);  // 合并\n    }\n    if(i+legnth < N)  // 剩下的元素个数 > length, 表示还可以进行一次合并： 一组的个数\n    {\n        // 此时最后被合并的数据 个数 < 2*length \n\t\tMerge_(A,tempA,i,i+length,N - 1);  // 合并\n    }\n    else\n    {\n        // 合并最后部分的元素\n        for(j = i; j < N;j++)\n        {\n            tempA[j] = A[j];\n        }\n    }\n}\n\nvoid Merge_(ElementType A[],ElementType tempA[],int L,int R,int RightEnd)\n{\n    leftEnd = R - 1  // 左边部分有序元素的结束位置\n    temp_index = L;  // 存放结果数组的初始位置\n    NumElements = RightEnd - L + 1;   // 计算元素的总个数 - 左右两部份紧挨着 \n\n    while(L <= LeftEnd && R <= RightEnd)\n    {\n        if(A[L] < A[R])\n        {\n            tempA[temp_index++] = A[L++];\n        }\n        else  // A[L] > A[R]\n        {\n            tempA[temp_index++] = A[R++];\n        }\n    }\n    while(L <= LeftEnd)\n    {\n        tempA[temp_index++] = A[L++];\n    }\n    while(R <= RightEnd)\n    {\n        tempA[temp_index++] = A[R++];\n    }\n}\n```\n\n","slug":"归并排序","published":1,"updated":"2022-07-26T00:48:36.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vcc001kucuu76l7cd3m","content":"<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><ul>\n<li>归并算法，核心机制是分而治之，每次对数据进行拆分，然后合并，每次拆分直到每次排序的元素个数为1，的时候，单个元素必然是有序的，然后合并便可。</li>\n</ul>\n<h4 id=\"1、有序子列的归并-伪代码\"><a href=\"#1、有序子列的归并-伪代码\" class=\"headerlink\" title=\"1、有序子列的归并 - 伪代码\"></a>1、有序子列的归并 - 伪代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// L 左边的起始位置 R 右边的起始位置 RightEnd 右边的终点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    leftEnd = R - <span class=\"number\">1</span>  <span class=\"comment\">// 左边部分有序元素的结束位置</span></span><br><span class=\"line\">    temp_index = L;  <span class=\"comment\">// 存放结果数组的初始位置</span></span><br><span class=\"line\">    NumElements = RightEnd - L + <span class=\"number\">1</span>;   <span class=\"comment\">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A[L] &lt; A[R])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[L++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">// A[L] &gt; A[R]</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[R++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[L++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[R++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将有序的元素写回到A中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i &lt; NumElements;i++,RightEnd--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        A[RightEnd] = tempA[RightEnd];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、归并的实现-递归\"><a href=\"#2、归并的实现-递归\" class=\"headerlink\" title=\"2、归并的实现 - 递归\"></a>2、归并的实现 - 递归</h4><ul>\n<li>归并算法的实现有不同的方式，相比之下递归的实现方式相对直观，此处是递归实现的伪代码：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Msort</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center;  <span class=\"comment\">// 每次将元素对半砍开 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L &lt; RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        center = (L + RightEnd) / <span class=\"number\">2</span>;          <span class=\"comment\">// 中间位置的元素</span></span><br><span class=\"line\">        MSort(A,tempA,L,center);              <span class=\"comment\">//左半部分 </span></span><br><span class=\"line\">        MSort(A,tempA,center+<span class=\"number\">1</span>，RightEnd);    <span class=\"comment\">//右半部分 </span></span><br><span class=\"line\">    \tMerge(A,tempA,L,center+<span class=\"number\">1</span>,RightEnd);   <span class=\"comment\">// 合并两部分 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、归并的实现-非递归\"><a href=\"#2、归并的实现-非递归\" class=\"headerlink\" title=\"2、归并的实现 - 非递归\"></a>2、归并的实现 - 非递归</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_Sort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"number\">1</span>;   <span class=\"comment\">// 最开始 有序子列的长度</span></span><br><span class=\"line\">    ElementType * tempA;   <span class=\"comment\">// 一个辅助交换的和A等大小的空间</span></span><br><span class=\"line\">    tempA = <span class=\"keyword\">new</span> ElementType[N];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempA != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(length &lt; N)  <span class=\"comment\">// 随着有序子列的扩大，最终一定大于等于N</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Merge_pass(A,tempA,N,length);</span><br><span class=\"line\">            length *= <span class=\"number\">2</span>;</span><br><span class=\"line\">            Merge_pass(tempA,A,N,length);</span><br><span class=\"line\">            length *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tempA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;error&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 源元素位置 目标元素位置 元素个数 有序子列的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_pass</span><span class=\"params\">(ElementType A,ElementType tempA,<span class=\"keyword\">int</span> N,<span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt;= N - <span class=\"number\">2</span>*length;i += <span class=\"number\">2</span>*length)   <span class=\"comment\">// 2*length 每次合并的元素的个数 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Merge_(A,tempA,i,i+length,i+<span class=\"number\">2</span>*length - <span class=\"number\">1</span>);  <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i+legnth &lt; N)  <span class=\"comment\">// 剩下的元素个数 &gt; length, 表示还可以进行一次合并： 一组的个数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此时最后被合并的数据 个数 &lt; 2*length </span></span><br><span class=\"line\">\t\tMerge_(A,tempA,i,i+length,N - <span class=\"number\">1</span>);  <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 合并最后部分的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i; j &lt; N;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[j] = A[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    leftEnd = R - <span class=\"number\">1</span>  <span class=\"comment\">// 左边部分有序元素的结束位置</span></span><br><span class=\"line\">    temp_index = L;  <span class=\"comment\">// 存放结果数组的初始位置</span></span><br><span class=\"line\">    NumElements = RightEnd - L + <span class=\"number\">1</span>;   <span class=\"comment\">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A[L] &lt; A[R])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[L++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">// A[L] &gt; A[R]</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[R++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[L++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[R++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><ul>\n<li>归并算法，核心机制是分而治之，每次对数据进行拆分，然后合并，每次拆分直到每次排序的元素个数为1，的时候，单个元素必然是有序的，然后合并便可。</li>\n</ul>\n<h4 id=\"1、有序子列的归并-伪代码\"><a href=\"#1、有序子列的归并-伪代码\" class=\"headerlink\" title=\"1、有序子列的归并 - 伪代码\"></a>1、有序子列的归并 - 伪代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// L 左边的起始位置 R 右边的起始位置 RightEnd 右边的终点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    leftEnd = R - <span class=\"number\">1</span>  <span class=\"comment\">// 左边部分有序元素的结束位置</span></span><br><span class=\"line\">    temp_index = L;  <span class=\"comment\">// 存放结果数组的初始位置</span></span><br><span class=\"line\">    NumElements = RightEnd - L + <span class=\"number\">1</span>;   <span class=\"comment\">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A[L] &lt; A[R])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[L++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">// A[L] &gt; A[R]</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[R++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[L++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[R++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将有序的元素写回到A中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i &lt; NumElements;i++,RightEnd--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        A[RightEnd] = tempA[RightEnd];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、归并的实现-递归\"><a href=\"#2、归并的实现-递归\" class=\"headerlink\" title=\"2、归并的实现 - 递归\"></a>2、归并的实现 - 递归</h4><ul>\n<li>归并算法的实现有不同的方式，相比之下递归的实现方式相对直观，此处是递归实现的伪代码：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Msort</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> center;  <span class=\"comment\">// 每次将元素对半砍开 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L &lt; RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        center = (L + RightEnd) / <span class=\"number\">2</span>;          <span class=\"comment\">// 中间位置的元素</span></span><br><span class=\"line\">        MSort(A,tempA,L,center);              <span class=\"comment\">//左半部分 </span></span><br><span class=\"line\">        MSort(A,tempA,center+<span class=\"number\">1</span>，RightEnd);    <span class=\"comment\">//右半部分 </span></span><br><span class=\"line\">    \tMerge(A,tempA,L,center+<span class=\"number\">1</span>,RightEnd);   <span class=\"comment\">// 合并两部分 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、归并的实现-非递归\"><a href=\"#2、归并的实现-非递归\" class=\"headerlink\" title=\"2、归并的实现 - 非递归\"></a>2、归并的实现 - 非递归</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_Sort</span><span class=\"params\">(ElementType A[],<span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"number\">1</span>;   <span class=\"comment\">// 最开始 有序子列的长度</span></span><br><span class=\"line\">    ElementType * tempA;   <span class=\"comment\">// 一个辅助交换的和A等大小的空间</span></span><br><span class=\"line\">    tempA = <span class=\"keyword\">new</span> ElementType[N];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempA != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(length &lt; N)  <span class=\"comment\">// 随着有序子列的扩大，最终一定大于等于N</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Merge_pass(A,tempA,N,length);</span><br><span class=\"line\">            length *= <span class=\"number\">2</span>;</span><br><span class=\"line\">            Merge_pass(tempA,A,N,length);</span><br><span class=\"line\">            length *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> [] tempA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;error&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 源元素位置 目标元素位置 元素个数 有序子列的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_pass</span><span class=\"params\">(ElementType A,ElementType tempA,<span class=\"keyword\">int</span> N,<span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt;= N - <span class=\"number\">2</span>*length;i += <span class=\"number\">2</span>*length)   <span class=\"comment\">// 2*length 每次合并的元素的个数 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Merge_(A,tempA,i,i+length,i+<span class=\"number\">2</span>*length - <span class=\"number\">1</span>);  <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i+legnth &lt; N)  <span class=\"comment\">// 剩下的元素个数 &gt; length, 表示还可以进行一次合并： 一组的个数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此时最后被合并的数据 个数 &lt; 2*length </span></span><br><span class=\"line\">\t\tMerge_(A,tempA,i,i+length,N - <span class=\"number\">1</span>);  <span class=\"comment\">// 合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 合并最后部分的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i; j &lt; N;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[j] = A[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Merge_</span><span class=\"params\">(ElementType A[],ElementType tempA[],<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> RightEnd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    leftEnd = R - <span class=\"number\">1</span>  <span class=\"comment\">// 左边部分有序元素的结束位置</span></span><br><span class=\"line\">    temp_index = L;  <span class=\"comment\">// 存放结果数组的初始位置</span></span><br><span class=\"line\">    NumElements = RightEnd - L + <span class=\"number\">1</span>;   <span class=\"comment\">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A[L] &lt; A[R])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[L++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">// A[L] &gt; A[R]</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tempA[temp_index++] = A[R++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(L &lt;= LeftEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[L++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(R &lt;= RightEnd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tempA[temp_index++] = A[R++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"微信多开","date":"2022-02-28T14:11:02.000Z","_content":"\n## 微信多开的小技巧 - Windows\n\n- 首先，需要你知道你机器上安装微信 - 请记录它的安装位置\n\n- 一般情况下，如果你不做任何修改的话，它会在`C:\\Program Files (x86)\\Tencent\\WeChat`这个目录下：\n&ensp;&ensp; ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png \"微信安装位置\")\n\n- 然后，打开你机器上任意的一个文本编辑器，输入如下内容：\n\n- 需要多开多少个微信，你便将如下命令输入重复写多少次。\n\n    ```bash\n    start D:\\\"Program Files (x86)\"\\Tencent\\WeChat\\WeChat.exe\n    start D:\\\"Program Files (x86)\"\\Tencent\\WeChat\\WeChat.exe\n    \n    # 请将上面的路径换成你机器上安装微信的路径\n    # 上面表示的是同时开两个微信程序\n    # 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别\n    \n    ```\n\n- 然后将文件保存，文件后缀为`.bat`,这是`cmd`识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。\n\n  ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png \"微信多开效果图\")\n\n","source":"_posts/微信多开.md","raw":"---\ntitle: 微信多开\ndate: 2022-02-28 22:11:02\ncategories:\n- Tips\ntags:\n- windows\n---\n\n## 微信多开的小技巧 - Windows\n\n- 首先，需要你知道你机器上安装微信 - 请记录它的安装位置\n\n- 一般情况下，如果你不做任何修改的话，它会在`C:\\Program Files (x86)\\Tencent\\WeChat`这个目录下：\n&ensp;&ensp; ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png \"微信安装位置\")\n\n- 然后，打开你机器上任意的一个文本编辑器，输入如下内容：\n\n- 需要多开多少个微信，你便将如下命令输入重复写多少次。\n\n    ```bash\n    start D:\\\"Program Files (x86)\"\\Tencent\\WeChat\\WeChat.exe\n    start D:\\\"Program Files (x86)\"\\Tencent\\WeChat\\WeChat.exe\n    \n    # 请将上面的路径换成你机器上安装微信的路径\n    # 上面表示的是同时开两个微信程序\n    # 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别\n    \n    ```\n\n- 然后将文件保存，文件后缀为`.bat`,这是`cmd`识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。\n\n  ![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png \"微信多开效果图\")\n\n","slug":"微信多开","published":1,"updated":"2022-07-26T00:48:36.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vce001nucuu9yxya5vq","content":"<h2 id=\"微信多开的小技巧-Windows\"><a href=\"#微信多开的小技巧-Windows\" class=\"headerlink\" title=\"微信多开的小技巧 - Windows\"></a>微信多开的小技巧 - Windows</h2><ul>\n<li><p>首先，需要你知道你机器上安装微信 - 请记录它的安装位置</p>\n</li>\n<li><p>一般情况下，如果你不做任何修改的话，它会在<code>C:\\Program Files (x86)\\Tencent\\WeChat</code>这个目录下：<br>&ensp;&ensp; <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png\" title=\"微信安装位置\"></p>\n</li>\n<li><p>然后，打开你机器上任意的一个文本编辑器，输入如下内容：</p>\n</li>\n<li><p>需要多开多少个微信，你便将如下命令输入重复写多少次。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start D:\\&quot;Program Files (x86)<span class=\"string\">&quot;\\Tencent\\WeChat\\WeChat.exe</span></span><br><span class=\"line\"><span class=\"string\">start D:\\&quot;Program Files (x86)&quot;</span>\\Tencent\\WeChat\\WeChat.exe</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 请将上面的路径换成你机器上安装微信的路径</span></span><br><span class=\"line\"><span class=\"comment\"># 上面表示的是同时开两个微信程序</span></span><br><span class=\"line\"><span class=\"comment\"># 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>然后将文件保存，文件后缀为<code>.bat</code>,这是<code>cmd</code>识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。</p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png\" title=\"微信多开效果图\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"微信多开的小技巧-Windows\"><a href=\"#微信多开的小技巧-Windows\" class=\"headerlink\" title=\"微信多开的小技巧 - Windows\"></a>微信多开的小技巧 - Windows</h2><ul>\n<li><p>首先，需要你知道你机器上安装微信 - 请记录它的安装位置</p>\n</li>\n<li><p>一般情况下，如果你不做任何修改的话，它会在<code>C:\\Program Files (x86)\\Tencent\\WeChat</code>这个目录下：<br>&ensp;&ensp; <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png\" title=\"微信安装位置\"></p>\n</li>\n<li><p>然后，打开你机器上任意的一个文本编辑器，输入如下内容：</p>\n</li>\n<li><p>需要多开多少个微信，你便将如下命令输入重复写多少次。</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start D:\\&quot;Program Files (x86)<span class=\"string\">&quot;\\Tencent\\WeChat\\WeChat.exe</span></span><br><span class=\"line\"><span class=\"string\">start D:\\&quot;Program Files (x86)&quot;</span>\\Tencent\\WeChat\\WeChat.exe</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 请将上面的路径换成你机器上安装微信的路径</span></span><br><span class=\"line\"><span class=\"comment\"># 上面表示的是同时开两个微信程序</span></span><br><span class=\"line\"><span class=\"comment\"># 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>然后将文件保存，文件后缀为<code>.bat</code>,这是<code>cmd</code>识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。</p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png\" title=\"微信多开效果图\"></p>\n</li>\n</ul>\n"},{"title":"记一次总结","date":"2021-10-17T07:25:40.000Z","_content":"\n### \n\n`前记：`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/GF_Workspace.JPG)\n\n&ensp;&ensp;&ensp;&ensp;从辞职到新公司，过去了快两个月时间，经过这大段的时间，度过了试用期，开始接手往后日子里要进行的工作。\n\n&ensp; &ensp;&ensp;&ensp;新工作是关于```C++　&　OSG```的，做一个仿真软件，主要负责一些关于`osg`的渲染工作，和其中部分界面的编写，项目用到的还算是熟悉的东西：\n\n- `Qt`编写整个软件的界面\n- `osg`负责整个3D图形的展示\n\n&ensp; 关于这个项目遇到的一些问题：\n\n-   `osg`编译劝退\t\n\n&ensp;&ensp;&ensp;&ensp;讲真，`osg`的库的编译相当劝退，各种库的依赖关系，以及`VS`的工具链的选择，以及部分库的调试模式的选择。\n\n这里推荐<a ref=https://freesouth.blog.csdn.net/>杨石兴的博客</a>详细介绍了OSG的编译的一些问题，同时它提供了编译使用的所有的依赖包，各种工具集的版本。\n\n- `osg`与`Qt`的集成\n\n&ensp;&ensp;&ensp;&ensp;要求你先编译`osg`然后才能编译，`osgQt`在`osg3.4`之后的版本中便被从原来的库中剔除，需要自己单独编译，\n\n同时`Qt4.0`的版本与`5.0`的版本编译使用的`Qt`的类也存在一些区别。\n\n当前阶段，上面提到的这些问题，我们已经解决了，新一番的问题产生了：\n\n- 在于不同的团队合作的时候，如何扯皮！\n\n\n\n","source":"_posts/记一次总结.md","raw":"---\ntitle: 记一次总结\ndate: 2021-10-17 15:25:40\ntags:\n- conclusion\ncategories:\n- works\n- HJ\n---\n\n### \n\n`前记：`\n\n![](https://raw.githubusercontent.com/CuntBoy/images/main/blog/GF_Workspace.JPG)\n\n&ensp;&ensp;&ensp;&ensp;从辞职到新公司，过去了快两个月时间，经过这大段的时间，度过了试用期，开始接手往后日子里要进行的工作。\n\n&ensp; &ensp;&ensp;&ensp;新工作是关于```C++　&　OSG```的，做一个仿真软件，主要负责一些关于`osg`的渲染工作，和其中部分界面的编写，项目用到的还算是熟悉的东西：\n\n- `Qt`编写整个软件的界面\n- `osg`负责整个3D图形的展示\n\n&ensp; 关于这个项目遇到的一些问题：\n\n-   `osg`编译劝退\t\n\n&ensp;&ensp;&ensp;&ensp;讲真，`osg`的库的编译相当劝退，各种库的依赖关系，以及`VS`的工具链的选择，以及部分库的调试模式的选择。\n\n这里推荐<a ref=https://freesouth.blog.csdn.net/>杨石兴的博客</a>详细介绍了OSG的编译的一些问题，同时它提供了编译使用的所有的依赖包，各种工具集的版本。\n\n- `osg`与`Qt`的集成\n\n&ensp;&ensp;&ensp;&ensp;要求你先编译`osg`然后才能编译，`osgQt`在`osg3.4`之后的版本中便被从原来的库中剔除，需要自己单独编译，\n\n同时`Qt4.0`的版本与`5.0`的版本编译使用的`Qt`的类也存在一些区别。\n\n当前阶段，上面提到的这些问题，我们已经解决了，新一番的问题产生了：\n\n- 在于不同的团队合作的时候，如何扯皮！\n\n\n\n","slug":"记一次总结","published":1,"updated":"2022-07-26T00:48:36.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vcg001sucuu5h99fxt4","content":"<h3 id><a href=\"#\" class=\"headerlink\" title></a></h3><p><code>前记：</code></p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/GF_Workspace.JPG\"></p>\n<p>&ensp;&ensp;&ensp;&ensp;从辞职到新公司，过去了快两个月时间，经过这大段的时间，度过了试用期，开始接手往后日子里要进行的工作。</p>\n<p>&ensp; &ensp;&ensp;&ensp;新工作是关于<code>C++　&amp;　OSG</code>的，做一个仿真软件，主要负责一些关于<code>osg</code>的渲染工作，和其中部分界面的编写，项目用到的还算是熟悉的东西：</p>\n<ul>\n<li><code>Qt</code>编写整个软件的界面</li>\n<li><code>osg</code>负责整个3D图形的展示</li>\n</ul>\n<p>&ensp; 关于这个项目遇到的一些问题：</p>\n<ul>\n<li>  <code>osg</code>编译劝退    </li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;讲真，<code>osg</code>的库的编译相当劝退，各种库的依赖关系，以及<code>VS</code>的工具链的选择，以及部分库的调试模式的选择。</p>\n<p>这里推荐<a ref=\"https://freesouth.blog.csdn.net/\">杨石兴的博客</a>详细介绍了OSG的编译的一些问题，同时它提供了编译使用的所有的依赖包，各种工具集的版本。</p>\n<ul>\n<li><code>osg</code>与<code>Qt</code>的集成</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;要求你先编译<code>osg</code>然后才能编译，<code>osgQt</code>在<code>osg3.4</code>之后的版本中便被从原来的库中剔除，需要自己单独编译，</p>\n<p>同时<code>Qt4.0</code>的版本与<code>5.0</code>的版本编译使用的<code>Qt</code>的类也存在一些区别。</p>\n<p>当前阶段，上面提到的这些问题，我们已经解决了，新一番的问题产生了：</p>\n<ul>\n<li>在于不同的团队合作的时候，如何扯皮！</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id><a href=\"#\" class=\"headerlink\" title></a></h3><p><code>前记：</code></p>\n<p><img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/blog/GF_Workspace.JPG\"></p>\n<p>&ensp;&ensp;&ensp;&ensp;从辞职到新公司，过去了快两个月时间，经过这大段的时间，度过了试用期，开始接手往后日子里要进行的工作。</p>\n<p>&ensp; &ensp;&ensp;&ensp;新工作是关于<code>C++　&amp;　OSG</code>的，做一个仿真软件，主要负责一些关于<code>osg</code>的渲染工作，和其中部分界面的编写，项目用到的还算是熟悉的东西：</p>\n<ul>\n<li><code>Qt</code>编写整个软件的界面</li>\n<li><code>osg</code>负责整个3D图形的展示</li>\n</ul>\n<p>&ensp; 关于这个项目遇到的一些问题：</p>\n<ul>\n<li>  <code>osg</code>编译劝退    </li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;讲真，<code>osg</code>的库的编译相当劝退，各种库的依赖关系，以及<code>VS</code>的工具链的选择，以及部分库的调试模式的选择。</p>\n<p>这里推荐<a ref=\"https://freesouth.blog.csdn.net/\">杨石兴的博客</a>详细介绍了OSG的编译的一些问题，同时它提供了编译使用的所有的依赖包，各种工具集的版本。</p>\n<ul>\n<li><code>osg</code>与<code>Qt</code>的集成</li>\n</ul>\n<p>&ensp;&ensp;&ensp;&ensp;要求你先编译<code>osg</code>然后才能编译，<code>osgQt</code>在<code>osg3.4</code>之后的版本中便被从原来的库中剔除，需要自己单独编译，</p>\n<p>同时<code>Qt4.0</code>的版本与<code>5.0</code>的版本编译使用的<code>Qt</code>的类也存在一些区别。</p>\n<p>当前阶段，上面提到的这些问题，我们已经解决了，新一番的问题产生了：</p>\n<ul>\n<li>在于不同的团队合作的时候，如何扯皮！</li>\n</ul>\n"},{"title":"记一次面试","date":"2022-01-15T16:51:02.000Z","_content":"\n## 记一次面试:\n\n&ensp;&ensp;距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了.......\n&ensp;&ensp;这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是`CAD`方向，大概都是渲染相关的，所以还是符合我的预期。\n\n\n## Start Interview:\n\n- 首先这是一个`Cpp`&`图形`的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是`CPP`和`图形学`开发经验, 可以预见大概的问题就是`Cpp`和图形相关的知识。\n\n---\n\n\n### 第一次面试\n\n#### 关于简历中提到的之前的项目\n\n- 部分和之前项目相关的问题\n- 一些技术上的解决方案\n- ......\n\n#### CPP的新的语言特性\n\n- `C++11`的新语言特性 - 比较常用的\n  - 智能指针\n  - `auto`自动类型推导\n  - 标准库的多线程\n  - `lambda`表达式\n\n- 一些指针和引用相关的问题\n  - 指针是什么？\n  - 引用是什么？\n  - 两者的区别？\n  - 内存分区的相关问题，如：\n    - 常量在程序中的的存储位置\n    - 静态变量在什么位置\n    - ......\n\n#### 图形相关的问题\n\n- 图形管线的问题\n  - 坐标变换相关的问题\n    - 投影\n    - 视图\n\n- 一些渲染上面的解决方案\n  - 大数据量的绘制\n\n### 第二次面试\n\n&ensp;&ensp;第二次面试倒是没有什么技术相关的问题，两个老师，一个人士，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：\n\n- 个人介绍\t\n  - 基本信息\n  - 求学经历\n  - ......\n\n- 工作经历\n  - 项目经历\n\n- 未来的规划\n  - 职业规划\n  - 个人规划\n\n- 个人爱好\n\n&ensp;.......\n\n&ensp;&ensp;后面部分就是关于这个介绍的提问了，无关痛痒。\n\n&ensp;&ensp;一周以后......，在我以为黄了的时候，竟然通过了。\n\n&ensp;&ensp;感谢！\n\n","source":"_posts/记一次面试-1.md","raw":"---\ntitle: 记一次面试\ndate: 2022-01-16 00:51:02\ncategories:\n  - works\n  - interview\ntags:\n  - openGL\t\n  - cpp\n  - computer graphics\n---\n\n## 记一次面试:\n\n&ensp;&ensp;距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了.......\n&ensp;&ensp;这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是`CAD`方向，大概都是渲染相关的，所以还是符合我的预期。\n\n\n## Start Interview:\n\n- 首先这是一个`Cpp`&`图形`的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是`CPP`和`图形学`开发经验, 可以预见大概的问题就是`Cpp`和图形相关的知识。\n\n---\n\n\n### 第一次面试\n\n#### 关于简历中提到的之前的项目\n\n- 部分和之前项目相关的问题\n- 一些技术上的解决方案\n- ......\n\n#### CPP的新的语言特性\n\n- `C++11`的新语言特性 - 比较常用的\n  - 智能指针\n  - `auto`自动类型推导\n  - 标准库的多线程\n  - `lambda`表达式\n\n- 一些指针和引用相关的问题\n  - 指针是什么？\n  - 引用是什么？\n  - 两者的区别？\n  - 内存分区的相关问题，如：\n    - 常量在程序中的的存储位置\n    - 静态变量在什么位置\n    - ......\n\n#### 图形相关的问题\n\n- 图形管线的问题\n  - 坐标变换相关的问题\n    - 投影\n    - 视图\n\n- 一些渲染上面的解决方案\n  - 大数据量的绘制\n\n### 第二次面试\n\n&ensp;&ensp;第二次面试倒是没有什么技术相关的问题，两个老师，一个人士，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：\n\n- 个人介绍\t\n  - 基本信息\n  - 求学经历\n  - ......\n\n- 工作经历\n  - 项目经历\n\n- 未来的规划\n  - 职业规划\n  - 个人规划\n\n- 个人爱好\n\n&ensp;.......\n\n&ensp;&ensp;后面部分就是关于这个介绍的提问了，无关痛痒。\n\n&ensp;&ensp;一周以后......，在我以为黄了的时候，竟然通过了。\n\n&ensp;&ensp;感谢！\n\n","slug":"记一次面试-1","published":1,"updated":"2022-07-26T00:56:37.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vch001vucuu32kk9ixw","content":"<h2 id=\"记一次面试\"><a href=\"#记一次面试\" class=\"headerlink\" title=\"记一次面试:\"></a>记一次面试:</h2><p>&ensp;&ensp;距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了…….<br>&ensp;&ensp;这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是<code>CAD</code>方向，大概都是渲染相关的，所以还是符合我的预期。</p>\n<h2 id=\"Start-Interview\"><a href=\"#Start-Interview\" class=\"headerlink\" title=\"Start Interview:\"></a>Start Interview:</h2><ul>\n<li>首先这是一个<code>Cpp</code>&amp;<code>图形</code>的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是<code>CPP</code>和<code>图形学</code>开发经验, 可以预见大概的问题就是<code>Cpp</code>和图形相关的知识。</li>\n</ul>\n<hr>\n<h3 id=\"第一次面试\"><a href=\"#第一次面试\" class=\"headerlink\" title=\"第一次面试\"></a>第一次面试</h3><h4 id=\"关于简历中提到的之前的项目\"><a href=\"#关于简历中提到的之前的项目\" class=\"headerlink\" title=\"关于简历中提到的之前的项目\"></a>关于简历中提到的之前的项目</h4><ul>\n<li>部分和之前项目相关的问题</li>\n<li>一些技术上的解决方案</li>\n<li>……</li>\n</ul>\n<h4 id=\"CPP的新的语言特性\"><a href=\"#CPP的新的语言特性\" class=\"headerlink\" title=\"CPP的新的语言特性\"></a>CPP的新的语言特性</h4><ul>\n<li><p><code>C++11</code>的新语言特性 - 比较常用的</p>\n<ul>\n<li>智能指针</li>\n<li><code>auto</code>自动类型推导</li>\n<li>标准库的多线程</li>\n<li><code>lambda</code>表达式</li>\n</ul>\n</li>\n<li><p>一些指针和引用相关的问题</p>\n<ul>\n<li>指针是什么？</li>\n<li>引用是什么？</li>\n<li>两者的区别？</li>\n<li>内存分区的相关问题，如：<ul>\n<li>常量在程序中的的存储位置</li>\n<li>静态变量在什么位置</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"图形相关的问题\"><a href=\"#图形相关的问题\" class=\"headerlink\" title=\"图形相关的问题\"></a>图形相关的问题</h4><ul>\n<li><p>图形管线的问题</p>\n<ul>\n<li>坐标变换相关的问题<ul>\n<li>投影</li>\n<li>视图</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>一些渲染上面的解决方案</p>\n<ul>\n<li>大数据量的绘制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二次面试\"><a href=\"#第二次面试\" class=\"headerlink\" title=\"第二次面试\"></a>第二次面试</h3><p>&ensp;&ensp;第二次面试倒是没有什么技术相关的问题，两个老师，一个人士，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：</p>\n<ul>\n<li><p>个人介绍    </p>\n<ul>\n<li>基本信息</li>\n<li>求学经历</li>\n<li>……</li>\n</ul>\n</li>\n<li><p>工作经历</p>\n<ul>\n<li>项目经历</li>\n</ul>\n</li>\n<li><p>未来的规划</p>\n<ul>\n<li>职业规划</li>\n<li>个人规划</li>\n</ul>\n</li>\n<li><p>个人爱好</p>\n</li>\n</ul>\n<p>&ensp;…….</p>\n<p>&ensp;&ensp;后面部分就是关于这个介绍的提问了，无关痛痒。</p>\n<p>&ensp;&ensp;一周以后……，在我以为黄了的时候，竟然通过了。</p>\n<p>&ensp;&ensp;感谢！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"记一次面试\"><a href=\"#记一次面试\" class=\"headerlink\" title=\"记一次面试:\"></a>记一次面试:</h2><p>&ensp;&ensp;距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了…….<br>&ensp;&ensp;这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是<code>CAD</code>方向，大概都是渲染相关的，所以还是符合我的预期。</p>\n<h2 id=\"Start-Interview\"><a href=\"#Start-Interview\" class=\"headerlink\" title=\"Start Interview:\"></a>Start Interview:</h2><ul>\n<li>首先这是一个<code>Cpp</code>&amp;<code>图形</code>的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是<code>CPP</code>和<code>图形学</code>开发经验, 可以预见大概的问题就是<code>Cpp</code>和图形相关的知识。</li>\n</ul>\n<hr>\n<h3 id=\"第一次面试\"><a href=\"#第一次面试\" class=\"headerlink\" title=\"第一次面试\"></a>第一次面试</h3><h4 id=\"关于简历中提到的之前的项目\"><a href=\"#关于简历中提到的之前的项目\" class=\"headerlink\" title=\"关于简历中提到的之前的项目\"></a>关于简历中提到的之前的项目</h4><ul>\n<li>部分和之前项目相关的问题</li>\n<li>一些技术上的解决方案</li>\n<li>……</li>\n</ul>\n<h4 id=\"CPP的新的语言特性\"><a href=\"#CPP的新的语言特性\" class=\"headerlink\" title=\"CPP的新的语言特性\"></a>CPP的新的语言特性</h4><ul>\n<li><p><code>C++11</code>的新语言特性 - 比较常用的</p>\n<ul>\n<li>智能指针</li>\n<li><code>auto</code>自动类型推导</li>\n<li>标准库的多线程</li>\n<li><code>lambda</code>表达式</li>\n</ul>\n</li>\n<li><p>一些指针和引用相关的问题</p>\n<ul>\n<li>指针是什么？</li>\n<li>引用是什么？</li>\n<li>两者的区别？</li>\n<li>内存分区的相关问题，如：<ul>\n<li>常量在程序中的的存储位置</li>\n<li>静态变量在什么位置</li>\n<li>……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"图形相关的问题\"><a href=\"#图形相关的问题\" class=\"headerlink\" title=\"图形相关的问题\"></a>图形相关的问题</h4><ul>\n<li><p>图形管线的问题</p>\n<ul>\n<li>坐标变换相关的问题<ul>\n<li>投影</li>\n<li>视图</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>一些渲染上面的解决方案</p>\n<ul>\n<li>大数据量的绘制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第二次面试\"><a href=\"#第二次面试\" class=\"headerlink\" title=\"第二次面试\"></a>第二次面试</h3><p>&ensp;&ensp;第二次面试倒是没有什么技术相关的问题，两个老师，一个人士，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：</p>\n<ul>\n<li><p>个人介绍    </p>\n<ul>\n<li>基本信息</li>\n<li>求学经历</li>\n<li>……</li>\n</ul>\n</li>\n<li><p>工作经历</p>\n<ul>\n<li>项目经历</li>\n</ul>\n</li>\n<li><p>未来的规划</p>\n<ul>\n<li>职业规划</li>\n<li>个人规划</li>\n</ul>\n</li>\n<li><p>个人爱好</p>\n</li>\n</ul>\n<p>&ensp;…….</p>\n<p>&ensp;&ensp;后面部分就是关于这个介绍的提问了，无关痛痒。</p>\n<p>&ensp;&ensp;一周以后……，在我以为黄了的时候，竟然通过了。</p>\n<p>&ensp;&ensp;感谢！</p>\n"},{"title":"记一次面试","date":"2021-07-27T12:31:46.000Z","_content":"\n*和老大提出辞职之后，商量了关于我的工作后续的事情，便开始寻找新工作......*\n\t目的地是在重庆的一家公司，具体什么名字，暂时不透露了，面的`C++ & Qt`，按照面试官的说法，这是一个纯`Qt`的岗位，所以接下来的问题大概全部是和`Qt`相关的，当然也会有部分C++的问题在其中。\n\n<font style=\"color:pink\">废话不多说，我们进入正题：</font>\n\n## C++部分的问题：\n\n- 第一部分是关于C++这门语言的，面向对象是什么？\n\n  ```C++\n   // OOP\n   // 封装,继承,多态\n  ```\n\n- 对于多态的理解?\n\n  ```C++ \n  // 首先是如何实现多态？\n  1. 多态发生在继承关系中。\n  2. 需要重写虚函数。\n  3. 父类的指针指向子类的对象。\n  4. 通过父类指针对重写的虚函数发起调用，最终调用你要想调用的函数。\n  ```\nexample：\n  ```C++\nclass A\n  {\n  public:\n      A(){std::cout<<\"A\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_A\"<<std::endl;\n      }\n  private:\n      int menber;\n  \n  };\n  \n  class B: public A\n  {\n  public:\n      B():A(){std::cout<<\"B\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_B\"<<std::endl;\n      }\n  };\n  \n  class D: public A\n  {\n  public:\n      D():A(){std::cout<<\"D\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_D\"<<std::endl;\n      }\n  };\n  \n  int main()\n  {\n      A * a = new A;\n      B * b = new B;\n      D * d = new D;\n  \n      A * ptr = b;\n      ptr->function_virtual();\n  \n      ptr = a;\n      ptr->function_virtual();\n  \n      ptr = d;\n      ptr->function_virtual();\n  \t\n      return 0;\n  }\n  \n  ```\n\t<font style=\"color:red\">结果如下：</font>\n\t![polymorphism](https://raw.githubusercontent.com/CuntBoy/images/main/polymorphism.png \"polymorphism\")\n\n\n- 多态的实现 -- <font style=\"color:red\">虚函数表</font>\n\n  - 验证虚函数表：\n\n    ```C++\n    // 一个简单的C 不带有虚函数 \n    class C\n    {\n    public:\n        C(){std::cout<<\"C\"<<std::endl;}\n    private:\n        long long member;\n    };\n    ```\n\t<font style=\"color:red\">输出结果:</font> ![virtual_table](https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_1.png \"virtual table 1\")\n  \t\n  \t![virtual table 2](https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_2.png \"virtual table 2\")\n  \t\n  \t- 上面的结果可以看出存在一个成员(存在虚函数的情况)，大小为8个字节(64位软件)。\n\n---\n\n## Qt部分\n\n- 元对象系统\n- 窗口刷新机制\n- 内存托管(删除机制)\n- Qquick\n- Qt的布局\n\n\n\n## OPENGL部分\n\n- 缓冲(双缓冲)\n\n- 着色器程序(语言)\n\n  ","source":"_posts/记一次面试.md","raw":"---\ntitle: 记一次面试\ndate: 2021-07-27 20:31:46\ntags:\n---\n\n*和老大提出辞职之后，商量了关于我的工作后续的事情，便开始寻找新工作......*\n\t目的地是在重庆的一家公司，具体什么名字，暂时不透露了，面的`C++ & Qt`，按照面试官的说法，这是一个纯`Qt`的岗位，所以接下来的问题大概全部是和`Qt`相关的，当然也会有部分C++的问题在其中。\n\n<font style=\"color:pink\">废话不多说，我们进入正题：</font>\n\n## C++部分的问题：\n\n- 第一部分是关于C++这门语言的，面向对象是什么？\n\n  ```C++\n   // OOP\n   // 封装,继承,多态\n  ```\n\n- 对于多态的理解?\n\n  ```C++ \n  // 首先是如何实现多态？\n  1. 多态发生在继承关系中。\n  2. 需要重写虚函数。\n  3. 父类的指针指向子类的对象。\n  4. 通过父类指针对重写的虚函数发起调用，最终调用你要想调用的函数。\n  ```\nexample：\n  ```C++\nclass A\n  {\n  public:\n      A(){std::cout<<\"A\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_A\"<<std::endl;\n      }\n  private:\n      int menber;\n  \n  };\n  \n  class B: public A\n  {\n  public:\n      B():A(){std::cout<<\"B\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_B\"<<std::endl;\n      }\n  };\n  \n  class D: public A\n  {\n  public:\n      D():A(){std::cout<<\"D\"<<std::endl;}\n  \n      virtual void function_virtual()\n      {\n          std::cout<<\"function_D\"<<std::endl;\n      }\n  };\n  \n  int main()\n  {\n      A * a = new A;\n      B * b = new B;\n      D * d = new D;\n  \n      A * ptr = b;\n      ptr->function_virtual();\n  \n      ptr = a;\n      ptr->function_virtual();\n  \n      ptr = d;\n      ptr->function_virtual();\n  \t\n      return 0;\n  }\n  \n  ```\n\t<font style=\"color:red\">结果如下：</font>\n\t![polymorphism](https://raw.githubusercontent.com/CuntBoy/images/main/polymorphism.png \"polymorphism\")\n\n\n- 多态的实现 -- <font style=\"color:red\">虚函数表</font>\n\n  - 验证虚函数表：\n\n    ```C++\n    // 一个简单的C 不带有虚函数 \n    class C\n    {\n    public:\n        C(){std::cout<<\"C\"<<std::endl;}\n    private:\n        long long member;\n    };\n    ```\n\t<font style=\"color:red\">输出结果:</font> ![virtual_table](https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_1.png \"virtual table 1\")\n  \t\n  \t![virtual table 2](https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_2.png \"virtual table 2\")\n  \t\n  \t- 上面的结果可以看出存在一个成员(存在虚函数的情况)，大小为8个字节(64位软件)。\n\n---\n\n## Qt部分\n\n- 元对象系统\n- 窗口刷新机制\n- 内存托管(删除机制)\n- Qquick\n- Qt的布局\n\n\n\n## OPENGL部分\n\n- 缓冲(双缓冲)\n\n- 着色器程序(语言)\n\n  ","slug":"记一次面试","published":1,"updated":"2022-07-26T00:48:36.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vcm0020ucuu1umsc5oz","content":"<p><em>和老大提出辞职之后，商量了关于我的工作后续的事情，便开始寻找新工作……</em><br>    目的地是在重庆的一家公司，具体什么名字，暂时不透露了，面的<code>C++ &amp; Qt</code>，按照面试官的说法，这是一个纯<code>Qt</code>的岗位，所以接下来的问题大概全部是和<code>Qt</code>相关的，当然也会有部分C++的问题在其中。</p>\n<p><font style=\"color:pink\">废话不多说，我们进入正题：</font></p>\n<h2 id=\"C-部分的问题：\"><a href=\"#C-部分的问题：\" class=\"headerlink\" title=\"C++部分的问题：\"></a>C++部分的问题：</h2><ul>\n<li><p>第一部分是关于C++这门语言的，面向对象是什么？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OOP</span></span><br><span class=\"line\"><span class=\"comment\">// 封装,继承,多态</span></span><br></pre></td></tr></table></figure></li>\n<li><p>对于多态的理解?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先是如何实现多态？</span></span><br><span class=\"line\"><span class=\"number\">1.</span> 多态发生在继承关系中。</span><br><span class=\"line\"><span class=\"number\">2.</span> 需要重写虚函数。</span><br><span class=\"line\"><span class=\"number\">3.</span> 父类的指针指向子类的对象。</span><br><span class=\"line\"><span class=\"number\">4.</span> 通过父类指针对重写的虚函数发起调用，最终调用你要想调用的函数。</span><br></pre></td></tr></table></figure>\n<p>example：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;A&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_A&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> menber;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      B():A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;B&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_B&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      D():A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;D&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_D&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">      A * a = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">      B * b = <span class=\"keyword\">new</span> B;</span><br><span class=\"line\">      D * d = <span class=\"keyword\">new</span> D;</span><br><span class=\"line\">  </span><br><span class=\"line\">      A * ptr = b;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  </span><br><span class=\"line\">      ptr = a;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  </span><br><span class=\"line\">      ptr = d;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  \t</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n<p>  <font style=\"color:red\">结果如下：</font><br>  <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/polymorphism.png\" alt=\"polymorphism\" title=\"polymorphism\"></p>\n</li>\n</ul>\n<ul>\n<li><p>多态的实现 – <font style=\"color:red\">虚函数表</font></p>\n<ul>\n<li><p>验证虚函数表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个简单的C 不带有虚函数 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    C()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;C&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> member;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><font style=\"color:red\">输出结果:</font> <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_1.png\" alt=\"virtual_table\" title=\"virtual table 1\"></p>\n<p>  <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_2.png\" alt=\"virtual table 2\" title=\"virtual table 2\"></p>\n<ul>\n<li>上面的结果可以看出存在一个成员(存在虚函数的情况)，大小为8个字节(64位软件)。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Qt部分\"><a href=\"#Qt部分\" class=\"headerlink\" title=\"Qt部分\"></a>Qt部分</h2><ul>\n<li>元对象系统</li>\n<li>窗口刷新机制</li>\n<li>内存托管(删除机制)</li>\n<li>Qquick</li>\n<li>Qt的布局</li>\n</ul>\n<h2 id=\"OPENGL部分\"><a href=\"#OPENGL部分\" class=\"headerlink\" title=\"OPENGL部分\"></a>OPENGL部分</h2><ul>\n<li><p>缓冲(双缓冲)</p>\n</li>\n<li><p>着色器程序(语言)</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><em>和老大提出辞职之后，商量了关于我的工作后续的事情，便开始寻找新工作……</em><br>    目的地是在重庆的一家公司，具体什么名字，暂时不透露了，面的<code>C++ &amp; Qt</code>，按照面试官的说法，这是一个纯<code>Qt</code>的岗位，所以接下来的问题大概全部是和<code>Qt</code>相关的，当然也会有部分C++的问题在其中。</p>\n<p><font style=\"color:pink\">废话不多说，我们进入正题：</font></p>\n<h2 id=\"C-部分的问题：\"><a href=\"#C-部分的问题：\" class=\"headerlink\" title=\"C++部分的问题：\"></a>C++部分的问题：</h2><ul>\n<li><p>第一部分是关于C++这门语言的，面向对象是什么？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OOP</span></span><br><span class=\"line\"><span class=\"comment\">// 封装,继承,多态</span></span><br></pre></td></tr></table></figure></li>\n<li><p>对于多态的理解?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先是如何实现多态？</span></span><br><span class=\"line\"><span class=\"number\">1.</span> 多态发生在继承关系中。</span><br><span class=\"line\"><span class=\"number\">2.</span> 需要重写虚函数。</span><br><span class=\"line\"><span class=\"number\">3.</span> 父类的指针指向子类的对象。</span><br><span class=\"line\"><span class=\"number\">4.</span> 通过父类指针对重写的虚函数发起调用，最终调用你要想调用的函数。</span><br></pre></td></tr></table></figure>\n<p>example：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">  &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;A&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_A&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">      <span class=\"keyword\">int</span> menber;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      B():A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;B&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_B&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span>:</span> <span class=\"keyword\">public</span> A</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">      D():A()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;D&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">function_virtual</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">      </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;function_D&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">      A * a = <span class=\"keyword\">new</span> A;</span><br><span class=\"line\">      B * b = <span class=\"keyword\">new</span> B;</span><br><span class=\"line\">      D * d = <span class=\"keyword\">new</span> D;</span><br><span class=\"line\">  </span><br><span class=\"line\">      A * ptr = b;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  </span><br><span class=\"line\">      ptr = a;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  </span><br><span class=\"line\">      ptr = d;</span><br><span class=\"line\">      ptr-&gt;function_virtual();</span><br><span class=\"line\">  \t</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n<p>  <font style=\"color:red\">结果如下：</font><br>  <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/polymorphism.png\" alt=\"polymorphism\" title=\"polymorphism\"></p>\n</li>\n</ul>\n<ul>\n<li><p>多态的实现 – <font style=\"color:red\">虚函数表</font></p>\n<ul>\n<li><p>验证虚函数表：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一个简单的C 不带有虚函数 </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    C()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;C&quot;</span>&lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> member;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><font style=\"color:red\">输出结果:</font> <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_1.png\" alt=\"virtual_table\" title=\"virtual table 1\"></p>\n<p>  <img src=\"https://raw.githubusercontent.com/CuntBoy/images/main/virtual_table_2.png\" alt=\"virtual table 2\" title=\"virtual table 2\"></p>\n<ul>\n<li>上面的结果可以看出存在一个成员(存在虚函数的情况)，大小为8个字节(64位软件)。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Qt部分\"><a href=\"#Qt部分\" class=\"headerlink\" title=\"Qt部分\"></a>Qt部分</h2><ul>\n<li>元对象系统</li>\n<li>窗口刷新机制</li>\n<li>内存托管(删除机制)</li>\n<li>Qquick</li>\n<li>Qt的布局</li>\n</ul>\n<h2 id=\"OPENGL部分\"><a href=\"#OPENGL部分\" class=\"headerlink\" title=\"OPENGL部分\"></a>OPENGL部分</h2><ul>\n<li><p>缓冲(双缓冲)</p>\n</li>\n<li><p>着色器程序(语言)</p>\n</li>\n</ul>\n"},{"title":"迟到的毕业总结","date":"2021-03-18T15:59:55.000Z","_content":"\n <font color=red>2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！\n\n​\t离开前，大家都像是急于归乡的游子，对身后的这个城市不存半点留恋。\n\n对于大学，我仿佛有千言万语，却是欲语还休 。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！\n\n\n\n待续。。。\n\n---\n\n\n\n`2021-7-26`\n\n​\t下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。\n当然一切都会是新的，我也是。\n\n​\t祝愿我将迎接新的美好，朋友我来了！\n\n","source":"_posts/迟到的毕业总结.md","raw":"---\ntitle: 迟到的毕业总结\ndate: 2021-03-18 23:59:55\ncategories:\n- bun\n- university \ntags:\n - university \n - conclusion\n---\n\n <font color=red>2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！\n\n​\t离开前，大家都像是急于归乡的游子，对身后的这个城市不存半点留恋。\n\n对于大学，我仿佛有千言万语，却是欲语还休 。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！\n\n\n\n待续。。。\n\n---\n\n\n\n`2021-7-26`\n\n​\t下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。\n当然一切都会是新的，我也是。\n\n​\t祝愿我将迎接新的美好，朋友我来了！\n\n","slug":"迟到的毕业总结","published":1,"updated":"2022-07-26T00:48:36.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl61k3vcq0023ucuu83nvhfaa","content":"<p> <font color=\"red\">2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！</p>\n<p>​    离开前，大家都像是急于归乡的游子，对身后的这个城市不存半点留恋。</p>\n<p>对于大学，我仿佛有千言万语，却是欲语还休 。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！</p>\n<p>待续。。。</p>\n<hr>\n<p><code>2021-7-26</code></p>\n<p>​    下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。<br>当然一切都会是新的，我也是。</p>\n<p>​    祝愿我将迎接新的美好，朋友我来了！</p>\n","site":{"data":{}},"excerpt":"","more":"<p> <font color=\"red\">2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！</p>\n<p>​    离开前，大家都像是急于归乡的游子，对身后的这个城市不存半点留恋。</p>\n<p>对于大学，我仿佛有千言万语，却是欲语还休 。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！</p>\n<p>待续。。。</p>\n<hr>\n<p><code>2021-7-26</code></p>\n<p>​    下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。<br>当然一切都会是新的，我也是。</p>\n<p>​    祝愿我将迎接新的美好，朋友我来了！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl61k3vb80003ucuu6jl95adi","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vbt000kucuu7plxg1o5"},{"post_id":"cl61k3vbl000fucuu00shevux","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vbx000pucuu7au09p8s"},{"post_id":"cl61k3vbn000iucuu0k9i2qdz","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vby000sucuu1bkv5shp"},{"post_id":"cl61k3vbz000wucuu1ask77it","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vc60015ucuuh1256wd8"},{"post_id":"cl61k3vb40001ucuu8tu32tv6","category_id":"cl61k3vbb0004ucuug0ro3npz","_id":"cl61k3vc80019ucuu0d5yad0l"},{"post_id":"cl61k3vb40001ucuu8tu32tv6","category_id":"cl61k3vbz000tucuubpu487g8","_id":"cl61k3vc9001ducuu8o7tehek"},{"post_id":"cl61k3vc1000yucuu5boj73aw","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcb001hucuu6lw75olz"},{"post_id":"cl61k3vc20012ucuudle1c4mt","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcc001lucuue6up2xug"},{"post_id":"cl61k3vc50014ucuu322tb77u","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcf001oucuu953mcc5w"},{"post_id":"cl61k3vbi000aucuuek82h5j5","category_id":"cl61k3vc20010ucuu3hdkcpp8","_id":"cl61k3vch001tucuua3wk84qi"},{"post_id":"cl61k3vc70018ucuu8lyz8nqg","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcl001wucuu0nwz0z43"},{"post_id":"cl61k3vc9001cucuug8313eri","category_id":"cl61k3vbb0004ucuug0ro3npz","_id":"cl61k3vcn0021ucuu6l5cbf34"},{"post_id":"cl61k3vc9001cucuug8313eri","category_id":"cl61k3vbz000tucuubpu487g8","_id":"cl61k3vcs0024ucuu4s30gfq9"},{"post_id":"cl61k3vca001gucuu3hs992hp","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcv0028ucuu72035o22"},{"post_id":"cl61k3vcc001kucuu76l7cd3m","category_id":"cl61k3vbi000bucuu6kdu1jxx","_id":"cl61k3vcx002aucuu7aqv9r8j"},{"post_id":"cl61k3vbr000jucuu07436xgb","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd0002eucuu16wv6ol2"},{"post_id":"cl61k3vbr000jucuu07436xgb","category_id":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vd1002gucuuble57vbh"},{"post_id":"cl61k3vbk000eucuuc3fw7ko7","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd6002rucuu3mvv3zaw"},{"post_id":"cl61k3vbk000eucuuc3fw7ko7","category_id":"cl61k3vd1002hucuu9mhygn8y","_id":"cl61k3vd6002uucuu4sf8bznc"},{"post_id":"cl61k3vce001nucuu9yxya5vq","category_id":"cl61k3vd6002sucuueskd2f2a","_id":"cl61k3vd80032ucuug5yv5h7r"},{"post_id":"cl61k3vcg001sucuu5h99fxt4","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd80035ucuu11qqbnv1"},{"post_id":"cl61k3vcg001sucuu5h99fxt4","category_id":"cl61k3vct0025ucuu21zaam60","_id":"cl61k3vd90039ucuugag76uod"},{"post_id":"cl61k3vch001vucuu32kk9ixw","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vd9003bucuu0554hx5s"},{"post_id":"cl61k3vch001vucuu32kk9ixw","category_id":"cl61k3vd80031ucuu5kscakj9","_id":"cl61k3vda003fucuu6633cioa"},{"post_id":"cl61k3vbv000oucuugvmxe6us","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vdb003iucuu657qfowq"},{"post_id":"cl61k3vbv000oucuugvmxe6us","category_id":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vdb003mucuudwsvbe6r"},{"post_id":"cl61k3vbv000oucuugvmxe6us","category_id":"cl61k3vd80037ucuu9d4793ep","_id":"cl61k3vdc003oucuu65fqache"},{"post_id":"cl61k3vcq0023ucuu83nvhfaa","category_id":"cl61k3vbb0004ucuug0ro3npz","_id":"cl61k3vdc003sucuubg04ggs3"},{"post_id":"cl61k3vcq0023ucuu83nvhfaa","category_id":"cl61k3vda003eucuu7b0t1kh7","_id":"cl61k3vdd003uucuuffl8ek9m"},{"post_id":"cl61k3vbh0009ucuu4004fwr3","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vdd003wucuu4cgqay8i"},{"post_id":"cl61k3vbh0009ucuu4004fwr3","category_id":"cl61k3vct0025ucuu21zaam60","_id":"cl61k3vdd003yucuu0wvia0r3"},{"post_id":"cl61k3vbh0009ucuu4004fwr3","category_id":"cl61k3vdb003kucuu8tll2nn0","_id":"cl61k3vde0040ucuuho053ahg"},{"post_id":"cl61k3vbx000rucuugt2hgpuc","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vde0041ucuuh5phcxiq"},{"post_id":"cl61k3vbx000rucuugt2hgpuc","category_id":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vdf0042ucuufmno9ou6"},{"post_id":"cl61k3vbx000rucuugt2hgpuc","category_id":"cl61k3vd80037ucuu9d4793ep","_id":"cl61k3vdf0043ucuu97y81ocv"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","category_id":"cl61k3vbm000gucuuf4tae46d","_id":"cl61k3vdg0044ucuuetgr88tp"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","category_id":"cl61k3vcb001iucuueky83wri","_id":"cl61k3vdg0045ucuu0o4z9wir"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","category_id":"cl61k3vd4002nucuu9dbvf2ho","_id":"cl61k3vdh0046ucuu18q05mz2"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","category_id":"cl61k3vdd003vucuu3jljg0kh","_id":"cl61k3vdh0047ucuu31ds757b"}],"PostTag":[{"post_id":"cl61k3vb40001ucuu8tu32tv6","tag_id":"cl61k3vbd0005ucuu59ac9khc","_id":"cl61k3vbk000ducuu2qbn79lz"},{"post_id":"cl61k3vbn000iucuu0k9i2qdz","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vbt000nucuue5a5ezhy"},{"post_id":"cl61k3vbn000iucuu0k9i2qdz","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vbx000qucuu328zb049"},{"post_id":"cl61k3vb80003ucuu6jl95adi","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vbz000vucuudpgs6bj9"},{"post_id":"cl61k3vb80003ucuu6jl95adi","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vc1000xucuu63b13y6g"},{"post_id":"cl61k3vbz000wucuu1ask77it","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vc2000zucuu6gby8qar"},{"post_id":"cl61k3vbz000wucuu1ask77it","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vc50013ucuuh1k4ex5n"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vc60016ucuu74zu59bd"},{"post_id":"cl61k3vbe0007ucuu18ggeu0k","tag_id":"cl61k3vbz000uucuuazrmdk4r","_id":"cl61k3vc9001bucuu8af3ahoh"},{"post_id":"cl61k3vc1000yucuu5boj73aw","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vca001eucuu1axu1gf3"},{"post_id":"cl61k3vc1000yucuu5boj73aw","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vcc001jucuu29m2h004"},{"post_id":"cl61k3vc20012ucuudle1c4mt","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vce001mucuua4n54z2f"},{"post_id":"cl61k3vc20012ucuudle1c4mt","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vcg001rucuu1os66lm9"},{"post_id":"cl61k3vc50014ucuu322tb77u","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vch001uucuu6wrv82zj"},{"post_id":"cl61k3vc50014ucuu322tb77u","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vcm001zucuuaxku4zea"},{"post_id":"cl61k3vc70018ucuu8lyz8nqg","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vco0022ucuu9bou7d1y"},{"post_id":"cl61k3vc70018ucuu8lyz8nqg","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vcu0027ucuu5d722gwb"},{"post_id":"cl61k3vbh0009ucuu4004fwr3","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vcx0029ucuug1d7abi7"},{"post_id":"cl61k3vbh0009ucuu4004fwr3","tag_id":"cl61k3vbz000uucuuazrmdk4r","_id":"cl61k3vcz002ducuuf09yarr1"},{"post_id":"cl61k3vca001gucuu3hs992hp","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd1002fucuuhyls1hqh"},{"post_id":"cl61k3vca001gucuu3hs992hp","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vd2002jucuubf5t6406"},{"post_id":"cl61k3vcc001kucuu76l7cd3m","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd3002kucuuefo4ejpr"},{"post_id":"cl61k3vcc001kucuu76l7cd3m","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vd3002mucuu2rh4c87r"},{"post_id":"cl61k3vbi000aucuuek82h5j5","tag_id":"cl61k3vca001fucuu3spke6qd","_id":"cl61k3vd5002oucuu5wvp2ced"},{"post_id":"cl61k3vbi000aucuuek82h5j5","tag_id":"cl61k3vcf001pucuudkezfrjg","_id":"cl61k3vd6002qucuugvtf8qtx"},{"post_id":"cl61k3vbk000eucuuc3fw7ko7","tag_id":"cl61k3vcl001yucuugkrnheqa","_id":"cl61k3vd6002tucuu1bmwco75"},{"post_id":"cl61k3vbl000fucuu00shevux","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd6002vucuu362uebaw"},{"post_id":"cl61k3vbl000fucuu00shevux","tag_id":"cl61k3vbn000hucuubjqv8ff8","_id":"cl61k3vd7002yucuudi844sbs"},{"post_id":"cl61k3vbr000jucuu07436xgb","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd7002zucuu1rh7bwm5"},{"post_id":"cl61k3vbr000jucuu07436xgb","tag_id":"cl61k3vbz000uucuuazrmdk4r","_id":"cl61k3vd80033ucuu4jf0frzz"},{"post_id":"cl61k3vbv000oucuugvmxe6us","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd80034ucuudu2t53lp"},{"post_id":"cl61k3vbv000oucuugvmxe6us","tag_id":"cl61k3vbz000uucuuazrmdk4r","_id":"cl61k3vd90038ucuuftntg5gt"},{"post_id":"cl61k3vbx000rucuugt2hgpuc","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vd9003aucuu4cr4g9n2"},{"post_id":"cl61k3vbx000rucuugt2hgpuc","tag_id":"cl61k3vbz000uucuuazrmdk4r","_id":"cl61k3vda003ducuuhfqrfyt4"},{"post_id":"cl61k3vc9001cucuug8313eri","tag_id":"cl61k3vd6002pucuu7dr540p4","_id":"cl61k3vda003gucuud8o50kyy"},{"post_id":"cl61k3vce001nucuu9yxya5vq","tag_id":"cl61k3vd7002wucuu2s3g4v9b","_id":"cl61k3vda003hucuu7fjv1txu"},{"post_id":"cl61k3vcg001sucuu5h99fxt4","tag_id":"cl61k3vd70030ucuu66n6bsuj","_id":"cl61k3vdb003lucuu46ig9gye"},{"post_id":"cl61k3vch001vucuu32kk9ixw","tag_id":"cl61k3vd80036ucuu5rzw8dyq","_id":"cl61k3vdc003nucuu4r1ecids"},{"post_id":"cl61k3vch001vucuu32kk9ixw","tag_id":"cl61k3vbj000cucuugpzy9wce","_id":"cl61k3vdc003rucuugroq9l3f"},{"post_id":"cl61k3vch001vucuu32kk9ixw","tag_id":"cl61k3vd9003cucuu7x496g0i","_id":"cl61k3vdc003tucuuft2fcjyw"},{"post_id":"cl61k3vcq0023ucuu83nvhfaa","tag_id":"cl61k3vdb003jucuuf4hx78u8","_id":"cl61k3vdd003xucuufygtfeop"},{"post_id":"cl61k3vcq0023ucuu83nvhfaa","tag_id":"cl61k3vd70030ucuu66n6bsuj","_id":"cl61k3vdd003zucuubpt25xo8"}],"Tag":[{"name":"mylife","_id":"cl61k3vbd0005ucuu59ac9khc"},{"name":"cpp","_id":"cl61k3vbj000cucuugpzy9wce"},{"name":"sort","_id":"cl61k3vbn000hucuubjqv8ff8"},{"name":"osg","_id":"cl61k3vbz000uucuuazrmdk4r"},{"name":"Games202","_id":"cl61k3vca001fucuu3spke6qd"},{"name":"Shadow","_id":"cl61k3vcf001pucuudkezfrjg"},{"name":"Git","_id":"cl61k3vcl001yucuugkrnheqa"},{"name":"intraduce","_id":"cl61k3vd6002pucuu7dr540p4"},{"name":"windows","_id":"cl61k3vd7002wucuu2s3g4v9b"},{"name":"conclusion","_id":"cl61k3vd70030ucuu66n6bsuj"},{"name":"openGL","_id":"cl61k3vd80036ucuu5rzw8dyq"},{"name":"computer graphics","_id":"cl61k3vd9003cucuu7x496g0i"},{"name":"university","_id":"cl61k3vdb003jucuuf4hx78u8"}]}}