<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RanBun&#39;s Blog</title>
  
  <subtitle>如你所见,如我所见</subtitle>
  <link href="https://blog.ranbun.com/atom.xml" rel="self"/>
  
  <link href="https://blog.ranbun.com/"/>
  <updated>2022-09-16T13:02:02.307Z</updated>
  <id>https://blog.ranbun.com/</id>
  
  <author>
    <name>RanBun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AABB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/14/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/14/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-14T07:49:17.000Z</published>
    <updated>2022-09-16T13:02:02.307Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模型变换-模型矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/10/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/10/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-10T02:56:47.000Z</published>
    <updated>2022-09-16T13:02:02.313Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cmake 文件操作</title>
    <link href="https://blog.ranbun.com/2022/09/10/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ranbun.com/2022/09/10/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-09T17:36:07.000Z</published>
    <updated>2022-09-16T13:02:02.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cmake-文件操作"><code>cmake</code> 文件操作</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cmake-文件操作&quot;&gt;&lt;code&gt;cmake&lt;/code&gt; 文件操作&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="CMake" scheme="https://blog.ranbun.com/categories/CMake/"/>
    
    
    <category term="fileSystem" scheme="https://blog.ranbun.com/tags/fileSystem/"/>
    
  </entry>
  
  <entry>
    <title>透视矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/08/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/08/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-08T13:03:38.000Z</published>
    <updated>2022-09-23T01:25:41.619Z</updated>
    
    <content type="html"><![CDATA[<p>在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？<span id="more"></span></p><h2 id="投影变换">投影变换</h2><ul><li>平行投影</li><li>透视投影</li></ul><center><img id="projection" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/projection.png"/></center><ul><li>当我们完成视图变换<ul><li>相机被移动到世界坐标系的原点，同时场景做了同样的相对位移。</li><li>相机看向<code>-z</code>方向，我们指定了一个<code>up</code>,通过<code>cross</code>我们分别计算出三个轴向，相当远将世界坐标系做一个旋转操作，变换到<spanclass="math inline">\(\vec{right},\vec{up},\vec{look}\)</span> -相机右方向，上方向，观察方向，<font color=red>场景也要做相同的旋转操作</font></li><li>下一步的操作便是投影</li></ul></li><li>此时，我们的场景变换到了相机描述的坐标系下。</li></ul><h3 id="平行投影">1. 平行投影</h3><ul><li>我们最先要做的是定义一个视锥体。<ul><li><span class="math inline">\([left,right]\)</span></li><li><span class="math inline">\([bottom,top]\)</span></li><li><span class="math inline">\([zNear,ZFar]\)</span></li><li><spanclass="math inline">\(ortho(left,right,bottom,top,zNear,zFar)\)</span></li><li><font color=red>由于相机朝向<code>-z</code>,实际上说<code>zNear</code>大于<code>zFar</code></font>.</li></ul></li><li>如上图<a href="#projection">平行投影与透视投影</a>所示：平行投影没有近大远小的视觉效果，我们可以简单的丢掉所有顶点的<code>Z</code>值，将他们挤压到一个平面上，就可以得到一个平面的图。这将会丢掉维度信息，且不可逆，将场景变为二维，同是，对于关于<code>XOY</code>平面对称的点相当不友好[<code>-z,z</code>]，所以并不是一个合适的方法。<ul><li>变换矩阵: <span class="math display">\[  P_0 = \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></li></ul></li><li>更好的做法是将场景移动到原点，然后做一次缩放，将场景的所有的顶点的坐标变换到<spanclass="math inline">\((x,y,z) \in [-1,1]^3\)</span><ul><li>此时将会生成 <code>z-buffer</code>，三维场景的信息变为<spanclass="math inline">\([x,y]^2\)</span>的信息</li></ul></li></ul><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/Ortho.png"/></center><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/ortho_moveandscale.png"/></center><ul><li>对应矩阵<ul><li><p><code>T matrix</code> <span class="math display">\[  T =  \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\  0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\  0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>S matrix</code> <span class="math display">\[  S =  \begin{bmatrix}  \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\  0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\  0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>Ortho Matrix</code> <span class="math display">\[  Ortho =  S \times T =         \begin{bmatrix}      \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\      0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\      0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \times  \begin{bmatrix}      1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\      0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\      0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix} \\  = \begin{bmatrix}          \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp;-\frac{left+right}{2}\quad  \\          0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp;-\frac{top+bottom}{2}\quad  \\          0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp;-\frac{zNear+zFar}{2}\quad  \\          0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></p></li></ul></li></ul><h3 id="透视投影">2. 透视投影</h3><ul><li>透视投影变换的过程可以认为是将透视投影定义的视椎体挤压成一个长方体,然后运用平行投影相似的变换(<code>S + T</code>)<center><img id="projection2ortho" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection2ortho.png"/></center></li></ul><h4 id="挤压矩阵计算">2.1. 挤压矩阵计算</h4><p><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection_extrusion_computer.png" />- 如图<a href="#projection2ortho">projection2ortho</a>,从侧面上看: -<span class="math inline">\(\vec{g}\)</span> 指向<code>-Z</code>方向 -<span class="math inline">\(d\)</span> &amp; <spanclass="math inline">\(y_s\)</span>构成的三角形在<spanclass="math inline">\(e\)</span>的角度为<code>fov</code>的一半 -压缩是将<span class="math inline">\(y\)</span>压缩到<spanclass="math inline">\(y_s\)</span></p><h5 id="x_fary_far-to-x_neary_near">2.1.1 <spanclass="math inline">\([X_{far},Y_{far}]\)</span> to <spanclass="math inline">\([X_{near},Y_{near}]\)</span></h5><p><span class="math display">\[        \begin{pmatrix}        x \\        y \\        z \\        \end{pmatrix} *  \begin{bmatrix}        1 &amp; 0 &amp; 0 \\        0 &amp; n &amp; 0 \\        0 &amp; 0 &amp; 1 \\        \end{bmatrix}    = \begin{pmatrix}        x \\        y_s \\        z \\        \end{pmatrix}\]</span></p><ul><li>由三角形相似可以得到: <spanclass="math inline">\(\frac{y_s}{y}\quad\)</span>=$ $ =&gt; <spanclass="math inline">\(y_s = \frac{n}{f}\quad * y\)</span></li><li>同理: <span class="math inline">\(\frac{x_s}{x}\quad\)</span>=$ $=&gt; <span class="math inline">\(x_s = \frac{n}{f}\quad *x\)</span></li></ul><h5 id="挤压过程">2.1.2. 挤压过程</h5><ul><li>将一个点由透视投影的视椎体变换到正交下: <spanclass="math display">\[\begin{pmatrix}      x \\      y \\      z \\      1\end{pmatrix} =&gt; \begin{pmatrix}      \frac{n}{f}\quad*{x} \\      \frac{n}{f}\quad * y \\      {???} \\      1\end{pmatrix} =&gt; \begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}\]</span></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\        c_1 &amp; c_2 &amp; c_3 &amp; c_4  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><ul><li>考虑当被变换的这个点在近平面中心上: <spanclass="math display">\[\begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}=&gt;  \begin{pmatrix} \\      x \\      y \\      n \\      1  \end{pmatrix} = \begin{pmatrix}      n*x \\      n*y \\      n^2 \\      n\end{pmatrix}\]</span></li></ul><p><span class="math display">\[    Mat4^{(4\times4)}_{p-&gt;o}  * \begin{pmatrix}        x \\        y \\        n \\        1    \end{pmatrix} = \begin{pmatrix}        n*x \\        n*y \\        n^2 \\        n    \end{pmatrix}\]</span></p><p>得到: <span class="math inline">\(c_1 * x + c_2 * y + c_3 * n + c_4 *1 = n^2\)</span> <br> 得到: <span class="math inline">\(c_3 * n + c_4 =n^2\)</span></p><ul><li><p>同理考虑这个点落在远平面的中心: <br> 得到: <spanclass="math inline">\(c_3 * f + c_4 = f^2\)</span></p></li><li><p>解得:</p><ul><li><p><span class="math inline">\(c_3\)</span> <spanclass="math display">\[  c_3 = n + f \\  \]</span></p></li><li><p><span class="math inline">\(c_4\)</span> <spanclass="math display">\[  c_4 = -n * f  \]</span></p></li></ul></li><li><p><spanclass="math inline">\(Mat4^{(4\times4)}_{p-&gt;o}\)</span></p></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\            0 &amp; 0 &amp; n + f &amp; -n*f  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><h5 id="完整的透视变换矩阵">2.1.3. 完整的透视变换矩阵</h5><ul><li><span class="math inline">\(Mat^{(4\times4)}_{p-&gt;o} *Ortho^{4\times4}_{ortho}\)</span> <span class="math display">\[Mat^{4\times4}_{per} = \begin{bmatrix}              \frac{2*n}{right - left}\quad &amp; 0 &amp; \frac{right +left}{right - left}\quad &amp; -\frac{left+right}{2}\quad  \\              0 &amp; \frac{2*n}{top - bottom}\quad &amp; \frac{top +bottom}{bottom - top}\quad &amp; 0 \\              0 &amp; 0 &amp; \frac{zFar + zNear}{zNear - zFar}\quad&amp; -\frac{2*zFar*zNear}{zFar - zNear}\quad  \\              0 &amp; 0 &amp; 1 &amp; 0      \end{bmatrix}\]</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？
关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？</summary>
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="projection" scheme="https://blog.ranbun.com/tags/projection/"/>
    
  </entry>
  
  <entry>
    <title>OBB与Triangle求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:59.000Z</published>
    <updated>2022-09-16T13:02:02.311Z</updated>
    
    <content type="html"><![CDATA[<p><code>OBB</code> 与三角形求交.</p><h3 id="预备知识">预备知识</h3><h4 id="点到面的距离方程">点到面的距离方程</h4><h5 id="面的方程">面的方程</h5><ul><li>定义平面<code>A</code>的法向 <spanclass="math inline">\(\vec{n}\)</span> <code>&#123;a,b,c&#125;</code>,</li><li>已知平面行一点<span class="math inline">\(P_0 \lbracex_0,y_0,z_0\rbrace\)</span></li><li>任意点 <spanclass="math inline">\(P\)</span><code>&#123;x,y,z&#125;</code></li><li>面方程:<ul><li><span class="math inline">\(\overrightarrow{P - P_0} \cdot \vec{n} =0\)</span></li></ul></li></ul><h5 id="点到面的距离">点到面的距离</h5><h6 id="法向量法">法向量法</h6><ul><li><span class="math inline">\(\vec{n}\)</span> - 平面的法向量</li><li><span class="math inline">\(d\)</span> - 点到平面的距离</li><li><span class="math inline">\(P\)</span> - 平面外一点</li><li><span class="math inline">\(A\)</span> - 平面上一点</li><li>$d = $<ul><li>PA在法向方向上的投影既是点<spanclass="math inline">\(P\)</span>到平面的距离</li></ul></li></ul><h5 id="射线的方程">射线的方程</h5><ul><li>射线方程<ul><li><span class="math inline">\(O\)</span> 为起点， 沿着方向 <spanclass="math inline">\(\vec{d}\)</span></li><li>射线方向上任意一点<span class="math inline">\(P_0\)</span></li><li><span class="math inline">\(P_0 = O + \vec{d}\)</span></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;OBB&lt;/code&gt; 与三角形求交.&lt;/p&gt;
&lt;h3 id=&quot;预备知识&quot;&gt;预备知识&lt;/h3&gt;
&lt;h4 id=&quot;点到面的距离方程&quot;&gt;点到面的距离方程&lt;/h4&gt;
&lt;h5 id=&quot;面的方程&quot;&gt;面的方程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;定义平面&lt;code&gt;A&lt;/c</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>OBB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:42.000Z</published>
    <updated>2022-09-16T13:02:02.309Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OBB与OBB求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:28:20.000Z</published>
    <updated>2022-09-16T13:02:02.309Z</updated>
    
    <content type="html"><![CDATA[<p><code>OBB</code>与<code>OBB</code>的求交,此处我们将会介绍两个<code>OBB</code>的求交计算。以及一些基本概念......</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;OBB&lt;/code&gt;与&lt;code&gt;OBB&lt;/code&gt;的求交,此处我们将会介绍两个&lt;code&gt;OBB&lt;/code&gt;的求交计算。以及一些基本概念......&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>IBL</title>
    <link href="https://blog.ranbun.com/2022/09/08/IBL/"/>
    <id>https://blog.ranbun.com/2022/09/08/IBL/</id>
    <published>2022-09-07T17:07:45.000Z</published>
    <updated>2022-09-20T10:58:10.548Z</updated>
    
    <content type="html"><![CDATA[<p>基于图像的照明<code>Image Based Lighting</code> <span id="more"></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于图像的照明&lt;code&gt;Image Based Lighting&lt;/code&gt;</summary>
    
    
    
    <category term="rendering" scheme="https://blog.ranbun.com/categories/rendering/"/>
    
    
  </entry>
  
  <entry>
    <title>构造函数私有化</title>
    <link href="https://blog.ranbun.com/2022/08/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89%E5%8C%96/"/>
    <id>https://blog.ranbun.com/2022/08/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89%E5%8C%96/</id>
    <published>2022-08-29T07:28:04.000Z</published>
    <updated>2022-08-29T11:51:15.304Z</updated>
    
    <content type="html"><![CDATA[<p>在我使用<code>std::make_unique&lt;Typename T&gt;()</code>构建一个我自定义的类的时候，不小心将构造函数写成了私有的，出现了这个问题-<code>cannot access private member declared in class</code>，这完全是由于不仔细造成的...</p><span id="more"></span><h2 id="cannot-access-private-member-declared-in-class">cannot accessprivate member declared in class</h2><h3 id="可能的错误原因">可能的错误原因:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> / <span class="keyword">protected</span>: </span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我使用&lt;code&gt;std::make_unique&amp;lt;Typename T&amp;gt;()&lt;/code&gt;构建一个我自定义的类的时候，不小心将构造函数写成了私有的，出现了这个问题-&lt;code&gt;cannot access private member declared in class&lt;/code&gt;，这完全是由于不仔细造成的...&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:58.000Z</published>
    <updated>2022-09-16T13:02:02.315Z</updated>
    
    <content type="html"><![CDATA[<p>考虑某种场景，我们需要一个工具类，对于所有模块提供同样的接口与数据，但是如果每个模块使用这个类的功能的时候都创建一整个类，此种行为虽说是合法的，但并不是最好的选择，我们可以通过单例设计模式，将这个类变为一个单例，我们每一次创建这个类的实例的时候，都只是获取之前创建的，从而调用相应的功能。<span id="more"></span></p><h2 id="单例模式">单例模式</h2><ul><li>单线程版本</li><li>多线程版本</li><li>双检查锁</li><li><code>C++11</code>之后的版本</li><li><code>std::call_once</code></li></ul><h3 id="实现">实现</h3><ul><li>单线程版本<ul><li>此版本只是单线程安全</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sprivate:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程版本</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.release();</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程版本优化版 - 双检查锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">            &#123;</span><br><span class="line">                m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>C++11</code>版本</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>std::call_once</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(flag, []() &#123;m_instance.reset(<span class="keyword">new</span> Singleton()); &#125;);</span><br><span class="line">        <span class="keyword">return</span> *m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; Singleton::m_instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;考虑某种场景，我们需要一个工具类，对于所有模块提供同样的接口与数据，但是如果每个模块使用这个类的功能的时候都创建一整个类，此种行为虽说是合法的，但并不是最好的选择，我们可以通过单例设计模式，将这个类变为一个单例，我们每一次创建这个类的实例的时候，都只是获取之前创建的，从而调用相应的功能。</summary>
    
    
    
    <category term="Design Patterns" scheme="https://blog.ranbun.com/categories/Design-Patterns/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:44.000Z</published>
    <updated>2022-09-19T05:33:41.308Z</updated>
    
    <content type="html"><![CDATA[<p>什么是工厂模式？工厂顾名思义，就是创建产品。该模式封装和管理对象的创建，通俗地讲就是，你<code>new</code>一个对象的时候，直接调用工厂方法就行了。</p><span id="more"></span><h2 id="工厂模式">工厂模式</h2><ul><li>当我们需要不停的创建不同的对象的时候，我们可以通过封装接口，然后调用函数返回不同的类型的对象，这个时候我们就需要工厂模式帮我们处理此问题</li></ul><h3 id="简单工厂模式">1. 简单工厂模式</h3><ul><li>将类的初始化和创建全部交给一个工厂来完成，我们只需要告诉工厂我们需要什么即可。</li><li>专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</li><li>是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。</li></ul><h4 id="工厂factory">1. 工厂(<code>Factory</code>)</h4><ul><li>负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。</li><li>创建出产品(<code>Product</code>) -&gt;具体的产品(<code>ConcreteProduct</code>)</li></ul><h4 id="产品">2. 产品</h4><h5 id="抽象产品">抽象产品</h5><ul><li>象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其派生对象。</li></ul><h5 id="具体产品">具体产品</h5><ul><li>具体产品是简单工厂模式的创建目标。每个具体产品都继承了抽象产品，需要实现定义在抽象产品中的方法。</li></ul><h4 id="使用">3. 使用</h4><ul><li>当我们需要创建的对象数量较多且杂的时候，我们需要使用简单工厂模式来创建对象。</li><li>对象的创建过程是我们不需要去关心，我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，方便后期的程序扩展和维护。</li></ul><h4 id="code">4. <code>Code</code></h4><ul><li>Product</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">product_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    none,</span><br><span class="line">    one,</span><br><span class="line">    two</span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Product() = <span class="keyword">default</span>;</span><br><span class="line">    ~Product() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">final</span> :</span><span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductA() = <span class="keyword">default</span>;</span><br><span class="line">    ~ProductA() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">final</span> :</span><span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductB() = <span class="keyword">default</span>;</span><br><span class="line">    ~ProductB() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Factoy.h</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">Factoy.h</span><br><span class="line">---</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Factory() = <span class="keyword">default</span>;</span><br><span class="line">    ~Factory() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  Product* <span class="title">crteateProduct</span><span class="params">(product_type &amp; type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::one)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span>  ProductA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::two)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">crteateProduct</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>main</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> Factory;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;crteateProduct(product_type::none);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式">2. 工厂方法模式</h3><h4 id="简介">2.1 简介</h4><ul><li>简单工厂模式中最大的缺点就是当我们需要创建新的产品的时候，我们需要修改工厂的<code>create</code>方法，加入必要的处理逻辑，违背了设计原则-<code>开闭原则</code></li><li>工厂方法模式中，工厂父类只是定义创建产品的接口，子类负责创建具体的产品，将具体产品的创建都延迟到子类中实现，通过子类创建具体的实例化对象。</li></ul><h4 id="实现">实现</h4><ul><li><code>concreteFactory.h</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FactoryA() = <span class="keyword">default</span>;</span><br><span class="line">    ~FactoryA() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Product* <span class="title">crteateProduct</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>main.cpp</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;concreteFactory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> FactoryA;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;crteateProduct();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式">3. 抽象工厂模式</h3><ul><li>一个特殊的工厂模式</li><li>创建一个产品族</li><li>待续</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是工厂模式？
工厂顾名思义，就是创建产品。该模式封装和管理对象的创建，通俗地讲就是，你&lt;code&gt;new&lt;/code&gt;一个对象的时候，直接调用工厂方法就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="Design Patterns" scheme="https://blog.ranbun.com/categories/Design-Patterns/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>多重继承下的菱形继承</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</id>
    <published>2022-08-19T12:58:37.000Z</published>
    <updated>2022-08-29T13:03:21.923Z</updated>
    
    <content type="html"><![CDATA[<p><code>cpp</code>, 中关于继承的一点问题...</p><span id="more"></span><h2 id="单继承">单继承</h2><ul><li>只有一父类的时候，称之为单继承</li></ul><h2 id="多继承">多继承</h2><ul><li>一个子类有两个及以上的父类，这个时候，称之为多继承</li></ul><h3 id="菱形继承">菱形继承</h3><ul><li>多继承下面的特殊状态, 会产生一些问题。<ul><li>当一个类的父类们同时拥有相同的父类的时候，就会发生二义性 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/diamond_inheritance.PNG"title="菱形继承" alt="菱形继承" /></li></ul></li></ul><h4 id="问题">问题</h4><h5 id="二义性">1 二义性</h5><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/cpp/inherit_ambiguos.png"title="二义性问题" alt="二义性" /><figcaption aria-hidden="true">二义性</figcaption></figure><ul><li><p>解决访问的二义性相对简单，可以通过添加类的限定从而访问到具体的数据</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span> :</span><span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Author()</span><br><span class="line">    &#123;</span><br><span class="line">        Student::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Teacher::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li></ul><h5 id="数据冗余">2 数据冗余</h5><ul><li>从上面的图来看,菱形继承的数据发生了冗余，以及带来数据访问时候的二义性<ul><li>在<code>Author</code>中存在两份<code>Person</code>的数据</li></ul></li><li>数据冗余的问题在<code>CPP</code>中通过使用虚继承解决</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name,<span class="built_in">std</span>::<span class="built_in">string</span> ID = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        :name_(name)</span><br><span class="line">        ,id_(ID)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_&#123;<span class="string">&quot;name&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> birthDay_&#123;<span class="string">&quot;2000.1.1&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id_&#123;<span class="string">&quot;XXXXXXXXXXXXXXXXXX&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> name_)</span><br><span class="line">        :Person(<span class="string">&quot;stu&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Student() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> stuId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name_)</span><br><span class="line">        :Person(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Teacher() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> teacherId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚继承的实现原理">虚继承的实现原理</h2><ul><li><p><code>virtual base table pointer</code></p></li><li><p><code>virtual table</code></p></li><li><p>我们基于上面部分分析关于虚继承的实现的原理</p><ul><li><code>VS</code>的<code>class</code>布局查看工具 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/cpp/vs_Layout_to_class.png" /></li><li>上述信息包含:虚函数表及布局，类的大小，类成员占用大小，成员相较于起始地址的偏移量，字节对其信息</li></ul></li><li><p>上述布局中我们可以看到,当虚继承发生,就会在虚基类的直接子类中产生一个<code>vbptr</code>指针,这个指针指向一个虚基类表,<code>Author</code>继承自<code>Teacher&amp;Student</code>,同样继承了虚基类指针,同时<code>Author</code>只存在一份<code>Person</code>的数据.</p></li><li><p>我们通过虚基类表中记录的偏移(虚基类到当前类),就可以访问到虚基类的数据成员.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;cpp&lt;/code&gt;, 中关于继承的一点问题...&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/categories/cpp/"/>
    
    
    <category term="inherit" scheme="https://blog.ranbun.com/tags/inherit/"/>
    
  </entry>
  
  <entry>
    <title>View/Camera Transformation</title>
    <link href="https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/"/>
    <id>https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/</id>
    <published>2022-08-19T12:39:56.000Z</published>
    <updated>2022-08-22T10:49:49.206Z</updated>
    
    <content type="html"><![CDATA[<p>  计算机图形学的视图变换过程的解析...</p><span id="more"></span><h1 id="视图变换">视图变换</h1><ul><li>视图变换是将所有世界空间中的点，变换到视图空间下的操作<ul><li>这种变换，我们通过矩阵可以轻易的完成，但是我们首先需要计算一个描述这种变换的矩阵</li></ul></li><li>在一般的实现中，我们将视图变换的过程抽象出了一个相机的概念<ul><li>本身而言在图形学中是没有相机这个概念的</li></ul></li></ul><h2 id="视图变换-变换过程">视图变换-变换过程</h2><ul><li>从顶点构建到最终渲染成一张二维的图片，在行业中大家将之类比为拍照的行为<ul><li>模型变换 - 取景的过程</li><li><font color=red>视图变换 - 摆放相机的过程</font></li><li>......</li><li>此处我们只是讨论视图变换的过程</li></ul></li></ul><h3 id="定义一个相机">定义一个相机</h3><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/define_cameracamera.png"title="define camera" alt="camera" /><figcaption aria-hidden="true">camera</figcaption></figure><ul><li>对于上述的那个拍照的行为，我们要拍摄这个摆放好的景物，关于相机我们只需要关心三个方面。<ul><li>我们基于<font color=red>右手系</font>考虑下面的这些信息</li><li>相机的位置 <span class="math inline">\(e\)</span> -&gt; <spanclass="math inline">\(eye\)</span> = $x,y,z,1$</li><li>相机的看的方向，既相机的拍摄方向 <spanclass="math inline">\(\vec{dir}\)</span> - <code>lookAt direction</code>$x,y,z,0 $</li><li>相机的上方向 <span class="math inline">\(\vec{up}\)</span> = <spanclass="math inline">\(\lbrace x,y,z,1\rbrace\)</span><ul><li>大概是手机横屏与竖屏的区别</li></ul></li></ul></li><li>我们获得一个观察方向,一个向上的方向<ul><li>观察方向与向上方向垂直</li><li>通过叉积我们可以得到一个向右的方向<spanclass="math inline">\(\vec{right}\)</span></li></ul></li></ul><p style="color:red">  从拍照的行为来看，相机的观察方向是指向模型摆放的位置，我们保持两个物体的相对位置关系(相机与场景)，相机做了某种变换，模型也跟着做同样的变换。基于这种相对位置的变化，我们约定，将相机永远变换到原点，相机的观察方向永远是<code> -z </code>方向,以此我们构建一个坐标系</p><p><img id="view_coordinate" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/camera构建坐标系.png"/></p><h2 id="计算视图变换矩阵">计算视图变换矩阵</h2><p><img id="旋转矩阵构建" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/旋转矩阵的构建.png"/></p><ul><li>我们将以相机定义的坐标框架通过旋转与平移将之与世界空间的坐标重合<ul><li><span class="math inline">\(\vec{g}\)</span> -&gt; $ $</li><li><span class="math inline">\(\vec{t}\)</span> -&gt; $ $</li><li><span class="math inline">\(\vec{t} \times \vec{g}\)</span> -&gt;<span class="math inline">\({\vec{X}}\)</span></li><li><font color=red>但是我们要做到上面的事情比较困难，换一种思路，我们做相反的事情</font></li></ul></li><li>我们将世界空间的坐标通过旋转&amp;平移将之与相机定义的坐标系重合<ul><li><span class="math inline">\(\vec{Y}\)</span> -&gt; <spanclass="math inline">\(\vec{t}\)</span></li><li><span class="math inline">\(\vec{-Z}\)</span> -&gt; <spanclass="math inline">\(\vec{g}\)</span></li><li><span class="math inline">\({\vec{X}}\)</span> -&gt; <spanclass="math inline">\(\vec{t} \times \vec{g}\)</span></li></ul></li><li>构建一个旋转矩阵的逆矩阵，然后计算逆矩阵的逆便得到我们想要的矩阵。<ul><li>由于坐标系的三个轴是正交的，我们只需要将矩阵转置就可以得到这个旋转矩阵。</li></ul></li><li>将旋转矩阵与平移矩阵乘起来，就得到想要的试图变换矩阵</li></ul><p><img src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/旋转矩阵计算.jpg"/></p><p style="color:pink"><p>   上述过程描述了视图变换的过程与视图矩阵的计算。</p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  计算机图形学的视图变换过程的解析...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    
    <category term="Base" scheme="https://blog.ranbun.com/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>起伏的2022(上)</title>
    <link href="https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-14T09:22:51.000Z</published>
    <updated>2022-08-21T05:28:31.663Z</updated>
    
    <content type="html"><![CDATA[<center><h1>关于我的2022(上)</h1></center><p>  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......</p><span id="more"></span><h2 id="上一览">2022上，一览</h2><ul><li>辞掉了原来的工作<ul><li>离开了北京</li><li>又去见了一些人</li></ul></li><li>来了成都</li><li>给自己翻篇</li><li>遇到了她<ul><li>准备一起写我们的故事</li></ul></li></ul><h3 id="离开我不喜欢的北京">离开我不喜欢的北京</h3><h4 id="辞职那点事">辞职那点事</h4><p>  其实之前也算是成都的一家公司，只是有些草率，我的入职合同是通过快递签订的。除了和我一起出差的同事，我并未见过任何一个公司的同事。我以为我的入职之后会是在成都度过，但是事实总是不能遂了人意，我在一直呆在北京，算是出差中，可能是呆的时间有点太长了，我决定要离开了。于是在去年年底的最后一个月开始重新找工作了，依旧是在成都，重新觅一份新的工作，阴差阳错，来了现在的公司，年前的2月，我们结束我们的年假，决定前往北京进行工作最后的工作交接。我深知那一次的离开，我可能再也不会再来北京，离开前总是需要见一些该见的人，就当作是最后的告别。</p><h4 id="往后不能再见的朋友">往后不能再见的朋友</h4><p>  记得大一的第一学期的前半程是稍微有些无聊的，我去往那个和我期待中的样子差距颇大的地方，我在颓废中度过了大一第一学期的前半程，可能是接受了现实，我决定改变一下这个现状，于是迈出了我成为程序员得第一步，我找了个学生组织，参与进去。可能是缘分，我遇到好些个有意思的人，在这之中有我的好朋友，也有带我入行的学长，毕业后，学长去了北京。虽然在我本来的计划中，我大概会去北京的，但事情总是不得遂人意，阴差阳错，我没能去了。借此机会，见了这位阔别已久的老朋友，一起聊到凌晨，大家总有各自的生活，所以分别，多少没那么不舍。我相信缘分会拉着我们一次又一次的相遇。</p><p>  那位没能和我们一起拍毕业照的小伙伴，也将见证我的离去，我们是大学同学，男孩子性格的她，和我们最是合得来，一起吃了个饭，记得是我此前没有尝试过的港式，没有什么不舍，惟愿。</p><h3 id="终来成都">终来成都</h3><h4 id="新工作">新工作</h4><ul><li>还是那个工作，只是换了环境和一波同事，对我来说,差别不大。来时是三月中旬，成都总是那么出人意料，我来时给予我最大的温暖，$28^o $的天气，只有感谢，未能有更多言语。</li><li>来后三个月的感叹，<code>我好菜呀！！！！！！！</code></li></ul><h3 id="给自己翻篇">给自己翻篇</h3><ul><li>经历变得丰富，成长颇多，感谢！</li><li>毕业两年！！！！！！！！！！！！！！！！！！！！！！！！！</li></ul><h3 id="遇到她">遇到她</h3><ul><li>如果我没有离开北京，如果我没有来这里，所以一切都是刚好的样子，感谢缘分让我们相遇。我们很合拍，无论什么。</li><li>所以想写新的故事，就我和她，在这个城市的故事。<ul><li>所以感谢会会的早餐与陪伴</li></ul></li></ul><h3 id="over">Over</h3><ul><li>2022的上半年到我们在一起结束，这是我2022年最开心的时候，感谢缘分，感谢相遇！</li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h1&gt;
关于我的2022(上)
&lt;/h1&gt;
&lt;/center&gt;
&lt;p&gt;
  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......
&lt;/p&gt;</summary>
    
    
    
    <category term="bun" scheme="https://blog.ranbun.com/categories/bun/"/>
    
    <category term="life" scheme="https://blog.ranbun.com/categories/bun/life/"/>
    
    
    <category term="mylife" scheme="https://blog.ranbun.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>Cplusplus key words - extern</title>
    <link href="https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/"/>
    <id>https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/</id>
    <published>2022-08-08T03:41:35.000Z</published>
    <updated>2022-08-21T05:57:37.929Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>cpp</code>关键词之<code>extern</code>...</p><span id="more"></span><center><h2><code>extern</code>关键字</h2></center><h2 id="extern-初解"><code>Extern</code> 初解</h2><ul><li>关于<code>extern</code>关键字可以应用于全局变量、函数或模板声明。它指定符号具有外部链接性质。<ul><li>在非const 全局变量声明中， extern指定变量或函数在另一个转换单元中定义。extern必须在定义变量的所有文件中应用该变量。</li><li>const在变量声明中，它指定变量具有 external 链接。extern必须应用于所有文件中的所有声明。 默认情况下， (全局 const变量具有内部链接。)</li><li>extern "C" 指定函数在别处定义并使用 C 语言调用约定。 extern"C"修饰符也可能应用于块中的多个函数声明。</li><li>在模板声明中， extern 指定模板已在其他位置实例化。 extern告知编译器它可以重复使用另一个实例化，而不是在当前位置创建新实例。有关此用法 extern的详细信息，请参阅 显式实例化。</li></ul></li></ul><h2 id="extern的使用"><code>Extern</code>的使用</h2><ul><li>小案例</li><li><code>extern var</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">头文件</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="comment">/// extern 变量与函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTERN_TEST_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">cpp 文件</span><br><span class="line">--- </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> extern_text_var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">使用导出变量</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printExternVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;current: &quot;</span> &lt;&lt; extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    extern_text_var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;do update: &quot;</span> &lt;&lt;extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">main.cpp</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printExternVar();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;add result: &quot;</span>&lt;&lt;add(<span class="number">10</span>, <span class="number">30</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">输出</span><br><span class="line">---</span><br><span class="line">current: <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span> update: <span class="number">200</span></span><br><span class="line">add result: <span class="number">40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;cpp&lt;/code&gt;关键词之&lt;code&gt;extern&lt;/code&gt;...
&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/categories/cpp/"/>
    
    
    <category term="key words" scheme="https://blog.ranbun.com/tags/key-words/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL parallel  projection graphics do not scale with the window</title>
    <link href="https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/"/>
    <id>https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/</id>
    <published>2022-08-04T02:05:58.000Z</published>
    <updated>2022-08-21T05:49:00.598Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>平行投影窗口缩放导致图形变形...</p><span id="more"></span><center><h2>OpenGL parallel projection graphics do not scale with the window</h2></center><h3 id="实现步骤">实现步骤</h3><ul><li>重写窗口的<code>resize</code>事件<ul><li>计算投影的范围</li></ul></li><li>更新投影矩阵</li><li><code>drawcull</code></li></ul><h4 id="resizegl"><code>resizeGL</code></h4><ul><li>我们最初计算一个比例：<ul><li>关于窗口的<code>size</code>和投影的范围的<ul><li>使用<code>left, right</code>计算一个<code>spanx(right - left)</code>,<code>top, bottom</code>计算<code>spany(top - bottom)</code>,分别与窗口的宽高比较 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ratioW = w / spanx;</span><br><span class="line"><span class="keyword">auto</span> ratioH = h / spany; </span><br><span class="line"><span class="comment">// 取最小的一个 </span></span><br><span class="line"><span class="keyword">auto</span> ratio = <span class="built_in">std</span>::min(ratioW,ratioH);</span><br></pre></td></tr></table></figure></li></ul></li><li>每次窗口缩放，我们就使用上述的范围计算新的<code>left,right,bottom,top</code><ul><li>只要投影的范围没有发生改变我们便不计算新的<code>ratio</code></li></ul></li></ul></li><li>计算新的<code>left,right,bottom,top</code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpenGLWidget::resizeGL</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line"></span><br><span class="line">    left = - w / ratio;</span><br><span class="line">    right = <span class="built_in">abs</span>(left);</span><br><span class="line">    bottom = -h / ratio;</span><br><span class="line">    top = <span class="built_in">abs</span>(bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新投影矩阵">更新投影矩阵</h4><ul><li>update<ul><li>关于<code>zNear &amp; zFar</code>投影当二维平面时候，并未使用这两个参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projMat.ortho(left,right,bottom,top,<span class="number">0.1f</span>,<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="更新绘制的场景">更新绘制的场景</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shaderProgram.bind(); </span><br><span class="line">shaderProgram-&gt;setUniformValue(<span class="string">&quot;projectionMatrix&quot;</span>, projMat); </span><br><span class="line">glDrawArray()</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;平行投影窗口缩放导致图形变形...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Move Scene</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/</id>
    <published>2022-08-03T13:05:59.000Z</published>
    <updated>2022-08-21T05:43:39.211Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>OpenGL</code>场景移动...</p><span id="more"></span><center><h1>OpenGL Move Scene - 平面上移动</h1></center><ul><li>我们考虑一个简单的平面的移动<ul><li>某个维度为 <code>0</code>,我们只需要在某个平面上移动</li></ul></li></ul><h2 id="计算移动的方向">1. 计算移动的方向</h2><ul><li>在此之前对于相机的概念，希望您是熟悉的</li><li>虽然在<code>OpenGL</code>中本身并没有相机的概念<ul><li><code>eye</code> - <code>point</code></li><li><code>center</code> - <code>point</code></li><li><code>up</code> - <code>vector</code></li></ul></li></ul><h3 id="计算相机的朝向">计算相机的朝向</h3><ul><li>右方向：<span class="math inline">\(\vec{front} = center -eye\)</span></li></ul><h3 id="计算相机的右方向">计算相机的右方向</h3><ul><li><span class="math inline">\(\vec{right} = \vec{front} \times\vec{up}\)</span></li><li>记得将向量<spanclass="math inline">\(\vec{right}\)</span>归一化处理</li></ul><h2 id="鼠标的移动">2. 鼠标的移动</h2><ul><li>规定使用鼠标右键平移场景</li><li>我们使用<code>Qt</code>的鼠标事件<ul><li>在<code>x</code>方向上，两次记录的位置相减携带了移动的方向</li><li>在<code>y</code>方向上，<code>Qt</code>窗口的原点与<code>OpenGL</code>的窗口存在差别，需要做额外的处理- 反向</li></ul></li></ul><h3 id="当右键按下我们记录当前的鼠标的坐标">1.当右键按下我们记录当前的鼠标的坐标</h3><h3 id="触发移动事件">2. 触发移动事件</h3><ul><li>此处每一次出发移动我们将计算一次场景的移动<ul><li><code>X</code>方向 - <code>offsetX</code></li><li><code>Y</code>方向 - <code>offsetY</code></li></ul></li><li>更新我们记录的上一次的鼠标的位置</li></ul><h2 id="移动场景">移动场景</h2><ul><li>将这个移动映射成为数据的比例，作为移动方向的系数，作用到<code>eye</code>&amp;<code>center</code>,重新计算视图矩阵，更新场景 ### 计算新的 <code>eye</code> &amp;<code>center</code></li><li>计算沿着<span class="math inline">\(\vec{right}\)</span> &amp; <spanclass="math inline">\(\vec{up}\)</span>方向的移动的距离</li><li>获取窗口的宽高为 <code>w&amp;h</code></li><li>在投影矩阵中 <span class="math inline">\(right - left =spanX\)</span> &amp; <span class="math inline">\(top - bottom =spanY\)</span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">offsetX / w * spanX = disX;</span><br><span class="line">offsetY / h * spanY = disY;</span><br><span class="line"></span><br><span class="line">eye += right * disX + up *  disY;</span><br><span class="line">center += right * disX + up *  disY;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新视图矩阵repaint">更新视图矩阵&amp;<code>repaint</code></h2><ul><li><code>ViewMat.lookAt(eye,center,up)</code></li><li><code>repaint()</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;OpenGL&lt;/code&gt;场景移动...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Scene ZoomIn &amp; ZoomOut</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/</id>
    <published>2022-08-03T13:01:52.000Z</published>
    <updated>2022-08-21T05:49:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>场景缩放...</p><span id="more"></span><!-- # `OpenGL Scene ZoomIn & ZoomOut` --><center><h1>OpenGL的缩放</h1></center><h2 id="about">About</h2><h3 id="直接缩放场景">1. 直接缩放场景</h3><h4 id="实现思路">1. 实现思路</h4><ul><li>通过模型矩阵修改场景</li></ul><h3 id="修改投影矩阵">2. 修改投影矩阵</h3><h4 id="实现思路-1">1. 实现思路</h4><ul><li>获取鼠标滚轮的变化(这个改变是带方向的向上获取一个正值,向下获取的是一个负值)</li><li>将获取的这个值映射到和投影变换参数上</li><li>修改投影矩阵</li><li>重新绘制,你将获得缩放后的场景</li></ul><p style="color:red">在我的实现中采用的是第二种方式</p><h2 id="缩放的实现">缩放的实现</h2><h3 id="获取滚轮旋转角度">1. 获取滚轮旋转角度</h3><p>我是用的是<code>Qt</code>的<code>OpenGL</code>,可以直接重写窗口的一些事件，比起使用<code>glfw</code>等方式，比起它们注册回调的方式可能相对方便一些。</p><h4 id="qt的滚轮事件">Qt的滚轮事件</h4><h5 id="qwheelevent"><code>QWheelEvent</code></h5><ul><li>在出发滚轮事件之后，我们通过一个<code>QWheelEvent</code>对象获取我们需要的关于滚轮的信息</li></ul><div><p>  Wheel events are sent to the widget under the mouse cursor, but ifthat widget does not handle the event they are sent to the focus widget.Wheel events are generated for both mouse wheels and trackpad scrollgestures. There are two ways to read the wheel event delta:<code>angleDelta()</code> returns the deltas in wheel degrees. Thesevalues are always provided. <code>pixelDelta()</code> returns the deltasin screen pixels.</p><p>  上述部分来自<code>Qt</code>官方文档,我们有两种方法可以获取鼠标滚轮的增量(正负代表方向)，<code>angleDelta()</code>，<code>pixelDelta()</code>.</p></div><h6><code>QPoint QWheelEvent::angleDelta() const</code></h6><p><p>  Returns the relative amount that the wheel was rotated, in eighthsof a degree. A positive value indicates that the wheel was rotatedforwards away from the user; a negative value indicates that the wheelwas rotated backwards toward the user. angleDelta().y() provides theangle through which the common vertical mouse wheel was rotated sincethe previous event. angleDelta().x() provides the angle through whichthe horizontal mouse wheel was rotated, if the mouse has a horizontalwheel; otherwise it stays at zero. Some mice allow the user to tilt thewheel to perform horizontal scrolling, and some touchpads support ahorizontal scrolling gesture; that will also appear inangleDelta().x().</p>  Most mouse types work in steps of 15 degrees, in which case the deltavalue is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.</p><ul><li>正值表示滚轮向上,远离用户. 负值向下,靠近用户.</li><li>此函数将返回两个方向上的滚动<ul><li><font color=red>我们此处使用是垂直方向的滚动的角度 </font></li></ul></li><li>滚轮每次触发滚动的的角度是<spanclass="math inline">\(15^\circ\left(delta\right)\)</span>，但是实际的返回值是$delta = 120 $</li><li>返回的值应以 $ 1/8 $ 为单位:<ul><li><span class="math inline">\(angleDelta() / 8\)</span>得到鼠标实际滚动的度数</li></ul></li><li><code style="color:red">通过上面步骤便可以获取滚轮实际旋转的角度</code></li></ul><h3 id="将滚轮旋转角度映射到投影矩阵">2.将滚轮旋转角度映射到投影矩阵</h3><ul><li><span class="math inline">\(ratio = delta/360^\circ\)</span></li><li>使用这个值去修改投影矩阵的参数</li><li>我们使用的是平行投影的方式<ul><li><code>left</code></li><li><code>rght</code></li><li><code>bottom</code></li><li><code>top</code></li></ul></li></ul><h3 id="更新投影矩阵">3. 更新投影矩阵</h3><ul><li>在此之前 请将矩阵设置为单位矩阵 然后重新计算投影矩阵</li><li>更新投影矩阵</li><li>调用强制重新绘制(<code>Qt</code>) - <code>repaint()</code></li><li>你将得到放大后的场景</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;场景缩放...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Qt OpenGL Antialiasing-MSAA</title>
    <link href="https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/"/>
    <id>https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/</id>
    <published>2022-08-02T09:16:16.000Z</published>
    <updated>2022-08-21T05:53:02.400Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>MSAA算法介绍...</p><span id="more"></span><h2 id="qt-opengl-antialiasing---msaa">Qt OpenGL Antialiasing -MSAA</h2><h3 id="锯齿是图形绘制中常见的问题">锯齿是图形绘制中常见的问题</h3><ul><li>这是一个采样不足然后信号丢失导致的问题</li><li>经过各位前辈们的其扑后继的研究，终究是有了看起来不错的解决方案</li><li>本文中我们采用一种名为<code>MSAA</code>的抗锯齿的技术</li></ul><h3 id="msaa"><code>MSAA</code></h3><p>  超级采样抗锯齿（Super SamplingAnti-Aliasing）的原理是把当前分辨率成倍提高,然后再把画缩放到当前的显示器上。这样的做法实际上就是在显示尺寸不变的情况提高分辨率，让单个像素变得极小，这样就能够大幅减轻画面的锯齿感了。不过是由于对整个显示画面的放大，因此它消耗的显示资源也是非常大的。</p><h3 id="qt-openggl-的-msaa"><code>Qt OpengGL</code> 的<code>MSAA</code></h3><h4 id="走样展示">走样展示</h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing.png"title="线的走样" alt="走样" /><figcaption aria-hidden="true">走样</figcaption></figure><h4id="开启qtopenglwidget的msaa">开启<code>QtOpenGLWidget</code>的<code>MSAA</code></h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing-MSAA.png"title="MSAA" alt="MSAA" /><figcaption aria-hidden="true">MSAA</figcaption></figure><h4id="如何开启qtopengl的msaa">如何开启<code>QtOpenGL</code>的<code>MSAA</code></h4><ul><li><p><code>Qt</code>有他自己的关于<code>OpenGL</code>的封装，我们使用的<code>Qt</code>的关于<code>OpenGL</code>封装</p></li><li><p>在创建<code>QOpenGLWidget</code>窗口时，在构造函数中添加如下代码：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSurfaceFormat format;</span><br><span class="line">format.setSamples(<span class="number">4</span>);</span><br><span class="line">setFormat(format);</span><br></pre></td></tr></table></figure></p><ul><li><code>setFormat</code>是窗口<code>QOpenGLWidget</code>的函数，在构造函数中使用，会给后面所有依赖的小部件设置一个默认的<code>format</code>，对于后面的小部件(窗口)，如果不做格式的修改，将会使用在构造函数中调用<code>setFormat</code>函数设置的格式作为默认格式</li></ul></li></ul><h4 id="失败的尝试">失败的尝试</h4><p>  我尝试，单独修改<code>QopenGLContext</code>的<code>QSurfaceFormat</code>,前面的部分是成功，我获取了当前窗口的<code>QopenGLContext</code>,修改了<code>QSurfaceFormat</code>，向其中添加了启用<code>MSAA</code>的代码.然后调用<code>QopenGLContext</code>的<code>create</code>函数，企图重新创建一个<code>QopenGLContext</code>，但是失败了，在初始化<code>QopenGLFunction</code>失败，<p style="color:red">暂时不知道原因,目测可能需要重新将当前窗口的绑定到重新创建后的上下文，以及调用这个上下文的<code>OpenGL</code>函数</p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;MSAA算法介绍...
&lt;/p&gt;</summary>
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/works/SCUU/"/>
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/works/SCUU/Computer-Graph/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
    <category term="Qt" scheme="https://blog.ranbun.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Smart pointer 简介</title>
    <link href="https://blog.ranbun.com/2022/08/01/Smartpointer/"/>
    <id>https://blog.ranbun.com/2022/08/01/Smartpointer/</id>
    <published>2022-08-01T11:53:40.000Z</published>
    <updated>2022-08-21T05:54:37.107Z</updated>
    
    <content type="html"><![CDATA[<p>  智能指针...</p><span id="more"></span><h1 id="smart-pointer">Smart Pointer</h1><p style="color:red">  智能指针是行为类似于指针的类对象，但这种对象还有其他功能。</p><ul><li>下面我将将会分别介绍几种不同的智能指针</li></ul><h3 id="auto_ptr"><code>auto_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++98</code>时被引入</li><li>已经在<code>C++11</code>是被弃用</li><li>在<code>C++17</code>被移除</li></ul><h4 id="特点">特点</h4><ul><li><code>auto_ptr</code>没有使用引用计数，在复制构造函数和赋值构造函数中将对象所有权转移</li><li><code>auto_ptr</code>不能指向数组，因为<code>auto_ptr</code>在析构的时候只是调用<code>delete</code>,而数组应该要调用<code>delete[]</code></li><li><code>auto_ptr</code> 不能和标准容器（vector,list,map…)一起使用<ul><li>由于<code>auto_ptr</code>在复制和赋值构造中将转移所有权</li></ul></li></ul><h3 id="unique_ptr"><code>unique_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++11</code>时被引入</li><li>用于解决<code>auto_ptr</code>的拷贝问题</li></ul><h4 id="特点-1">特点</h4><ul><li>不支持拷贝操作，只能进行所有权的转移</li><li><code>std::unique_ptr</code> 通常用于管理对象的生命周期，包括：通过保证正常退出和异常退出时的删除，为处理具有动态生命周期的对象的类和函数提供异常安全性</li><li>对于自定义的类对象，支持提供自定义的删除器</li><li>常用于单线程</li><li>可以为空</li></ul><h3 id="shared_ptr"><code>shared_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code>头文件中</li><li>在<code>C++11</code>时被引入</li><li>支持拷贝和复制</li></ul><h4 id="特点-2">特点</h4><ul><li>支持拷贝和复制</li><li>对于自定义的类对象，支持提供自定义的删除器</li><li>常用于多线程</li><li>多个对象可以共享所有权</li><li>可以为空</li></ul><h3 id="weak_ptr"><code>weak_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++11</code>时被引入</li><li>它是对 <code>std::shared_ptr</code>管理的对象的非拥有引用,必须将其转换为 <code>std::shared_ptr</code>才能访问引用的对象</li></ul><h4 id="特点-3">特点</h4><ul><li>解决<code>shared_ptr</code>引起的循环引用问题</li><li>获取某个<code>shared_ptr</code>指向对象的临时所有权，在<code>shared_ptr</code>对象被销毁是可以延长此对象的生命周期</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  智能指针...
&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://blog.ranbun.com/categories/study/"/>
    
    <category term="coding" scheme="https://blog.ranbun.com/categories/study/coding/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="pointer" scheme="https://blog.ranbun.com/tags/pointer/"/>
    
  </entry>
  
</feed>
