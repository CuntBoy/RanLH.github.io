<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RanBun&#39;s Blog</title>
  
  <subtitle>如你所见,如我所见</subtitle>
  <link href="https://blog.ranbun.com/atom.xml" rel="self"/>
  
  <link href="https://blog.ranbun.com/"/>
  <updated>2022-10-25T15:19:53.754Z</updated>
  <id>https://blog.ranbun.com/</id>
  
  <author>
    <name>RanBun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>射线与平面相交</title>
    <link href="https://blog.ranbun.com/2022/10/25/%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/10/25/%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%AE%A1%E7%AE%97/</id>
    <published>2022-10-25T15:19:53.000Z</published>
    <updated>2022-10-25T15:19:53.754Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AABB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/14/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/14/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-14T07:49:17.000Z</published>
    <updated>2022-10-23T14:41:58.934Z</updated>
    
    <content type="html"><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。<span id="more"></span></p><h2 id="aabb与ray求交">AABB与Ray求交</h2><ul><li>在之前的部分我们说到了关于<code>OBB</code>与<code>Ray</code>求交的计算<a href="./../../08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/">jump</a>,AABB算是比较特殊的<code>OBB</code>,计算<code>OBB</code>与<code>Ray</code>的方法可能不在适用于<code>AABB</code>与射线的求交计算，当然从原理上来说,这依旧是<code>Slabs Method</code>。</li></ul><h3 id="计算">计算</h3><h4 id="前置判断">前置判断</h4><ul><li>考虑射线起点在盒子里面的情况</li><li>考虑射线和盒子某个面平行的时候</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"><span class="comment">// 计算是否平行</span></span><br><span class="line"><span class="keyword">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(u[i] &lt; del)  <span class="comment">// 近似为0  向量表示唯一 在这个方向上没有移动表示它和当前轴垂直</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时判断射线与盒子的关系</span></span><br><span class="line">        <span class="comment">// 在盒子内部必然相交</span></span><br><span class="line">        <span class="keyword">if</span>(begin[i] &lt; min[i] || begin[i] &gt; max[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4id="计算每个方向上对应的slab与射线的相交情况">计算每个方向上对应的<code>slab</code>与射线的相交情况</h4><ul><li><span class="math inline">\(P = P_0 + t \dots \vec{d}\)</span><ul><li><span class="math inline">\(\vec{d}\)</span> - 射线的方向</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> tMin = DBL_MIN,tMax = DBL_MAX;  <span class="comment">// 记录最后获取的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> dis = <span class="number">1.0</span> / u[i];</span><br><span class="line">    <span class="keyword">float</span> t_min;</span><br><span class="line">    <span class="keyword">float</span> t_max;</span><br><span class="line">    <span class="keyword">if</span>(dis &gt;= del)</span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (max[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (min[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (min[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (max[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t_max &lt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(t_max,t_min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        tMin = t_min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMax &lt; t_max)</span><br><span class="line">    &#123;</span><br><span class="line">        tMax = t_max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; tMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断">判断</h4><ul><li>返回结果</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="AABB" scheme="https://blog.ranbun.com/tags/AABB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>模型变换-模型矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/10/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/10/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-10T02:56:47.000Z</published>
    <updated>2022-10-01T15:35:32.871Z</updated>
    
    <content type="html"><![CDATA[<p>常规的仿射变换(旋转，缩放，平移),以及一些常用的基本矩阵和这些矩阵的原理<spanclass="math inline">\(\dots\)</span></p><span id="more"></span><h2 id="模型变换">模型变换</h2><ul><li>仿射变换<ul><li>基本概念：</li><li>矩阵的计算</li></ul></li><li>齐次坐标<ul><li>W分量的意义</li></ul></li><li>坐标系的变换<ul><li>模型坐标到世界坐标。</li></ul></li></ul><h3 id="齐次坐标">齐次坐标</h3><ul><li>在开始模型变换的讲解之前，我们首先需要知道，我们的变换的各种操作都是通过矩阵实现的，为了将旋转缩放平移写到一个矩阵中，在计算机图形学中引入了一个叫齐次坐标的东西，给向量<spanclass="math inline">\(\vec{a}_{3\times1}\)</span>扩充一个<code>w</code>维度，<spanclass="math inline">\(\vec{a}(x,y,z,w)\)</span>,关于向量我相信大家知道的不少，向量只表示方向与起点与终点没有关系。当然某些时候我们也用来描述一个空间的位置，所以当<code>w</code>分量为<code>0</code>表示的是向量，为<code>1</code>表示的是一个点，注意：<ul><li><span class="math inline">\(\vec{a}(x,y,z,w)\)</span><code>==</code> <span class="math inline">\(\vec{a}(w \times x,w \timesy,w \times z,w^2)\)</span></li></ul></li></ul><h3 id="平移">平移</h3><ul><li>建模师们在建模的时候都是使用模型自己的坐标，规定坐标系的原点在模型这个包围盒的内部，平移要做的操作就是将模型放到世界空间的某个位置。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常规的仿射变换(旋转，缩放，平移),
以及一些常用的基本矩阵和这些矩阵的原理&lt;span
class=&quot;math inline&quot;&gt;\(\dots\)&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="translate" scheme="https://blog.ranbun.com/tags/translate/"/>
    
  </entry>
  
  <entry>
    <title>cmake 文件操作</title>
    <link href="https://blog.ranbun.com/2022/09/10/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ranbun.com/2022/09/10/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-09T17:36:07.000Z</published>
    <updated>2022-09-30T15:32:36.615Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下在日常的工作中用到的一些<code>cmake</code>的关于文件操作的命令(基本<code>Copy</code>,<code>move</code>,<code>remove</code><spanclass="math inline">\(\dots\)</span>)</p><span id="more"></span><h2 id="cmake-文件操作"><code>cmake</code> 文件操作</h2><ul><li>通常使用<code>FILE</code>命令完成相关的参数.</li></ul><h3 id="copy-file"><code>Copy</code> File</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span>(&lt;COPY|<span class="keyword">INSTALL</span>&gt; &lt;files&gt;... DESTINATION &lt;dir&gt;</span><br><span class="line">     [FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]</span><br><span class="line">     [FOLLOW_SYMLINK_CHAIN]</span><br><span class="line">     [FILES_MATCHING]</span><br><span class="line">     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">    [EXCLUDE] [PERMISSIONS &lt;permissions&gt;...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># The COPY signature copies files, directories, and symlinks to a destination folder. </span></span><br><span class="line"><span class="comment"># Relative input paths are evaluated with respect to the current source directory, and a relative destination is evaluated with respect to the current build directory. </span></span><br><span class="line"><span class="comment"># Copying preserves input file timestamps, and optimizes out a file if it exists at the destination with the same timestamp.</span></span><br><span class="line"><span class="comment"># Copying preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS are given (default is USE_SOURCE_PERMISSIONS).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If FOLLOW_SYMLINK_CHAIN is specified, COPY will recursively resolve the symlinks at the paths given until a real file is found, and install a corresponding symlink in the destination for each symlink encountered.</span></span><br><span class="line"><span class="comment"># For each symlink that is installed, the resolution is stripped of the directory, leaving only the filename, meaning that the new symlink points to a file in the same directory as the symlink. </span></span><br><span class="line"><span class="comment"># This feature is useful on some Unix systems, where libraries are installed as a chain of symlinks with version numbers, with less specific versions pointing to more specific versions. </span></span><br><span class="line"><span class="comment"># FOLLOW_SYMLINK_CHAIN will install all of these symlinks and the library itself into the destination directory. </span></span><br><span class="line"><span class="comment"># For example, if you have the following directory structure:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>file</code>命令的<code>copy</code>操作会将文件，目录，或者是符号链接复制到目标目录，相对输入路径是相对于当前源目录(<code>cmake文件</code>)，复制会保留输入文件的时间戳，如果文件存在于目标位置且具有相同的时间戳，则会对其进行优化。复制行为默认保留默认权限，除非手动指定(<code>NO_SOURCE_PERMISSIONS</code>)。</li></ul><h4 id="example">example</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝一个目录(&#123;CMAKE_SOURCE_DIR&#125;/resources/Fonts)到&quot;&#123;CMAKE_SOURCE_DIR&#125;/bin/resources/&quot;路径下</span></span><br><span class="line"><span class="keyword">FILE</span>(COPY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/resources/Fonts DESTINATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin/resources/)</span><br></pre></td></tr></table></figure><ul><li>load <span class="math inline">\(\dots\)</span> <spanclass="math inline">\(\dots\)</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下在日常的工作中用到的一些&lt;code&gt;cmake&lt;/code&gt;的关于文件操作的命令(基本&lt;code&gt;Copy&lt;/code&gt;,&lt;code&gt;move&lt;/code&gt;,&lt;code&gt;remove&lt;/code&gt;&lt;span
class=&quot;math inline&quot;&gt;\(\dots\)&lt;/span&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://blog.ranbun.com/categories/CMake/"/>
    
    
    <category term="fileSystem" scheme="https://blog.ranbun.com/tags/fileSystem/"/>
    
  </entry>
  
  <entry>
    <title>透视矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/08/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/08/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-08T13:03:38.000Z</published>
    <updated>2022-09-25T14:29:09.110Z</updated>
    
    <content type="html"><![CDATA[<p>在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？<span id="more"></span></p><h2 id="投影变换">投影变换</h2><ul><li>平行投影</li><li>透视投影</li></ul><center><img id="projection" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/projection.png"/></center><ul><li>当我们完成视图变换<ul><li>相机被移动到世界坐标系的原点，同时场景做了同样的相对位移。</li><li>相机看向<code>-z</code>方向，我们指定了一个<code>up</code>,通过<code>cross</code>我们分别计算出三个轴向，相当远将世界坐标系做一个旋转操作，变换到<spanclass="math inline">\(\vec{right},\vec{up},\vec{look}\)</span> -相机右方向，上方向，观察方向，<font color=red>场景也要做相同的旋转操作</font></li><li>下一步的操作便是投影</li></ul></li><li>此时，我们的场景变换到了相机描述的坐标系下。</li></ul><h3 id="平行投影">1. 平行投影</h3><ul><li>我们最先要做的是定义一个视锥体。<ul><li><span class="math inline">\([left,right]\)</span></li><li><span class="math inline">\([bottom,top]\)</span></li><li><span class="math inline">\([zNear,ZFar]\)</span></li><li><spanclass="math inline">\(ortho(left,right,bottom,top,zNear,zFar)\)</span></li><li><font color=red>由于相机朝向<code>-z</code>,实际上说<code>zNear</code>大于<code>zFar</code></font>.</li></ul></li><li>如上图<a href="#projection">平行投影与透视投影</a>所示：平行投影没有近大远小的视觉效果，我们可以简单的丢掉所有顶点的<code>Z</code>值，将他们挤压到一个平面上，就可以得到一个平面的图。这将会丢掉维度信息，且不可逆，将场景变为二维，同是，对于关于<code>XOY</code>平面对称的点相当不友好[<code>-z,z</code>]，所以并不是一个合适的方法。<ul><li>变换矩阵: <span class="math display">\[  P_0 = \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></li></ul></li><li>更好的做法是将场景移动到原点，然后做一次缩放，将场景的所有的顶点的坐标变换到<spanclass="math inline">\((x,y,z) \in [-1,1]^3\)</span><ul><li>此时将会生成 <code>z-buffer</code>，三维场景的信息变为<spanclass="math inline">\([x,y]^2\)</span>的信息</li></ul></li></ul><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/Ortho.png"/></center><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/ortho_moveandscale.png"/></center><ul><li>对应矩阵<ul><li><p><code>T matrix</code> <span class="math display">\[  T =  \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\  0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\  0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>S matrix</code> <span class="math display">\[  S =  \begin{bmatrix}  \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\  0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\  0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>Ortho Matrix</code> <span class="math display">\[  Ortho =  S \times T =         \begin{bmatrix}      \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\      0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\      0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \times  \begin{bmatrix}      1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\      0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\      0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix} \\  = \begin{bmatrix}          \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp;-\frac{left+right}{2}\quad  \\          0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp;-\frac{top+bottom}{2}\quad  \\          0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp;-\frac{zNear+zFar}{2}\quad  \\          0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></p></li></ul></li></ul><h3 id="透视投影">2. 透视投影</h3><ul><li>透视投影变换的过程可以认为是将透视投影定义的视椎体挤压成一个长方体,然后运用平行投影相似的变换(<code>S + T</code>)<center><img id="projection2ortho" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection2ortho.png"/></center></li></ul><h4 id="挤压矩阵计算">2.1. 挤压矩阵计算</h4><p><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection_extrusion_computer.png" />- 如图<a href="#projection2ortho">projection2ortho</a>,从侧面上看: -<span class="math inline">\(\vec{g}\)</span> 指向<code>-Z</code>方向 -<span class="math inline">\(d\)</span> &amp; <spanclass="math inline">\(y_s\)</span>构成的三角形在<spanclass="math inline">\(e\)</span>的角度为<code>fov</code>的一半 -压缩是将<span class="math inline">\(y\)</span>压缩到<spanclass="math inline">\(y_s\)</span></p><h5 id="x_fary_far-to-x_neary_near">2.1.1 <spanclass="math inline">\([X_{far},Y_{far}]\)</span> to <spanclass="math inline">\([X_{near},Y_{near}]\)</span></h5><p><span class="math display">\[        \begin{pmatrix}        x \\        y \\        z \\        \end{pmatrix} *  \begin{bmatrix}        1 &amp; 0 &amp; 0 \\        0 &amp; n &amp; 0 \\        0 &amp; 0 &amp; 1 \\        \end{bmatrix}    = \begin{pmatrix}        x \\        y_s \\        z \\        \end{pmatrix}\]</span></p><ul><li>由三角形相似可以得到: <spanclass="math inline">\(\frac{y_s}{y}\quad=\frac{n}{f}\quad\)</span> =&gt;<span class="math inline">\(y_s = \frac{n}{f}\quad * y\)</span></li><li>同理: <span class="math inline">\(\frac{x_s}{x}\quad\)</span>=$ $=&gt; <span class="math inline">\(x_s = \frac{n}{f}\quad *x\)</span></li></ul><h5 id="挤压过程">2.1.2. 挤压过程</h5><ul><li>将一个点由透视投影的视椎体变换到正交下: <spanclass="math display">\[\begin{pmatrix}      x \\      y \\      z \\      1\end{pmatrix} =&gt; \begin{pmatrix}      \frac{n}{f}\quad*{x} \\      \frac{n}{f}\quad * y \\      {???} \\      1\end{pmatrix} =&gt; \begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}\]</span></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\        c_1 &amp; c_2 &amp; c_3 &amp; c_4  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><ul><li>考虑当被变换的这个点在近平面中心上: <spanclass="math display">\[\begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}=&gt;  \begin{pmatrix} \\      x \\      y \\      n \\      1  \end{pmatrix} = \begin{pmatrix}      n*x \\      n*y \\      n^2 \\      n\end{pmatrix}\]</span></li></ul><p><span class="math display">\[    Mat4^{(4\times4)}_{p-&gt;o}  * \begin{pmatrix}        x \\        y \\        n \\        1    \end{pmatrix} = \begin{pmatrix}        n*x \\        n*y \\        n^2 \\        n    \end{pmatrix}\]</span></p><p>得到: <span class="math inline">\(c_1 * x + c_2 * y + c_3 * n + c_4 *1 = n^2\)</span> <br> 得到: <span class="math inline">\(c_3 * n + c_4 =n^2\)</span></p><ul><li><p>同理考虑这个点落在远平面的中心: <br> 得到: <spanclass="math inline">\(c_3 * f + c_4 = f^2\)</span></p></li><li><p>解得:</p><ul><li><p><span class="math inline">\(c_3\)</span> <spanclass="math display">\[  c_3 = n + f \\  \]</span></p></li><li><p><span class="math inline">\(c_4\)</span> <spanclass="math display">\[  c_4 = -n * f  \]</span></p></li></ul></li><li><p><spanclass="math inline">\(Mat4^{(4\times4)}_{p-&gt;o}\)</span></p></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\            0 &amp; 0 &amp; n + f &amp; -n*f  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><h5 id="完整的透视变换矩阵">2.1.3. 完整的透视变换矩阵</h5><ul><li><span class="math inline">\(Mat^{(4\times4)}_{p-&gt;o} *Ortho^{4\times4}_{ortho}\)</span> <span class="math display">\[Mat^{4\times4}_{per} = \begin{bmatrix}              \frac{2*n}{right - left}\quad &amp; 0 &amp; \frac{right +left}{right - left}\quad &amp; -\frac{left+right}{2}\quad  \\              0 &amp; \frac{2*n}{top - bottom}\quad &amp; \frac{top +bottom}{bottom - top}\quad &amp; 0 \\              0 &amp; 0 &amp; \frac{zFar + zNear}{zNear - zFar}\quad&amp; -\frac{2*zFar*zNear}{zFar - zNear}\quad  \\              0 &amp; 0 &amp; 1 &amp; 0      \end{bmatrix}\]</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？
关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？</summary>
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="projection" scheme="https://blog.ranbun.com/tags/projection/"/>
    
  </entry>
  
  <entry>
    <title>AABB与Triangle求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/AABB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/AABB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:59.000Z</published>
    <updated>2022-10-23T14:41:59.400Z</updated>
    
    <content type="html"><![CDATA[<p><code>AABB</code>与三角形求交，采用分离轴的方式实现的一种比较优质的方法。 <span id="more"></span></p><h2 id="预备知识">0. 预备知识</h2><h3 id="点到面的距离方程">点到面的距离方程</h3><h3 id="面的方程">面的方程</h3><ul><li>定义平面<code>A</code>的法向 <spanclass="math inline">\(\vec{n}\)</span> <code>&#123;a,b,c&#125;</code>,</li><li>已知平面行一点<span class="math inline">\(P_0 \lbracex_0,y_0,z_0\rbrace\)</span></li><li>任意点 <spanclass="math inline">\(P\)</span><code>&#123;x,y,z&#125;</code></li><li>面方程:<ul><li><span class="math inline">\(\overrightarrow{P - P_0} \cdot \vec{n} =0\)</span></li></ul></li></ul><h3 id="点到面的距离">点到面的距离</h3><h4 id="法向量法">法向量法</h4><ul><li><span class="math inline">\(\vec{n}\)</span> - 平面的法向量</li><li><span class="math inline">\(d\)</span> - 点到平面的距离</li><li><span class="math inline">\(P\)</span> - 平面外一点</li><li><span class="math inline">\(A\)</span> - 平面上一点</li><li>$d = $<ul><li>PA在法向方向上的投影既是点<spanclass="math inline">\(P\)</span>到平面的距离</li></ul></li></ul><h3 id="射线的方程">射线的方程</h3><ul><li>射线方程<ul><li><span class="math inline">\(O\)</span> 为起点， 沿着方向 <spanclass="math inline">\(\vec{d}\)</span></li><li>射线方向上任意一点<span class="math inline">\(P_0\)</span></li><li><span class="math inline">\(P_0 = O + \vec{d}\)</span></li></ul></li></ul><h2 id="三角形与aabb求交">三角形与AABB求交</h2><ul><li>我们定义一个轴对齐包围盒<ul><li>center <span class="math inline">\(c\)</span>,<code>AABB</code>的中心点</li><li>a half vector <span class="math inline">\(\vec{h}\)</span>,记录盒子的各个轴的方向与在轴所在方向大小</li></ul></li><li>一个三角形<ul><li><span class="math inline">\(\Delta u_0u_1u_2\)</span></li></ul></li></ul><p><img id=AABB&Trangle src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/AABB_and_trangle_intersect.png></img></p><h3 id="第一步">1. 第一步</h3><ul><li>移动<code>AABB</code>与三角形，使<code>AABB</code>与原点重合</li></ul><h3 id="计算测试的轴">2. 计算测试的轴</h3><ul><li>我们将在原点进行基于分离轴的相交测试，需要测试13根轴。</li></ul><h4 id="aabb的面的法线">2.1 <code>AABB</code>的面的法线</h4><ul><li><span class="math inline">\(\vec{e_0}(1,0,0)\)</span></li><li><span class="math inline">\(\vec{e_1}(0,1,0)\)</span></li><li><span class="math inline">\(\vec{e_2}(0,0,1)\)</span></li></ul><h4 id="三角形delta-u_0u_1u_2的法线">2.2 三角形<spanclass="math inline">\(\Delta u_0u_1u_2\)</span>的法线</h4><ul><li><span class="math inline">\(\vec{n}\)</span></li><li><span class="math inline">\(\vec{n} == \vec{f_0} \times\vec{f_1}\)</span></li></ul><h4 id="a_ij-e_i-times-f_j">2.3 <span class="math inline">\(a_{ij} = e_i\times f_j\)</span></h4><ul><li><span class="math inline">\(i,j \in \left ( 0,1,2 \right)\)</span></li><li><span class="math inline">\(\vec{f_0} = \vec{v_1} -\vec{v_0}\)</span></li><li><span class="math inline">\(\vec{f_1} = \vec{v_2} -\vec{v_1}\)</span></li><li><span class="math inline">\(\vec{f_0} = \vec{v_0} -\vec{v_2}\)</span></li></ul><h3 id="分离轴计算">3 分离轴计算</h3><ul><li><p>一旦找到分离轴算法就会立即停止并且返回一个不相交的结果</p></li><li><p>如果通过所有的测试并且没有找到分离轴，那么三角形与<code>AABB box</code>相交</p></li><li><p>将三角形的顶点投影到每一个分离轴上，然后计算<code>AABB</code>在分离轴上的范围,<code>AABB</code>被移动到原点，它的投影将会是一个<spanclass="math inline">\(\left [ -r,+r\right ]\)</span>对称的</p><ul><li>如果她们在这个分离轴上重合，那么它们投影后的结果也是重合的</li></ul></li><li><p>只有当所有的分离轴上的测试都通过的时候才能是相交的。</p></li></ul><h2 id="code">Code</h2><h3 id="define-aabb">define AABB</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AABB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AABB() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AABB</span><span class="params">(<span class="keyword">const</span> glm::vec3 &amp; center,<span class="keyword">const</span> glm::vec3 &amp; size)</span></span></span><br><span class="line"><span class="function">        : <span class="title">m_center</span><span class="params">(center)</span></span></span><br><span class="line">        , m_size(size)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTransfrom</span><span class="params">(<span class="keyword">const</span> glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_center = glm::vec3( model * glm::vec4(m_center,<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_center;</span><br><span class="line">    glm::vec3 m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="define-triangle">define Triangle</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/// 注意三角形的顶点顺序为逆时针</span></span><br><span class="line">    Triangle(<span class="keyword">const</span> glm::vec3&amp; p1, <span class="keyword">const</span> glm::vec3&amp; p2, <span class="keyword">const</span> glm::vec3&amp; p3, <span class="keyword">const</span> glm::vec3&amp; normal)</span><br><span class="line">        : m_p1(p1)</span><br><span class="line">        , m_p2(p2)</span><br><span class="line">        , m_p3(p3)</span><br><span class="line">        , m_normal(glm::normalize(normal))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Triangle(<span class="keyword">const</span> glm::vec3&amp; p1, <span class="keyword">const</span> glm::vec3&amp; p2, <span class="keyword">const</span> glm::vec3&amp; p3)</span><br><span class="line">        : m_p1(p1)</span><br><span class="line">        , m_p2(p2)</span><br><span class="line">        , m_p3(p3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 计算三角形的法相</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                p2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          p3           p1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = p3 - p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = p2 - p1;</span><br><span class="line">        m_normal = glm::normalize(glm::cross(v2, v1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTransform</span><span class="params">(glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_p1 = vec3(model * glm::vec4(m_p1,<span class="number">1.0</span>));</span><br><span class="line">        m_p2 = vec3(model * glm::vec4(m_p2,<span class="number">1.0</span>));</span><br><span class="line">        m_p3 = vec3(model * glm::vec4(m_p3,<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = m_p3 - m_p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = m_p2 - m_p1;</span><br><span class="line">        m_normal = glm::normalize(glm::cross(v2, v1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_p1;</span><br><span class="line">    glm::vec3 m_p2;</span><br><span class="line">    glm::vec3 m_p3;</span><br><span class="line">    glm::vec3 m_normal;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IntersectAABBWithTriangle</span><span class="params">(<span class="keyword">const</span> AABB &amp;aabb, <span class="keyword">const</span> Triangle &amp;triangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// move AABB ro  origin</span></span><br><span class="line">    <span class="keyword">auto</span> box = aabb;</span><br><span class="line">    <span class="keyword">auto</span> trans = glm::mat4(<span class="number">1.0</span>);</span><br><span class="line">    trans = glm::translate(trans,- box.m_center);</span><br><span class="line">    box.updateTransfrom(trans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tri = triangle;</span><br><span class="line">    tri.updateTransform(trans);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;glm::vec3,13&gt; projectAxis;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;glm::vec3,3&gt; aabbAxisVector;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbAxisVector[<span class="number">0</span>] = glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">1</span>] = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">2</span>] = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;glm::vec3,3&gt; triEdgeVector;</span><br><span class="line">    &#123;</span><br><span class="line">        triEdgeVector[<span class="number">0</span>] = tri.m_p2 - tri.m_p1;</span><br><span class="line">        triEdgeVector[<span class="number">1</span>] = tri.m_p3 - tri.m_p2;</span><br><span class="line">        triEdgeVector[<span class="number">2</span>] = tri.m_p1 - tri.m_p3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> triangleNormal = tri.m_normal;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;glm::vec3,3&gt; aabbFaceNormal;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbFaceNormal[<span class="number">0</span>] = glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">1</span>] = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">2</span>] = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个图形边的随机组合的叉积也作为一个分离轴</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; i: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;  <span class="comment">/// AABB</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; j: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        &#123; <span class="comment">/// triangle</span></span><br><span class="line">            projectAxis[i*<span class="number">3</span> + j] = glm::normalize(glm::cross(aabbAxisVector[i], triEdgeVector[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的法线</span></span><br><span class="line">    projectAxis[<span class="number">9</span>] = triangleNormal;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; index: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        projectAxis[<span class="number">10</span> + index] = aabbFaceNormal[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; it: projectAxis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 投影三角形到分离轴上</span></span><br><span class="line">        <span class="keyword">auto</span> p_0 = glm::dot(it,tri.m_p1);</span><br><span class="line">        <span class="keyword">auto</span> p_1 = glm::dot(it,tri.m_p2);</span><br><span class="line">        <span class="keyword">auto</span> p_2 = glm::dot(it,tri.m_p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的Size</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> half = glm::vec3(<span class="number">0.5</span> * aabb.m_size.x,<span class="number">0.5</span> * aabb.m_size.y,<span class="number">0.5</span> * aabb.m_size.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的投影的结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> r = half.x * <span class="built_in">std</span>::<span class="built_in">abs</span>(dot(aabbAxisVector[<span class="number">0</span>],it)) +</span><br><span class="line">                half.y * <span class="built_in">std</span>::<span class="built_in">abs</span>(dot(aabbAxisVector[<span class="number">1</span>],it)) +</span><br><span class="line">                half.z * <span class="built_in">std</span>::<span class="built_in">abs</span>(dot(aabbAxisVector[<span class="number">2</span>],it));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算三角形投影结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> min_p = <span class="built_in">std</span>::min(<span class="built_in">std</span>::min(p_0,p_1),p_2);</span><br><span class="line">        <span class="keyword">auto</span> max_p = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(p_0,p_1),p_2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否相交</span></span><br><span class="line">        <span class="keyword">if</span>(min_p &gt; r || max_p &lt; -r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;AABB&lt;/code&gt;
与三角形求交，采用分离轴的方式实现的一种比较优质的方法。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="AABB" scheme="https://blog.ranbun.com/tags/AABB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>OBB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:42.000Z</published>
    <updated>2022-10-23T14:41:59.457Z</updated>
    
    <content type="html"><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。<span id="more"></span></p><h2 id="obb与ray求交">OBB与Ray求交</h2><ul><li>我们在更之前的地方定义了一个<code>OBB</code>,往前翻一番也许就能找到<ul><li><span class="math inline">\(center\)</span> - 盒子的中心点</li><li><span class="math inline">\(\vec{u}\)</span> - 盒子的某个法线 <spanclass="math inline">\(u\)</span></li><li><span class="math inline">\(\vec{v}\)</span> - 盒子的某个法线 <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(\vec{w}\)</span> - 盒子的某个法线 <spanclass="math inline">\(w\)</span></li><li>盒子的尺寸 - <span class="math inline">\(size\left(h_u,h_v,h_w\right )\)</span></li></ul></li><li>同样的 我们曾经定义过一条射线<ul><li><span class="math inline">\(Ray \left( P\right ) = O + t \cdot\vec{u}\)</span></li><li><code>Ray(P)</code> 射线上某一点</li><li><code>O</code> 射线的起点</li><li><code>t</code> 沿着方向<spanclass="math inline">\(\vec{u}\)</span>前进的长度</li><li><span class="math inline">\(\vec{u}\)</span> 射线的方向向量</li></ul></li></ul><h2 id="slab-method">slab method</h2><ul><li>在OBB与光线的求交计算中，我们常用的方法是<code>slab method</code><ul><li>将我们测量的这个盒子分成三组平行的板</li><li>分别将光线与对应的板做相交计算，在射线的方向上，有一个进入这一组板的时间<spanclass="math inline">\(t^{min}\)</span>，以及一个出板的时间<spanclass="math inline">\(t^{max}\)</span></li><li>分别计算对于三个面板的<spanclass="math inline">\(t^{min}_{i},t^{max}_{i},i \in\left(u,v,w\right)\)</span></li><li>如果射线与盒子相交，那么简单的说这条射线一定有一段时间是处于这三个<spanclass="math inline">\(t^{min},t^{max}\)</span>之中的。</li></ul></li></ul><h3 id="计算原理">计算原理</h3><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/Ray_and_Obb_intersect.png"title="Ray&amp;OBB" alt="intersection" /><figcaption aria-hidden="true">intersection</figcaption></figure><ul><li><p><span class="math inline">\(P_{min} = P + t_{min} \cdot\vec{u}\)</span> - <span class="math inline">\(1.0\)</span></p></li><li><p><span class="math inline">\(P_{max} = P + t_{max} \cdot\vec{u}\)</span> - <span class="math inline">\(1.1\)</span></p></li><li><p><span class="math inline">\(P_{i} = P + t \cdot \vec{u}\)</span>- <span class="math inline">\(1.2\)</span></p></li><li><p>$(P_{min} - C ) = min $ - <spanclass="math inline">\(1.3\)</span></p></li><li><p>$(P_{max} - C ) = max $ - <spanclass="math inline">\(1.4\)</span></p></li><li><p><span class="math inline">\(1.0\)</span>式 &amp; <spanclass="math inline">\(1.1\)</span>式 带入 <spanclass="math inline">\(1.3\)</span>式 &amp; <spanclass="math inline">\(1.4\)</span>式得到： <span class="math display">\[\left [ \left (P + t_i \cdot \vec{u} \right ) - C \right ] \cdot\vec{O_n} = O_{Size.j} / 2.0, i \in (min,max),j \in (x,y,z), n \in(u,v,w)\]</span> =&gt; 化简得: <span class="math display">\[t_i = (O_{Size.i} / 2.0 - (C - P) \cdot \vec{O_n}) / (\vec{u} \cdot\vec{O_n}), i \in (min,max),j \in (x,y,z), n \in (u,v,w)\]</span></p></li></ul><h3 id="求交实现">求交实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersect::IntersectObbWithRay</span><span class="params">(<span class="keyword">const</span> OBB&amp; obb, Ray &amp; ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delta = obb.m_center - ray.m_begin; <span class="comment">// C- P</span></span><br><span class="line">    <span class="keyword">float</span> t1, t2;    <span class="comment">// 当前面交点在射线上的位置</span></span><br><span class="line">    <span class="keyword">double</span> minT = DBL_MIN, maxT = DBL_MAX;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> e = glm::dot(delta, obb.m_u);</span><br><span class="line">        <span class="keyword">float</span> f = glm::dot(ray.m_dir, obb.m_u);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>) <span class="comment">// 判断当前面是否和射线平行 - 与法线垂直则会平行</span></span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)  <span class="comment">// 交换 我们不知道当前的射线与目前检测的板的法相的方向是什么样的关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)   <span class="comment">// 未发生相交</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)  <span class="comment">// 小于0表示不再正方向上，盒子在射线的后面</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时盒子与光线平行，我们需要看看盒子和光线的关系，如果光线在盒子内部则相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.x / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.x / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> e = glm::dot(delta, obb.m_v);</span><br><span class="line">        <span class="keyword">float</span> f = glm::dot(ray.m_dir, obb.m_v);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.y / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.y / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> e = glm::dot(delta, obb.m_w);</span><br><span class="line">        <span class="keyword">float</span> f = glm::dot(ray.m_dir, obb.m_w);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.z / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.z / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
  </entry>
  
  <entry>
    <title>OBB与OBB求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:28:20.000Z</published>
    <updated>2022-09-25T14:29:09.106Z</updated>
    
    <content type="html"><![CDATA[<p>OBB 全称为 Oriented Bound Box，译为有朝向的包围盒。OBB 常与AABB(Axis-Aligned Bound Box) 对比：AABB 的边与轴平行，而 OBB的边则与物体的朝向有关。</p><span id="more"></span><h3 id="obb求交介绍">OBB求交介绍</h3><ul><li>采用分离轴的方式计算</li><li>两个凸包多边形，当且仅当存在一条线，这两个多边形在这条线上的投影不相交，则这两个多边形也不相交.</li><li>这条线称为<code>Separating Axis</code>.垂直<code>Separating Axis</code>存在一条<code>Separating Line</code>将两个多边形分开。</li></ul><h4 id="obb-to-aabb">OBB to AABB</h4><ul><li>我们采用一个稍微容易理解的方法完成这种计算 -将<code>OBB</code>转换为<code>AABB</code></li><li>然后使用<code>AABB</code>o求交的计算方式去算<code>OBB</code>的相交</li></ul><h3 id="aabb的定义"><code>AABB</code>的定义</h3><ul><li><code>AABB</code>既是<code>Axis-aligned Bounding Box</code></li></ul><center><img src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/define_aabb.png></img></center><ul><li>简单由定义两个最大最小点完成定义，一个<code>OBB</code>也可以描述一个<code>AABB</code></li></ul><h3 id="obb的定义">OBB的定义</h3><ul><li><code>m_center</code> 中点位置</li><li><code>size</code> 盒子的大小(尺寸)</li><li><span class="math inline">\(\vec{u},\vec{v},\vec{w}\)</span>,坐标系的轴向(与面的法相一样)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OBB</span></span></span><br><span class="line"><span class="class">///&lt;</span> 右手系</span><br><span class="line">&#123;</span><br><span class="line">    OBB(<span class="keyword">const</span> vec3 &amp; pos,<span class="keyword">const</span> vec3 &amp; size)</span><br><span class="line">        : m_pos(pos)</span><br><span class="line">        , m_size(size)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OBB(<span class="keyword">const</span> vec3&amp; pos, <span class="keyword">const</span> vec3&amp; size, <span class="keyword">const</span> vec3&amp; u, <span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; w)</span><br><span class="line">        : m_pos(pos)</span><br><span class="line">        , m_size(size) </span><br><span class="line">        , m_u(u)</span><br><span class="line">        , m_v(v)</span><br><span class="line">        , m_w(w)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 m_pos&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;   <span class="comment">///&lt; pos </span></span><br><span class="line">    vec3 m_size&#123; <span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span> &#125;;  <span class="comment">///&lt; 长宽高 x = 长 y = 宽 z = 高</span></span><br><span class="line">    vec3 m_u&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; x</span></span><br><span class="line">    vec3 m_v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; y </span></span><br><span class="line">    vec3 m_w&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;     <span class="comment">///&lt; z </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="aabb求交"><code>AABB</code>求交</h3><ul><li>根据分离轴定理，对于<code>AABB</code>我们只需要计算最大最小的点在标准的<spanclass="math inline">\({\vec{x},\vec{y},\vec{z}}\)</span>轴上的投影是否相交即可，实现起来比较简单</li></ul><h4 id="code">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">intersectObbWithObb</span><span class="params">(OBB &amp;first, OBB &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fRes  = computerOBBIntersecte(first,second);</span><br><span class="line">    <span class="keyword">auto</span> sRes = computerOBBIntersecte(second,first);</span><br><span class="line">    <span class="keyword">return</span> (fRes&amp;sRes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">computerOBBIntersecte</span><span class="params">(OBB first, OBB second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// first</span></span><br><span class="line">    first.m_trans = glm::translate(glm::mat4(<span class="number">1.0f</span>),-first.m_center);</span><br><span class="line">    <span class="keyword">auto</span> rotate = glm::mat4(glm::vec4(first.m_u, <span class="number">0.0</span>), glm::vec4(first.m_v, <span class="number">0.0</span>), glm::vec4(first.m_w, <span class="number">0.0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>));</span><br><span class="line">    rotate = glm::transpose(rotate);</span><br><span class="line">    first.m_rotate = rotate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个matrix变换到第一个变换矩阵描述的空间</span></span><br><span class="line">    first.m_center = first.m_rotate * first.m_trans * glm::vec4(first.m_center,<span class="number">1.0</span>);</span><br><span class="line">    first.m_u = first.m_rotate * first.m_trans * glm::vec4(first.m_u,<span class="number">0.0</span>);</span><br><span class="line">    first.m_v = first.m_rotate * first.m_trans * glm::vec4(first.m_v,<span class="number">0.0</span>);</span><br><span class="line">    first.m_w = first.m_rotate * first.m_trans * glm::vec4(first.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 second 变换到对应的空间中</span></span><br><span class="line">    <span class="keyword">auto</span> trans2Origin = glm::translate(glm::mat4(<span class="number">1.0</span>),-second.m_center);</span><br><span class="line">    second.m_trans = trans2Origin;</span><br><span class="line">    <span class="keyword">auto</span> transRestore = glm::translate(glm::mat4(<span class="number">1.0</span>),second.m_center);</span><br><span class="line">    second.m_center = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::vec4(second.m_center,<span class="number">1.0</span>);</span><br><span class="line">    second.m_u = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::vec4(second.m_u,<span class="number">0.0</span>);</span><br><span class="line">    second.m_v = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::vec4(second.m_v,<span class="number">0.0</span>);</span><br><span class="line">    second.m_w = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::vec4(second.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// first Obb max &amp; min position</span></span><br><span class="line">    glm::vec3 fMinPos = first.m_center - first.m_size.x/<span class="number">2.0f</span> * first.m_u - first.m_size.y / <span class="number">2.0f</span> * first.m_v - first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line">    glm::vec3 fMaxPos = first.m_center + first.m_size.x/<span class="number">2.0f</span> * first.m_u + first.m_size.y / <span class="number">2.0f</span> * first.m_v + first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算second OBB 的最大最小点</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;glm::vec3,8&gt; secondPos;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 右手系</span></span><br><span class="line">        <span class="comment">// m_center + vector * size</span></span><br><span class="line">        secondPos[<span class="number">0</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">1</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">2</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">3</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">4</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">5</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">6</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">7</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 sMinPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line">    glm::vec3 sMaxPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it : secondPos)</span><br><span class="line">    &#123;</span><br><span class="line">        sMinPos.x = sMinPos.x &gt; it.x? it.x:sMinPos.x;</span><br><span class="line">        sMinPos.y = sMinPos.y &gt; it.y? it.y:sMinPos.y;</span><br><span class="line">        sMinPos.z = sMinPos.z &gt; it.z? it.z:sMinPos.z;</span><br><span class="line"></span><br><span class="line">        sMaxPos.x = sMaxPos.x &lt; it.x? it.x:sMaxPos.x;</span><br><span class="line">        sMaxPos.y = sMaxPos.y &lt; it.y? it.y:sMaxPos.y;</span><br><span class="line">        sMaxPos.z = sMaxPos.z &lt; it.z? it.z:sMaxPos.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        (fMinPos.x &gt; sMaxPos.x || sMinPos.x &gt; fMaxPos.x) ||</span><br><span class="line">        (fMinPos.y &gt; sMaxPos.y || sMinPos.y &gt; fMaxPos.y) ||</span><br><span class="line">        (fMinPos.z &gt; sMaxPos.z || sMinPos.z &gt; fMaxPos.z)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然也可以直接使用其他的方式计算<code>OBB</code>的求交，分离轴使用相对较多，可以直接投影<code>OBB</code>的最大最小的点到由<code>OBB</code>确定的投影轴上,包含15跟轴</li><li><code>OBB A</code>的三个轴向,<code>OBB B</code>的三个轴向 6根。</li><li>两个<code>OBB</code>各自轴向的叉积 =&gt; 3*3 = 9。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OBB 全称为 Oriented Bound Box，译为有朝向的包围盒。OBB 常与
AABB(Axis-Aligned Bound Box) 对比：AABB 的边与轴平行，而 OBB
的边则与物体的朝向有关。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
  </entry>
  
  <entry>
    <title>IBL</title>
    <link href="https://blog.ranbun.com/2022/09/08/IBL/"/>
    <id>https://blog.ranbun.com/2022/09/08/IBL/</id>
    <published>2022-09-07T17:07:45.000Z</published>
    <updated>2022-09-18T15:55:57.570Z</updated>
    
    <content type="html"><![CDATA[<p>基于图像的照明<code>Image Based Lighting</code> <span id="more"></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于图像的照明&lt;code&gt;Image Based Lighting&lt;/code&gt;</summary>
    
    
    
    <category term="rendering" scheme="https://blog.ranbun.com/categories/rendering/"/>
    
    
  </entry>
  
  <entry>
    <title>构造函数私有化</title>
    <link href="https://blog.ranbun.com/2022/08/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89%E5%8C%96/"/>
    <id>https://blog.ranbun.com/2022/08/29/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89%E5%8C%96/</id>
    <published>2022-08-29T07:28:04.000Z</published>
    <updated>2022-09-07T17:13:27.466Z</updated>
    
    <content type="html"><![CDATA[<p>在我使用<code>std::make_unique&lt;Typename T&gt;()</code>构建一个我自定义的类的时候，不小心将构造函数写成了私有的，出现了这个问题-<code>cannot access private member declared in class</code>，这完全是由于不仔细造成的...</p><span id="more"></span><h2 id="cannot-access-private-member-declared-in-class">cannot accessprivate member declared in class</h2><h3 id="可能的错误原因">可能的错误原因:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> / <span class="keyword">protected</span>: </span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我使用&lt;code&gt;std::make_unique&amp;lt;Typename T&amp;gt;()&lt;/code&gt;构建一个我自定义的类的时候，不小心将构造函数写成了私有的，出现了这个问题-&lt;code&gt;cannot access private member declared in class&lt;/code&gt;，这完全是由于不仔细造成的...&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:58.000Z</published>
    <updated>2022-09-15T15:29:04.374Z</updated>
    
    <content type="html"><![CDATA[<p>考虑某种场景，我们需要一个工具类，对于所有模块提供同样的接口与数据，但是如果每个模块使用这个类的功能的时候都创建一整个类，此种行为虽说是合法的，但并不是最好的选择，我们可以通过单例设计模式，将这个类变为一个单例，我们每一次创建这个类的实例的时候，都只是获取之前创建的，从而调用相应的功能。<span id="more"></span></p><h2 id="单例模式">单例模式</h2><ul><li>单线程版本</li><li>多线程版本</li><li>双检查锁</li><li><code>C++11</code>之后的版本</li><li><code>std::call_once</code></li></ul><h3 id="实现">实现</h3><ul><li>单线程版本<ul><li>此版本只是单线程安全</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sprivate:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程版本</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.release();</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多线程版本优化版 - 双检查锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">            &#123;</span><br><span class="line">                m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>C++11</code>版本</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>std::call_once</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(flag, []() &#123;m_instance.reset(<span class="keyword">new</span> Singleton()); &#125;);</span><br><span class="line">        <span class="keyword">return</span> *m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Singleton&gt; Singleton::m_instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;考虑某种场景，我们需要一个工具类，对于所有模块提供同样的接口与数据，但是如果每个模块使用这个类的功能的时候都创建一整个类，此种行为虽说是合法的，但并不是最好的选择，我们可以通过单例设计模式，将这个类变为一个单例，我们每一次创建这个类的实例的时候，都只是获取之前创建的，从而调用相应的功能。</summary>
    
    
    
    <category term="Design Patterns" scheme="https://blog.ranbun.com/categories/Design-Patterns/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:44.000Z</published>
    <updated>2022-09-18T15:31:36.496Z</updated>
    
    <content type="html"><![CDATA[<p>什么是工厂模式？工厂顾名思义，就是创建产品。该模式封装和管理对象的创建，通俗地讲就是，你<code>new</code>一个对象的时候，直接调用工厂方法就行了。</p><span id="more"></span><h2 id="工厂模式">工厂模式</h2><ul><li>当我们需要不停的创建不同的对象的时候，我们可以通过封装接口，然后调用函数返回不同的类型的对象，这个时候我们就需要工厂模式帮我们处理此问题</li></ul><h3 id="简单工厂模式">1. 简单工厂模式</h3><ul><li>将类的初始化和创建全部交给一个工厂来完成，我们只需要告诉工厂我们需要什么即可。</li><li>专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</li><li>是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。</li></ul><h4 id="工厂factory">1. 工厂(<code>Factory</code>)</h4><ul><li>负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。</li><li>创建出产品(<code>Product</code>) -&gt;具体的产品(<code>ConcreteProduct</code>)</li></ul><h4 id="产品">2. 产品</h4><h5 id="抽象产品">抽象产品</h5><ul><li>象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其派生对象。</li></ul><h5 id="具体产品">具体产品</h5><ul><li>具体产品是简单工厂模式的创建目标。每个具体产品都继承了抽象产品，需要实现定义在抽象产品中的方法。</li></ul><h4 id="使用">3. 使用</h4><ul><li>当我们需要创建的对象数量较多且杂的时候，我们需要使用简单工厂模式来创建对象。</li><li>对象的创建过程是我们不需要去关心，我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，方便后期的程序扩展和维护。</li></ul><h4 id="code">4. <code>Code</code></h4><ul><li>Product</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">product_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    none,</span><br><span class="line">    one,</span><br><span class="line">    two</span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Product() = <span class="keyword">default</span>;</span><br><span class="line">    ~Product() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">final</span> :</span><span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductA() = <span class="keyword">default</span>;</span><br><span class="line">    ~ProductA() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">final</span> :</span><span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProductB() = <span class="keyword">default</span>;</span><br><span class="line">    ~ProductB() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Factoy.h</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">Factoy.h</span><br><span class="line">---</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Factory() = <span class="keyword">default</span>;</span><br><span class="line">    ~Factory() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  Product* <span class="title">crteateProduct</span><span class="params">(product_type &amp; type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::one)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span>  ProductA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::two)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">crteateProduct</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>main</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> Factory;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;crteateProduct(product_type::none);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式">2. 工厂方法模式</h3><h4 id="简介">2.1 简介</h4><ul><li>简单工厂模式中最大的缺点就是当我们需要创建新的产品的时候，我们需要修改工厂的<code>create</code>方法，加入必要的处理逻辑，违背了设计原则-<code>开闭原则</code></li><li>工厂方法模式中，工厂父类只是定义创建产品的接口，子类负责创建具体的产品，将具体产品的创建都延迟到子类中实现，通过子类创建具体的实例化对象。</li></ul><h4 id="实现">实现</h4><ul><li><code>concreteFactory.h</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FactoryA() = <span class="keyword">default</span>;</span><br><span class="line">    ~FactoryA() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Product* <span class="title">crteateProduct</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>main.cpp</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;concreteFactory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> FactoryA;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;crteateProduct();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式">3. 抽象工厂模式</h3><ul><li>一个特殊的工厂模式</li><li>创建一个产品族</li><li>待续</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是工厂模式？
工厂顾名思义，就是创建产品。该模式封装和管理对象的创建，通俗地讲就是，你&lt;code&gt;new&lt;/code&gt;一个对象的时候，直接调用工厂方法就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="Design Patterns" scheme="https://blog.ranbun.com/categories/Design-Patterns/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>多重继承下的菱形继承</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</id>
    <published>2022-08-19T12:58:37.000Z</published>
    <updated>2022-09-07T17:13:27.464Z</updated>
    
    <content type="html"><![CDATA[<p><code>cpp</code>, 中关于继承的一点问题...</p><span id="more"></span><h2 id="单继承">单继承</h2><ul><li>只有一父类的时候，称之为单继承</li></ul><h2 id="多继承">多继承</h2><ul><li>一个子类有两个及以上的父类，这个时候，称之为多继承</li></ul><h3 id="菱形继承">菱形继承</h3><ul><li>多继承下面的特殊状态, 会产生一些问题。<ul><li>当一个类的父类们同时拥有相同的父类的时候，就会发生二义性 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/diamond_inheritance.PNG"title="菱形继承" alt="菱形继承" /></li></ul></li></ul><h4 id="问题">问题</h4><h5 id="二义性">1 二义性</h5><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/cpp/inherit_ambiguos.png"title="二义性问题" alt="二义性" /><figcaption aria-hidden="true">二义性</figcaption></figure><ul><li><p>解决访问的二义性相对简单，可以通过添加类的限定从而访问到具体的数据</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span> :</span><span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Author()</span><br><span class="line">    &#123;</span><br><span class="line">        Student::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Teacher::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li></ul><h5 id="数据冗余">2 数据冗余</h5><ul><li>从上面的图来看,菱形继承的数据发生了冗余，以及带来数据访问时候的二义性<ul><li>在<code>Author</code>中存在两份<code>Person</code>的数据</li></ul></li><li>数据冗余的问题在<code>CPP</code>中通过使用虚继承解决</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> name,<span class="built_in">std</span>::<span class="built_in">string</span> ID = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        :name_(name)</span><br><span class="line">        ,id_(ID)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_&#123;<span class="string">&quot;name&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> birthDay_&#123;<span class="string">&quot;2000.1.1&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id_&#123;<span class="string">&quot;XXXXXXXXXXXXXXXXXX&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> name_)</span><br><span class="line">        :Person(<span class="string">&quot;stu&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Student() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> stuId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name_)</span><br><span class="line">        :Person(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Teacher() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> teacherId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚继承的实现原理">虚继承的实现原理</h2><ul><li><p><code>virtual base table pointer</code></p></li><li><p><code>virtual table</code></p></li><li><p>我们基于上面部分分析关于虚继承的实现的原理</p><ul><li><code>VS</code>的<code>class</code>布局查看工具 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/cpp/vs_Layout_to_class.png" /></li><li>上述信息包含:虚函数表及布局，类的大小，类成员占用大小，成员相较于起始地址的偏移量，字节对其信息</li></ul></li><li><p>上述布局中我们可以看到,当虚继承发生,就会在虚基类的直接子类中产生一个<code>vbptr</code>指针,这个指针指向一个虚基类表,<code>Author</code>继承自<code>Teacher&amp;Student</code>,同样继承了虚基类指针,同时<code>Author</code>只存在一份<code>Person</code>的数据.</p></li><li><p>我们通过虚基类表中记录的偏移(虚基类到当前类),就可以访问到虚基类的数据成员.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;cpp&lt;/code&gt;, 中关于继承的一点问题...&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/categories/cpp/"/>
    
    
    <category term="inherit" scheme="https://blog.ranbun.com/tags/inherit/"/>
    
  </entry>
  
  <entry>
    <title>View/Camera Transformation</title>
    <link href="https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/"/>
    <id>https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/</id>
    <published>2022-08-19T12:39:56.000Z</published>
    <updated>2022-08-22T11:46:11.143Z</updated>
    
    <content type="html"><![CDATA[<p>  计算机图形学的视图变换过程的解析...</p><span id="more"></span><h1 id="视图变换">视图变换</h1><ul><li>视图变换是将所有世界空间中的点，变换到视图空间下的操作<ul><li>这种变换，我们通过矩阵可以轻易的完成，但是我们首先需要计算一个描述这种变换的矩阵</li></ul></li><li>在一般的实现中，我们将视图变换的过程抽象出了一个相机的概念<ul><li>本身而言在图形学中是没有相机这个概念的</li></ul></li></ul><h2 id="视图变换-变换过程">视图变换-变换过程</h2><ul><li>从顶点构建到最终渲染成一张二维的图片，在行业中大家将之类比为拍照的行为<ul><li>模型变换 - 取景的过程</li><li><font color=red>视图变换 - 摆放相机的过程</font></li><li>......</li><li>此处我们只是讨论视图变换的过程</li></ul></li></ul><h3 id="定义一个相机">定义一个相机</h3><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/define_cameracamera.png"title="define camera" alt="camera" /><figcaption aria-hidden="true">camera</figcaption></figure><ul><li>对于上述的那个拍照的行为，我们要拍摄这个摆放好的景物，关于相机我们只需要关心三个方面。<ul><li>我们基于<font color=red>右手系</font>考虑下面的这些信息</li><li>相机的位置 <span class="math inline">\(e\)</span> -&gt; <spanclass="math inline">\(eye\)</span> = $x,y,z,1$</li><li>相机的看的方向，既相机的拍摄方向 <spanclass="math inline">\(\vec{dir}\)</span> - <code>lookAt direction</code>$x,y,z,0 $</li><li>相机的上方向 <span class="math inline">\(\vec{up}\)</span> = <spanclass="math inline">\(\lbrace x,y,z,1\rbrace\)</span><ul><li>大概是手机横屏与竖屏的区别</li></ul></li></ul></li><li>我们获得一个观察方向,一个向上的方向<ul><li>观察方向与向上方向垂直</li><li>通过叉积我们可以得到一个向右的方向<spanclass="math inline">\(\vec{right}\)</span></li></ul></li></ul><p style="color:red">  从拍照的行为来看，相机的观察方向是指向模型摆放的位置，我们保持两个物体的相对位置关系(相机与场景)，相机做了某种变换，模型也跟着做同样的变换。基于这种相对位置的变化，我们约定，将相机永远变换到原点，相机的观察方向永远是<code> -z </code>方向,以此我们构建一个坐标系</p><p><img id="view_coordinate" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/camera构建坐标系.png"/></p><h2 id="计算视图变换矩阵">计算视图变换矩阵</h2><p><img id="旋转矩阵构建" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/旋转矩阵的构建.png"/></p><ul><li>我们将以相机定义的坐标框架通过旋转与平移将之与世界空间的坐标重合<ul><li><span class="math inline">\(\vec{g}\)</span> -&gt; $ $</li><li><span class="math inline">\(\vec{t}\)</span> -&gt; $ $</li><li><span class="math inline">\(\vec{t} \times \vec{g}\)</span> -&gt;<span class="math inline">\({\vec{X}}\)</span></li><li><font color=red>但是我们要做到上面的事情比较困难，换一种思路，我们做相反的事情</font></li></ul></li><li>我们将世界空间的坐标通过旋转&amp;平移将之与相机定义的坐标系重合<ul><li><span class="math inline">\(\vec{Y}\)</span> -&gt; <spanclass="math inline">\(\vec{t}\)</span></li><li><span class="math inline">\(\vec{-Z}\)</span> -&gt; <spanclass="math inline">\(\vec{g}\)</span></li><li><span class="math inline">\({\vec{X}}\)</span> -&gt; <spanclass="math inline">\(\vec{t} \times \vec{g}\)</span></li></ul></li><li>构建一个旋转矩阵的逆矩阵，然后计算逆矩阵的逆便得到我们想要的矩阵。<ul><li>由于坐标系的三个轴是正交的，我们只需要将矩阵转置就可以得到这个旋转矩阵。</li></ul></li><li>将旋转矩阵与平移矩阵乘起来，就得到想要的试图变换矩阵</li></ul><p><img src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/旋转矩阵计算.jpg"/></p><p style="color:pink"><p>   上述过程描述了视图变换的过程与视图矩阵的计算。</p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  计算机图形学的视图变换过程的解析...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    
    <category term="Base" scheme="https://blog.ranbun.com/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>起伏的2022(上)</title>
    <link href="https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-14T09:22:51.000Z</published>
    <updated>2022-10-23T14:41:58.859Z</updated>
    
    <content type="html"><![CDATA[<center><h1>关于我的2022(上)</h1></center><p>  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......</p><span id="more"></span><h2 id="上一览">2022上，一览</h2><ul><li>辞掉了原来的工作<ul><li>离开了北京</li><li>又去见了一些人</li></ul></li><li>来了成都</li><li>给自己翻篇</li><li>遇到了她<ul><li>准备一起写我们的故事</li></ul></li></ul><h3 id="离开我不喜欢的北京">离开我不喜欢的北京</h3><h4 id="辞职那点事">辞职那点事</h4><p>  其实之前也算是成都的一家公司，只是有些草率，我的入职合同是通过快递签订的。除了和我一起出差的同事，我并未见过任何一个公司的同事。我以为我的入职之后会是在成都度过，但是事实总是不能遂了人意，我在一直呆在北京，算是出差中，可能是呆的时间有点太长了，我决定要离开了。于是在去年年底的最后一个月开始重新找工作了，依旧是在成都，重新觅一份新的工作，阴差阳错，来了现在的公司，年前的2月，我们结束我们的年假，决定前往北京进行工作最后的工作交接。我深知那一次的离开，我可能再也不会再来北京，离开前总是需要见一些该见的人，就当作是最后的告别。</p><h4 id="往后不能再见的朋友">往后不能再见的朋友</h4><p>  记得大一的第一学期的前半程是稍微有些无聊的，我去往那个和我期待中的样子差距颇大的地方，我在颓废中度过了大一第一学期的前半程，可能是接受了现实，我决定改变一下这个现状，于是迈出了我成为程序员得第一步，我找了个学生组织，参与进去。可能是缘分，我遇到好些个有意思的人，在这之中有我的好朋友，也有带我入行的学长，毕业后，学长去了北京。虽然在我本来的计划中，我大概会去北京的，但事情总是不得遂人意，阴差阳错，我没能去了。借此机会，见了这位阔别已久的老朋友，一起聊到凌晨，大家总有各自的生活，所以分别，多少没那么不舍。我相信缘分会拉着我们一次又一次的相遇。</p><p>  那位没能和我们一起拍毕业照的小伙伴，也将见证我的离去，我们是大学同学，男孩子性格的她，和我们最是合得来，一起吃了个饭，记得是我此前没有尝试过的港式，没有什么不舍，惟愿。</p><h3 id="终来成都">终来成都</h3><h4 id="新工作">新工作</h4><ul><li>还是那个工作，只是换了环境和一波同事，对我来说,差别不大。来时是三月中旬，成都总是那么出人意料，我来时给予我最大的温暖，$28^o $的天气，只有感谢，未能有更多言语。</li><li>来后三个月的感叹，<code>我好菜呀！！！！！！！</code></li></ul><h3 id="给自己翻篇">给自己翻篇</h3><ul><li>经历变得丰富，成长颇多，感谢！</li><li>毕业两年！！！！！！！！！！！！！！！！！！！！！！！！！</li></ul><h3 id="遇到她">遇到她</h3><ul><li>如果我没有离开北京，如果我没有来这里，所以一切都是刚好的样子，感谢缘分让我们相遇。我们很合拍，无论什么。</li><li>所以想写新的故事，就我和她，在这个城市的故事。<ul><li>所以感谢会会的早餐与陪伴</li></ul></li></ul><h3 id="over">Over</h3><ul><li>2022的上半年到我们在一起结束，这是我2022年最开心的时候，感谢缘分，感谢相遇！</li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h1&gt;
关于我的2022(上)
&lt;/h1&gt;
&lt;/center&gt;
&lt;p&gt;
  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......
&lt;/p&gt;</summary>
    
    
    
    <category term="bun" scheme="https://blog.ranbun.com/categories/bun/"/>
    
    <category term="life" scheme="https://blog.ranbun.com/categories/bun/life/"/>
    
    
    <category term="mylife" scheme="https://blog.ranbun.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>Cplusplus key words - extern</title>
    <link href="https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/"/>
    <id>https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/</id>
    <published>2022-08-08T03:41:35.000Z</published>
    <updated>2022-08-21T15:34:56.737Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>cpp</code>关键词之<code>extern</code>...</p><span id="more"></span><center><h2><code>extern</code>关键字</h2></center><h2 id="extern-初解"><code>Extern</code> 初解</h2><ul><li>关于<code>extern</code>关键字可以应用于全局变量、函数或模板声明。它指定符号具有外部链接性质。<ul><li>在非const 全局变量声明中， extern指定变量或函数在另一个转换单元中定义。extern必须在定义变量的所有文件中应用该变量。</li><li>const在变量声明中，它指定变量具有 external 链接。extern必须应用于所有文件中的所有声明。 默认情况下， (全局 const变量具有内部链接。)</li><li>extern "C" 指定函数在别处定义并使用 C 语言调用约定。 extern"C"修饰符也可能应用于块中的多个函数声明。</li><li>在模板声明中， extern 指定模板已在其他位置实例化。 extern告知编译器它可以重复使用另一个实例化，而不是在当前位置创建新实例。有关此用法 extern的详细信息，请参阅 显式实例化。</li></ul></li></ul><h2 id="extern的使用"><code>Extern</code>的使用</h2><ul><li>小案例</li><li><code>extern var</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">头文件</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="comment">/// extern 变量与函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTERN_TEST_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">cpp 文件</span><br><span class="line">--- </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> extern_text_var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">使用导出变量</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printExternVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;current: &quot;</span> &lt;&lt; extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    extern_text_var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;do update: &quot;</span> &lt;&lt;extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">main.cpp</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printExternVar();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;add result: &quot;</span>&lt;&lt;add(<span class="number">10</span>, <span class="number">30</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">输出</span><br><span class="line">---</span><br><span class="line">current: <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span> update: <span class="number">200</span></span><br><span class="line">add result: <span class="number">40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;cpp&lt;/code&gt;关键词之&lt;code&gt;extern&lt;/code&gt;...
&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/categories/cpp/"/>
    
    
    <category term="key words" scheme="https://blog.ranbun.com/tags/key-words/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL parallel  projection graphics do not scale with the window</title>
    <link href="https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/"/>
    <id>https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/</id>
    <published>2022-08-04T02:05:58.000Z</published>
    <updated>2022-08-21T15:34:56.762Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>平行投影窗口缩放导致图形变形...</p><span id="more"></span><center><h2>OpenGL parallel projection graphics do not scale with the window</h2></center><h3 id="实现步骤">实现步骤</h3><ul><li>重写窗口的<code>resize</code>事件<ul><li>计算投影的范围</li></ul></li><li>更新投影矩阵</li><li><code>drawcull</code></li></ul><h4 id="resizegl"><code>resizeGL</code></h4><ul><li>我们最初计算一个比例：<ul><li>关于窗口的<code>size</code>和投影的范围的<ul><li>使用<code>left, right</code>计算一个<code>spanx(right - left)</code>,<code>top, bottom</code>计算<code>spany(top - bottom)</code>,分别与窗口的宽高比较 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ratioW = w / spanx;</span><br><span class="line"><span class="keyword">auto</span> ratioH = h / spany; </span><br><span class="line"><span class="comment">// 取最小的一个 </span></span><br><span class="line"><span class="keyword">auto</span> ratio = <span class="built_in">std</span>::min(ratioW,ratioH);</span><br></pre></td></tr></table></figure></li></ul></li><li>每次窗口缩放，我们就使用上述的范围计算新的<code>left,right,bottom,top</code><ul><li>只要投影的范围没有发生改变我们便不计算新的<code>ratio</code></li></ul></li></ul></li><li>计算新的<code>left,right,bottom,top</code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpenGLWidget::resizeGL</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line"></span><br><span class="line">    left = - w / ratio;</span><br><span class="line">    right = <span class="built_in">abs</span>(left);</span><br><span class="line">    bottom = -h / ratio;</span><br><span class="line">    top = <span class="built_in">abs</span>(bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新投影矩阵">更新投影矩阵</h4><ul><li>update<ul><li>关于<code>zNear &amp; zFar</code>投影当二维平面时候，并未使用这两个参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projMat.ortho(left,right,bottom,top,<span class="number">0.1f</span>,<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="更新绘制的场景">更新绘制的场景</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shaderProgram.bind(); </span><br><span class="line">shaderProgram-&gt;setUniformValue(<span class="string">&quot;projectionMatrix&quot;</span>, projMat); </span><br><span class="line">glDrawArray()</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;平行投影窗口缩放导致图形变形...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Move Scene</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/</id>
    <published>2022-08-03T13:05:59.000Z</published>
    <updated>2022-08-21T15:34:56.758Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>OpenGL</code>场景移动...</p><span id="more"></span><center><h1>OpenGL Move Scene - 平面上移动</h1></center><ul><li>我们考虑一个简单的平面的移动<ul><li>某个维度为 <code>0</code>,我们只需要在某个平面上移动</li></ul></li></ul><h2 id="计算移动的方向">1. 计算移动的方向</h2><ul><li>在此之前对于相机的概念，希望您是熟悉的</li><li>虽然在<code>OpenGL</code>中本身并没有相机的概念<ul><li><code>eye</code> - <code>point</code></li><li><code>center</code> - <code>point</code></li><li><code>up</code> - <code>vector</code></li></ul></li></ul><h3 id="计算相机的朝向">计算相机的朝向</h3><ul><li>右方向：<span class="math inline">\(\vec{front} = center -eye\)</span></li></ul><h3 id="计算相机的右方向">计算相机的右方向</h3><ul><li><span class="math inline">\(\vec{right} = \vec{front} \times\vec{up}\)</span></li><li>记得将向量<spanclass="math inline">\(\vec{right}\)</span>归一化处理</li></ul><h2 id="鼠标的移动">2. 鼠标的移动</h2><ul><li>规定使用鼠标右键平移场景</li><li>我们使用<code>Qt</code>的鼠标事件<ul><li>在<code>x</code>方向上，两次记录的位置相减携带了移动的方向</li><li>在<code>y</code>方向上，<code>Qt</code>窗口的原点与<code>OpenGL</code>的窗口存在差别，需要做额外的处理- 反向</li></ul></li></ul><h3 id="当右键按下我们记录当前的鼠标的坐标">1.当右键按下我们记录当前的鼠标的坐标</h3><h3 id="触发移动事件">2. 触发移动事件</h3><ul><li>此处每一次出发移动我们将计算一次场景的移动<ul><li><code>X</code>方向 - <code>offsetX</code></li><li><code>Y</code>方向 - <code>offsetY</code></li></ul></li><li>更新我们记录的上一次的鼠标的位置</li></ul><h2 id="移动场景">移动场景</h2><ul><li>将这个移动映射成为数据的比例，作为移动方向的系数，作用到<code>eye</code>&amp;<code>center</code>,重新计算视图矩阵，更新场景 ### 计算新的 <code>eye</code> &amp;<code>center</code></li><li>计算沿着<span class="math inline">\(\vec{right}\)</span> &amp; <spanclass="math inline">\(\vec{up}\)</span>方向的移动的距离</li><li>获取窗口的宽高为 <code>w&amp;h</code></li><li>在投影矩阵中 <span class="math inline">\(right - left =spanX\)</span> &amp; <span class="math inline">\(top - bottom =spanY\)</span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">offsetX / w * spanX = disX;</span><br><span class="line">offsetY / h * spanY = disY;</span><br><span class="line"></span><br><span class="line">eye += right * disX + up *  disY;</span><br><span class="line">center += right * disX + up *  disY;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新视图矩阵repaint">更新视图矩阵&amp;<code>repaint</code></h2><ul><li><code>ViewMat.lookAt(eye,center,up)</code></li><li><code>repaint()</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;OpenGL&lt;/code&gt;场景移动...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Scene ZoomIn &amp; ZoomOut</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/</id>
    <published>2022-08-03T13:01:52.000Z</published>
    <updated>2022-08-21T15:34:56.760Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>场景缩放...</p><span id="more"></span><!-- # `OpenGL Scene ZoomIn & ZoomOut` --><center><h1>OpenGL的缩放</h1></center><h2 id="about">About</h2><h3 id="直接缩放场景">1. 直接缩放场景</h3><h4 id="实现思路">1. 实现思路</h4><ul><li>通过模型矩阵修改场景</li></ul><h3 id="修改投影矩阵">2. 修改投影矩阵</h3><h4 id="实现思路-1">1. 实现思路</h4><ul><li>获取鼠标滚轮的变化(这个改变是带方向的向上获取一个正值,向下获取的是一个负值)</li><li>将获取的这个值映射到和投影变换参数上</li><li>修改投影矩阵</li><li>重新绘制,你将获得缩放后的场景</li></ul><p style="color:red">在我的实现中采用的是第二种方式</p><h2 id="缩放的实现">缩放的实现</h2><h3 id="获取滚轮旋转角度">1. 获取滚轮旋转角度</h3><p>我是用的是<code>Qt</code>的<code>OpenGL</code>,可以直接重写窗口的一些事件，比起使用<code>glfw</code>等方式，比起它们注册回调的方式可能相对方便一些。</p><h4 id="qt的滚轮事件">Qt的滚轮事件</h4><h5 id="qwheelevent"><code>QWheelEvent</code></h5><ul><li>在出发滚轮事件之后，我们通过一个<code>QWheelEvent</code>对象获取我们需要的关于滚轮的信息</li></ul><div><p>  Wheel events are sent to the widget under the mouse cursor, but ifthat widget does not handle the event they are sent to the focus widget.Wheel events are generated for both mouse wheels and trackpad scrollgestures. There are two ways to read the wheel event delta:<code>angleDelta()</code> returns the deltas in wheel degrees. Thesevalues are always provided. <code>pixelDelta()</code> returns the deltasin screen pixels.</p><p>  上述部分来自<code>Qt</code>官方文档,我们有两种方法可以获取鼠标滚轮的增量(正负代表方向)，<code>angleDelta()</code>，<code>pixelDelta()</code>.</p></div><h6><code>QPoint QWheelEvent::angleDelta() const</code></h6><p><p>  Returns the relative amount that the wheel was rotated, in eighthsof a degree. A positive value indicates that the wheel was rotatedforwards away from the user; a negative value indicates that the wheelwas rotated backwards toward the user. angleDelta().y() provides theangle through which the common vertical mouse wheel was rotated sincethe previous event. angleDelta().x() provides the angle through whichthe horizontal mouse wheel was rotated, if the mouse has a horizontalwheel; otherwise it stays at zero. Some mice allow the user to tilt thewheel to perform horizontal scrolling, and some touchpads support ahorizontal scrolling gesture; that will also appear inangleDelta().x().</p>  Most mouse types work in steps of 15 degrees, in which case the deltavalue is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.</p><ul><li>正值表示滚轮向上,远离用户. 负值向下,靠近用户.</li><li>此函数将返回两个方向上的滚动<ul><li><font color=red>我们此处使用是垂直方向的滚动的角度 </font></li></ul></li><li>滚轮每次触发滚动的的角度是<spanclass="math inline">\(15^\circ\left(delta\right)\)</span>，但是实际的返回值是$delta = 120 $</li><li>返回的值应以 $ 1/8 $ 为单位:<ul><li><span class="math inline">\(angleDelta() / 8\)</span>得到鼠标实际滚动的度数</li></ul></li><li><code style="color:red">通过上面步骤便可以获取滚轮实际旋转的角度</code></li></ul><h3 id="将滚轮旋转角度映射到投影矩阵">2.将滚轮旋转角度映射到投影矩阵</h3><ul><li><span class="math inline">\(ratio = delta/360^\circ\)</span></li><li>使用这个值去修改投影矩阵的参数</li><li>我们使用的是平行投影的方式<ul><li><code>left</code></li><li><code>rght</code></li><li><code>bottom</code></li><li><code>top</code></li></ul></li></ul><h3 id="更新投影矩阵">3. 更新投影矩阵</h3><ul><li>在此之前 请将矩阵设置为单位矩阵 然后重新计算投影矩阵</li><li>更新投影矩阵</li><li>调用强制重新绘制(<code>Qt</code>) - <code>repaint()</code></li><li>你将得到放大后的场景</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;场景缩放...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Qt OpenGL Antialiasing-MSAA</title>
    <link href="https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/"/>
    <id>https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/</id>
    <published>2022-08-02T09:16:16.000Z</published>
    <updated>2022-08-21T15:34:56.768Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>MSAA算法介绍...</p><span id="more"></span><h2 id="qt-opengl-antialiasing---msaa">Qt OpenGL Antialiasing -MSAA</h2><h3 id="锯齿是图形绘制中常见的问题">锯齿是图形绘制中常见的问题</h3><ul><li>这是一个采样不足然后信号丢失导致的问题</li><li>经过各位前辈们的其扑后继的研究，终究是有了看起来不错的解决方案</li><li>本文中我们采用一种名为<code>MSAA</code>的抗锯齿的技术</li></ul><h3 id="msaa"><code>MSAA</code></h3><p>  超级采样抗锯齿（Super SamplingAnti-Aliasing）的原理是把当前分辨率成倍提高,然后再把画缩放到当前的显示器上。这样的做法实际上就是在显示尺寸不变的情况提高分辨率，让单个像素变得极小，这样就能够大幅减轻画面的锯齿感了。不过是由于对整个显示画面的放大，因此它消耗的显示资源也是非常大的。</p><h3 id="qt-openggl-的-msaa"><code>Qt OpengGL</code> 的<code>MSAA</code></h3><h4 id="走样展示">走样展示</h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing.png"title="线的走样" alt="走样" /><figcaption aria-hidden="true">走样</figcaption></figure><h4id="开启qtopenglwidget的msaa">开启<code>QtOpenGLWidget</code>的<code>MSAA</code></h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing-MSAA.png"title="MSAA" alt="MSAA" /><figcaption aria-hidden="true">MSAA</figcaption></figure><h4id="如何开启qtopengl的msaa">如何开启<code>QtOpenGL</code>的<code>MSAA</code></h4><ul><li><p><code>Qt</code>有他自己的关于<code>OpenGL</code>的封装，我们使用的<code>Qt</code>的关于<code>OpenGL</code>封装</p></li><li><p>在创建<code>QOpenGLWidget</code>窗口时，在构造函数中添加如下代码：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSurfaceFormat format;</span><br><span class="line">format.setSamples(<span class="number">4</span>);</span><br><span class="line">setFormat(format);</span><br></pre></td></tr></table></figure></p><ul><li><code>setFormat</code>是窗口<code>QOpenGLWidget</code>的函数，在构造函数中使用，会给后面所有依赖的小部件设置一个默认的<code>format</code>，对于后面的小部件(窗口)，如果不做格式的修改，将会使用在构造函数中调用<code>setFormat</code>函数设置的格式作为默认格式</li></ul></li></ul><h4 id="失败的尝试">失败的尝试</h4><p>  我尝试，单独修改<code>QopenGLContext</code>的<code>QSurfaceFormat</code>,前面的部分是成功，我获取了当前窗口的<code>QopenGLContext</code>,修改了<code>QSurfaceFormat</code>，向其中添加了启用<code>MSAA</code>的代码.然后调用<code>QopenGLContext</code>的<code>create</code>函数，企图重新创建一个<code>QopenGLContext</code>，但是失败了，在初始化<code>QopenGLFunction</code>失败，<p style="color:red">暂时不知道原因,目测可能需要重新将当前窗口的绑定到重新创建后的上下文，以及调用这个上下文的<code>OpenGL</code>函数</p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;MSAA算法介绍...
&lt;/p&gt;</summary>
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/works/SCUU/"/>
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/works/SCUU/Computer-Graph/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
    <category term="Qt" scheme="https://blog.ranbun.com/tags/Qt/"/>
    
  </entry>
  
</feed>
