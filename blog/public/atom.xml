<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RanBun&#39;s Blog</title>
  
  <subtitle>如你所见,如我所见</subtitle>
  <link href="https://blog.ranbun.com/atom.xml" rel="self"/>
  
  <link href="https://blog.ranbun.com/"/>
  <updated>2022-08-21T05:57:14.356Z</updated>
  <id>https://blog.ranbun.com/</id>
  
  <author>
    <name>RanBun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:58.000Z</published>
    <updated>2022-08-21T05:57:14.356Z</updated>
    
    <content type="html"><![CDATA[<p>  设计模式之单例模式...</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  设计模式之单例模式...
&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-19T13:01:44.000Z</published>
    <updated>2022-08-21T05:57:17.220Z</updated>
    
    <content type="html"><![CDATA[<p>  设计模式之工厂模式...</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  设计模式之工厂模式...
&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>多重继承</title>
    <link href="https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <id>https://blog.ranbun.com/2022/08/19/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</id>
    <published>2022-08-19T12:58:37.000Z</published>
    <updated>2022-08-21T05:56:55.762Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>Cpp</code>,中关于继承的一点问题...</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;Cpp&lt;/code&gt;,中关于继承的一点问题...
&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>View/Camera Transformation</title>
    <link href="https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/"/>
    <id>https://blog.ranbun.com/2022/08/19/View-Camera-Transformation/</id>
    <published>2022-08-19T12:39:56.000Z</published>
    <updated>2022-08-21T05:55:51.741Z</updated>
    
    <content type="html"><![CDATA[<p>  计算机图形学的试图变换过程的解析...</p><span id="more"></span><h1 id="视图变换">视图变换</h1><ul><li>视图变换是将所有世界空间中的点，变换到视图空间下的操作<ul><li>这种变换，我们通过矩阵可以轻易的完成，但是我们首先需要计算一个描述这种变换的矩阵</li></ul></li><li>在一般的实现中，我们将视图变换的过程抽象出了一个相机的概念<ul><li>本身而言在图形学中是没有相机这个概念的</li></ul></li></ul><h2 id="视图变换-变换过程">视图变换-变换过程</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  计算机图形学的试图变换过程的解析...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    
    <category term="Base" scheme="https://blog.ranbun.com/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>起伏的2022(上)</title>
    <link href="https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ranbun.com/2022/08/14/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-14T09:22:51.000Z</published>
    <updated>2022-08-21T05:28:31.663Z</updated>
    
    <content type="html"><![CDATA[<center><h1>关于我的2022(上)</h1></center><p>  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......</p><span id="more"></span><h2 id="上一览">2022上，一览</h2><ul><li>辞掉了原来的工作<ul><li>离开了北京</li><li>又去见了一些人</li></ul></li><li>来了成都</li><li>给自己翻篇</li><li>遇到了她<ul><li>准备一起写我们的故事</li></ul></li></ul><h3 id="离开我不喜欢的北京">离开我不喜欢的北京</h3><h4 id="辞职那点事">辞职那点事</h4><p>  其实之前也算是成都的一家公司，只是有些草率，我的入职合同是通过快递签订的。除了和我一起出差的同事，我并未见过任何一个公司的同事。我以为我的入职之后会是在成都度过，但是事实总是不能遂了人意，我在一直呆在北京，算是出差中，可能是呆的时间有点太长了，我决定要离开了。于是在去年年底的最后一个月开始重新找工作了，依旧是在成都，重新觅一份新的工作，阴差阳错，来了现在的公司，年前的2月，我们结束我们的年假，决定前往北京进行工作最后的工作交接。我深知那一次的离开，我可能再也不会再来北京，离开前总是需要见一些该见的人，就当作是最后的告别。</p><h4 id="往后不能再见的朋友">往后不能再见的朋友</h4><p>  记得大一的第一学期的前半程是稍微有些无聊的，我去往那个和我期待中的样子差距颇大的地方，我在颓废中度过了大一第一学期的前半程，可能是接受了现实，我决定改变一下这个现状，于是迈出了我成为程序员得第一步，我找了个学生组织，参与进去。可能是缘分，我遇到好些个有意思的人，在这之中有我的好朋友，也有带我入行的学长，毕业后，学长去了北京。虽然在我本来的计划中，我大概会去北京的，但事情总是不得遂人意，阴差阳错，我没能去了。借此机会，见了这位阔别已久的老朋友，一起聊到凌晨，大家总有各自的生活，所以分别，多少没那么不舍。我相信缘分会拉着我们一次又一次的相遇。</p><p>  那位没能和我们一起拍毕业照的小伙伴，也将见证我的离去，我们是大学同学，男孩子性格的她，和我们最是合得来，一起吃了个饭，记得是我此前没有尝试过的港式，没有什么不舍，惟愿。</p><h3 id="终来成都">终来成都</h3><h4 id="新工作">新工作</h4><ul><li>还是那个工作，只是换了环境和一波同事，对我来说,差别不大。来时是三月中旬，成都总是那么出人意料，我来时给予我最大的温暖，$28^o $的天气，只有感谢，未能有更多言语。</li><li>来后三个月的感叹，<code>我好菜呀！！！！！！！</code></li></ul><h3 id="给自己翻篇">给自己翻篇</h3><ul><li>经历变得丰富，成长颇多，感谢！</li><li>毕业两年！！！！！！！！！！！！！！！！！！！！！！！！！</li></ul><h3 id="遇到她">遇到她</h3><ul><li>如果我没有离开北京，如果我没有来这里，所以一切都是刚好的样子，感谢缘分让我们相遇。我们很合拍，无论什么。</li><li>所以想写新的故事，就我和她，在这个城市的故事。<ul><li>所以感谢会会的早餐与陪伴</li></ul></li></ul><h3 id="over">Over</h3><ul><li>2022的上半年到我们在一起结束，这是我2022年最开心的时候，感谢缘分，感谢相遇！</li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;
&lt;h1&gt;
关于我的2022(上)
&lt;/h1&gt;
&lt;/center&gt;
&lt;p&gt;
  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......
&lt;/p&gt;</summary>
    
    
    
    <category term="bun" scheme="https://blog.ranbun.com/categories/bun/"/>
    
    <category term="life" scheme="https://blog.ranbun.com/categories/bun/life/"/>
    
    
    <category term="mylife" scheme="https://blog.ranbun.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>Cplusplus key words - extern</title>
    <link href="https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/"/>
    <id>https://blog.ranbun.com/2022/08/08/Cplusplus-key-words-extern/</id>
    <published>2022-08-08T03:41:35.000Z</published>
    <updated>2022-08-21T05:57:37.929Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>cpp</code>关键词之<code>extern</code>...</p><span id="more"></span><center><h2><code>extern</code>关键字</h2></center><h2 id="extern-初解"><code>Extern</code> 初解</h2><ul><li>关于<code>extern</code>关键字可以应用于全局变量、函数或模板声明。它指定符号具有外部链接性质。<ul><li>在非const 全局变量声明中， extern指定变量或函数在另一个转换单元中定义。extern必须在定义变量的所有文件中应用该变量。</li><li>const在变量声明中，它指定变量具有 external 链接。extern必须应用于所有文件中的所有声明。 默认情况下， (全局 const变量具有内部链接。)</li><li>extern "C" 指定函数在别处定义并使用 C 语言调用约定。 extern"C"修饰符也可能应用于块中的多个函数声明。</li><li>在模板声明中， extern 指定模板已在其他位置实例化。 extern告知编译器它可以重复使用另一个实例化，而不是在当前位置创建新实例。有关此用法 extern的详细信息，请参阅 显式实例化。</li></ul></li></ul><h2 id="extern的使用"><code>Extern</code>的使用</h2><ul><li>小案例</li><li><code>extern var</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">头文件</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="comment">/// extern 变量与函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXTERN_TEST_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">cpp 文件</span><br><span class="line">--- </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> extern_text_var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">使用导出变量</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> extern_text_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printExternVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;current: &quot;</span> &lt;&lt; extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    extern_text_var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;do update: &quot;</span> &lt;&lt;extern_text_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">main.cpp</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TestExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printExternVar();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;add result: &quot;</span>&lt;&lt;add(<span class="number">10</span>, <span class="number">30</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">输出</span><br><span class="line">---</span><br><span class="line">current: <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span> update: <span class="number">200</span></span><br><span class="line">add result: <span class="number">40</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;cpp&lt;/code&gt;关键词之&lt;code&gt;extern&lt;/code&gt;...
&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/categories/cpp/"/>
    
    
    <category term="key words" scheme="https://blog.ranbun.com/tags/key-words/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL parallel  projection graphics do not scale with the window</title>
    <link href="https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/"/>
    <id>https://blog.ranbun.com/2022/08/04/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/</id>
    <published>2022-08-04T02:05:58.000Z</published>
    <updated>2022-08-21T05:49:00.598Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>平行投影窗口缩放导致图形变形...</p><span id="more"></span><center><h2>OpenGL parallel projection graphics do not scale with the window</h2></center><h3 id="实现步骤">实现步骤</h3><ul><li>重写窗口的<code>resize</code>事件<ul><li>计算投影的范围</li></ul></li><li>更新投影矩阵</li><li><code>drawcull</code></li></ul><h4 id="resizegl"><code>resizeGL</code></h4><ul><li>我们最初计算一个比例：<ul><li>关于窗口的<code>size</code>和投影的范围的<ul><li>使用<code>left, right</code>计算一个<code>spanx(right - left)</code>,<code>top, bottom</code>计算<code>spany(top - bottom)</code>,分别与窗口的宽高比较 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ratioW = w / spanx;</span><br><span class="line"><span class="keyword">auto</span> ratioH = h / spany; </span><br><span class="line"><span class="comment">// 取最小的一个 </span></span><br><span class="line"><span class="keyword">auto</span> ratio = <span class="built_in">std</span>::min(ratioW,ratioH);</span><br></pre></td></tr></table></figure></li></ul></li><li>每次窗口缩放，我们就使用上述的范围计算新的<code>left,right,bottom,top</code><ul><li>只要投影的范围没有发生改变我们便不计算新的<code>ratio</code></li></ul></li></ul></li><li>计算新的<code>left,right,bottom,top</code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpenGLWidget::resizeGL</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line"></span><br><span class="line">    left = - w / ratio;</span><br><span class="line">    right = <span class="built_in">abs</span>(left);</span><br><span class="line">    bottom = -h / ratio;</span><br><span class="line">    top = <span class="built_in">abs</span>(bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更新投影矩阵">更新投影矩阵</h4><ul><li>update<ul><li>关于<code>zNear &amp; zFar</code>投影当二维平面时候，并未使用这两个参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projMat.ortho(left,right,bottom,top,<span class="number">0.1f</span>,<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="更新绘制的场景">更新绘制的场景</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shaderProgram.bind(); </span><br><span class="line">shaderProgram-&gt;setUniformValue(<span class="string">&quot;projectionMatrix&quot;</span>, projMat); </span><br><span class="line">glDrawArray()</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;平行投影窗口缩放导致图形变形...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Move Scene</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Move-Scene/</id>
    <published>2022-08-03T13:05:59.000Z</published>
    <updated>2022-08-21T05:43:39.211Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>OpenGL</code>场景移动...</p><span id="more"></span><center><h1>OpenGL Move Scene - 平面上移动</h1></center><ul><li>我们考虑一个简单的平面的移动<ul><li>某个维度为 <code>0</code>,我们只需要在某个平面上移动</li></ul></li></ul><h2 id="计算移动的方向">1. 计算移动的方向</h2><ul><li>在此之前对于相机的概念，希望您是熟悉的</li><li>虽然在<code>OpenGL</code>中本身并没有相机的概念<ul><li><code>eye</code> - <code>point</code></li><li><code>center</code> - <code>point</code></li><li><code>up</code> - <code>vector</code></li></ul></li></ul><h3 id="计算相机的朝向">计算相机的朝向</h3><ul><li>右方向：<span class="math inline">\(\vec{front} = center -eye\)</span></li></ul><h3 id="计算相机的右方向">计算相机的右方向</h3><ul><li><span class="math inline">\(\vec{right} = \vec{front} \times\vec{up}\)</span></li><li>记得将向量<spanclass="math inline">\(\vec{right}\)</span>归一化处理</li></ul><h2 id="鼠标的移动">2. 鼠标的移动</h2><ul><li>规定使用鼠标右键平移场景</li><li>我们使用<code>Qt</code>的鼠标事件<ul><li>在<code>x</code>方向上，两次记录的位置相减携带了移动的方向</li><li>在<code>y</code>方向上，<code>Qt</code>窗口的原点与<code>OpenGL</code>的窗口存在差别，需要做额外的处理- 反向</li></ul></li></ul><h3 id="当右键按下我们记录当前的鼠标的坐标">1.当右键按下我们记录当前的鼠标的坐标</h3><h3 id="触发移动事件">2. 触发移动事件</h3><ul><li>此处每一次出发移动我们将计算一次场景的移动<ul><li><code>X</code>方向 - <code>offsetX</code></li><li><code>Y</code>方向 - <code>offsetY</code></li></ul></li><li>更新我们记录的上一次的鼠标的位置</li></ul><h2 id="移动场景">移动场景</h2><ul><li>将这个移动映射成为数据的比例，作为移动方向的系数，作用到<code>eye</code>&amp;<code>center</code>,重新计算视图矩阵，更新场景 ### 计算新的 <code>eye</code> &amp;<code>center</code></li><li>计算沿着<span class="math inline">\(\vec{right}\)</span> &amp; <spanclass="math inline">\(\vec{up}\)</span>方向的移动的距离</li><li>获取窗口的宽高为 <code>w&amp;h</code></li><li>在投影矩阵中 <span class="math inline">\(right - left =spanX\)</span> &amp; <span class="math inline">\(top - bottom =spanY\)</span> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">offsetX / w * spanX = disX;</span><br><span class="line">offsetY / h * spanY = disY;</span><br><span class="line"></span><br><span class="line">eye += right * disX + up *  disY;</span><br><span class="line">center += right * disX + up *  disY;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新视图矩阵repaint">更新视图矩阵&amp;<code>repaint</code></h2><ul><li><code>ViewMat.lookAt(eye,center,up)</code></li><li><code>repaint()</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;OpenGL&lt;/code&gt;场景移动...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Scene ZoomIn &amp; ZoomOut</title>
    <link href="https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/"/>
    <id>https://blog.ranbun.com/2022/08/03/OpenGL-Scene-ZoomIn-ZoomOut/</id>
    <published>2022-08-03T13:01:52.000Z</published>
    <updated>2022-08-21T05:49:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>场景缩放...</p><span id="more"></span><!-- # `OpenGL Scene ZoomIn & ZoomOut` --><center><h1>OpenGL的缩放</h1></center><h2 id="about">About</h2><h3 id="直接缩放场景">1. 直接缩放场景</h3><h4 id="实现思路">1. 实现思路</h4><ul><li>通过模型矩阵修改场景</li></ul><h3 id="修改投影矩阵">2. 修改投影矩阵</h3><h4 id="实现思路-1">1. 实现思路</h4><ul><li>获取鼠标滚轮的变化(这个改变是带方向的向上获取一个正值,向下获取的是一个负值)</li><li>将获取的这个值映射到和投影变换参数上</li><li>修改投影矩阵</li><li>重新绘制,你将获得缩放后的场景</li></ul><p style="color:red">在我的实现中采用的是第二种方式</p><h2 id="缩放的实现">缩放的实现</h2><h3 id="获取滚轮旋转角度">1. 获取滚轮旋转角度</h3><p>我是用的是<code>Qt</code>的<code>OpenGL</code>,可以直接重写窗口的一些事件，比起使用<code>glfw</code>等方式，比起它们注册回调的方式可能相对方便一些。</p><h4 id="qt的滚轮事件">Qt的滚轮事件</h4><h5 id="qwheelevent"><code>QWheelEvent</code></h5><ul><li>在出发滚轮事件之后，我们通过一个<code>QWheelEvent</code>对象获取我们需要的关于滚轮的信息</li></ul><div><p>  Wheel events are sent to the widget under the mouse cursor, but ifthat widget does not handle the event they are sent to the focus widget.Wheel events are generated for both mouse wheels and trackpad scrollgestures. There are two ways to read the wheel event delta:<code>angleDelta()</code> returns the deltas in wheel degrees. Thesevalues are always provided. <code>pixelDelta()</code> returns the deltasin screen pixels.</p><p>  上述部分来自<code>Qt</code>官方文档,我们有两种方法可以获取鼠标滚轮的增量(正负代表方向)，<code>angleDelta()</code>，<code>pixelDelta()</code>.</p></div><h6><code>QPoint QWheelEvent::angleDelta() const</code></h6><p><p>  Returns the relative amount that the wheel was rotated, in eighthsof a degree. A positive value indicates that the wheel was rotatedforwards away from the user; a negative value indicates that the wheelwas rotated backwards toward the user. angleDelta().y() provides theangle through which the common vertical mouse wheel was rotated sincethe previous event. angleDelta().x() provides the angle through whichthe horizontal mouse wheel was rotated, if the mouse has a horizontalwheel; otherwise it stays at zero. Some mice allow the user to tilt thewheel to perform horizontal scrolling, and some touchpads support ahorizontal scrolling gesture; that will also appear inangleDelta().x().</p>  Most mouse types work in steps of 15 degrees, in which case the deltavalue is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.</p><ul><li>正值表示滚轮向上,远离用户. 负值向下,靠近用户.</li><li>此函数将返回两个方向上的滚动<ul><li><font color=red>我们此处使用是垂直方向的滚动的角度 </font></li></ul></li><li>滚轮每次触发滚动的的角度是<spanclass="math inline">\(15^\circ\left(delta\right)\)</span>，但是实际的返回值是$delta = 120 $</li><li>返回的值应以 $ 1/8 $ 为单位:<ul><li><span class="math inline">\(angleDelta() / 8\)</span>得到鼠标实际滚动的度数</li></ul></li><li><code style="color:red">通过上面步骤便可以获取滚轮实际旋转的角度</code></li></ul><h3 id="将滚轮旋转角度映射到投影矩阵">2.将滚轮旋转角度映射到投影矩阵</h3><ul><li><span class="math inline">\(ratio = delta/360^\circ\)</span></li><li>使用这个值去修改投影矩阵的参数</li><li>我们使用的是平行投影的方式<ul><li><code>left</code></li><li><code>rght</code></li><li><code>bottom</code></li><li><code>top</code></li></ul></li></ul><h3 id="更新投影矩阵">3. 更新投影矩阵</h3><ul><li>在此之前 请将矩阵设置为单位矩阵 然后重新计算投影矩阵</li><li>更新投影矩阵</li><li>调用强制重新绘制(<code>Qt</code>) - <code>repaint()</code></li><li>你将得到放大后的场景</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;场景缩放...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/SCUU/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Qt OpenGL Antialiasing-MSAA</title>
    <link href="https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/"/>
    <id>https://blog.ranbun.com/2022/08/02/Qt-OpenGL-Antialiasing-MSAA/</id>
    <published>2022-08-02T09:16:16.000Z</published>
    <updated>2022-08-21T05:53:02.400Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>QtOpenGL</code>MSAA算法介绍...</p><span id="more"></span><h2 id="qt-opengl-antialiasing---msaa">Qt OpenGL Antialiasing -MSAA</h2><h3 id="锯齿是图形绘制中常见的问题">锯齿是图形绘制中常见的问题</h3><ul><li>这是一个采样不足然后信号丢失导致的问题</li><li>经过各位前辈们的其扑后继的研究，终究是有了看起来不错的解决方案</li><li>本文中我们采用一种名为<code>MSAA</code>的抗锯齿的技术</li></ul><h3 id="msaa"><code>MSAA</code></h3><p>  超级采样抗锯齿（Super SamplingAnti-Aliasing）的原理是把当前分辨率成倍提高,然后再把画缩放到当前的显示器上。这样的做法实际上就是在显示尺寸不变的情况提高分辨率，让单个像素变得极小，这样就能够大幅减轻画面的锯齿感了。不过是由于对整个显示画面的放大，因此它消耗的显示资源也是非常大的。</p><h3 id="qt-openggl-的-msaa"><code>Qt OpengGL</code> 的<code>MSAA</code></h3><h4 id="走样展示">走样展示</h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing.png"title="线的走样" alt="走样" /><figcaption aria-hidden="true">走样</figcaption></figure><h4id="开启qtopenglwidget的msaa">开启<code>QtOpenGLWidget</code>的<code>MSAA</code></h4><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing-MSAA.png"title="MSAA" alt="MSAA" /><figcaption aria-hidden="true">MSAA</figcaption></figure><h4id="如何开启qtopengl的msaa">如何开启<code>QtOpenGL</code>的<code>MSAA</code></h4><ul><li><p><code>Qt</code>有他自己的关于<code>OpenGL</code>的封装，我们使用的<code>Qt</code>的关于<code>OpenGL</code>封装</p></li><li><p>在创建<code>QOpenGLWidget</code>窗口时，在构造函数中添加如下代码：</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSurfaceFormat format;</span><br><span class="line">format.setSamples(<span class="number">4</span>);</span><br><span class="line">setFormat(format);</span><br></pre></td></tr></table></figure></p><ul><li><code>setFormat</code>是窗口<code>QOpenGLWidget</code>的函数，在构造函数中使用，会给后面所有依赖的小部件设置一个默认的<code>format</code>，对于后面的小部件(窗口)，如果不做格式的修改，将会使用在构造函数中调用<code>setFormat</code>函数设置的格式作为默认格式</li></ul></li></ul><h4 id="失败的尝试">失败的尝试</h4><p>  我尝试，单独修改<code>QopenGLContext</code>的<code>QSurfaceFormat</code>,前面的部分是成功，我获取了当前窗口的<code>QopenGLContext</code>,修改了<code>QSurfaceFormat</code>，向其中添加了启用<code>MSAA</code>的代码.然后调用<code>QopenGLContext</code>的<code>create</code>函数，企图重新创建一个<code>QopenGLContext</code>，但是失败了，在初始化<code>QopenGLFunction</code>失败，<p style="color:red">暂时不知道原因,目测可能需要重新将当前窗口的绑定到重新创建后的上下文，以及调用这个上下文的<code>OpenGL</code>函数</p></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;QtOpenGL&lt;/code&gt;MSAA算法介绍...
&lt;/p&gt;</summary>
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="SCUU" scheme="https://blog.ranbun.com/categories/works/SCUU/"/>
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/works/SCUU/Computer-Graph/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
    <category term="Qt" scheme="https://blog.ranbun.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Smart pointer 简介</title>
    <link href="https://blog.ranbun.com/2022/08/01/Smartpointer/"/>
    <id>https://blog.ranbun.com/2022/08/01/Smartpointer/</id>
    <published>2022-08-01T11:53:40.000Z</published>
    <updated>2022-08-21T05:54:37.107Z</updated>
    
    <content type="html"><![CDATA[<p>  智能指针...</p><span id="more"></span><h1 id="smart-pointer">Smart Pointer</h1><p style="color:red">  智能指针是行为类似于指针的类对象，但这种对象还有其他功能。</p><ul><li>下面我将将会分别介绍几种不同的智能指针</li></ul><h3 id="auto_ptr"><code>auto_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++98</code>时被引入</li><li>已经在<code>C++11</code>是被弃用</li><li>在<code>C++17</code>被移除</li></ul><h4 id="特点">特点</h4><ul><li><code>auto_ptr</code>没有使用引用计数，在复制构造函数和赋值构造函数中将对象所有权转移</li><li><code>auto_ptr</code>不能指向数组，因为<code>auto_ptr</code>在析构的时候只是调用<code>delete</code>,而数组应该要调用<code>delete[]</code></li><li><code>auto_ptr</code> 不能和标准容器（vector,list,map…)一起使用<ul><li>由于<code>auto_ptr</code>在复制和赋值构造中将转移所有权</li></ul></li></ul><h3 id="unique_ptr"><code>unique_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++11</code>时被引入</li><li>用于解决<code>auto_ptr</code>的拷贝问题</li></ul><h4 id="特点-1">特点</h4><ul><li>不支持拷贝操作，只能进行所有权的转移</li><li><code>std::unique_ptr</code> 通常用于管理对象的生命周期，包括：通过保证正常退出和异常退出时的删除，为处理具有动态生命周期的对象的类和函数提供异常安全性</li><li>对于自定义的类对象，支持提供自定义的删除器</li><li>常用于单线程</li><li>可以为空</li></ul><h3 id="shared_ptr"><code>shared_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code>头文件中</li><li>在<code>C++11</code>时被引入</li><li>支持拷贝和复制</li></ul><h4 id="特点-2">特点</h4><ul><li>支持拷贝和复制</li><li>对于自定义的类对象，支持提供自定义的删除器</li><li>常用于多线程</li><li>多个对象可以共享所有权</li><li>可以为空</li></ul><h3 id="weak_ptr"><code>weak_ptr</code></h3><ul><li>包含在 <code>&lt;memory&gt;</code> 头文件中</li><li>在<code>C++11</code>时被引入</li><li>它是对 <code>std::shared_ptr</code>管理的对象的非拥有引用,必须将其转换为 <code>std::shared_ptr</code>才能访问引用的对象</li></ul><h4 id="特点-3">特点</h4><ul><li>解决<code>shared_ptr</code>引起的循环引用问题</li><li>获取某个<code>shared_ptr</code>指向对象的临时所有权，在<code>shared_ptr</code>对象被销毁是可以延长此对象的生命周期</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  智能指针...
&lt;/p&gt;</summary>
    
    
    
    <category term="study" scheme="https://blog.ranbun.com/categories/study/"/>
    
    <category term="coding" scheme="https://blog.ranbun.com/categories/study/coding/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="pointer" scheme="https://blog.ranbun.com/tags/pointer/"/>
    
  </entry>
  
  <entry>
    <title>Qt Connect</title>
    <link href="https://blog.ranbun.com/2022/07/29/Qt-Signals-And-Slots/"/>
    <id>https://blog.ranbun.com/2022/07/29/Qt-Signals-And-Slots/</id>
    <published>2022-07-29T09:26:28.000Z</published>
    <updated>2022-08-21T05:53:39.827Z</updated>
    
    <content type="html"><![CDATA[<p>  <code>Qt</code>信号与槽...</p><span id="more"></span><h1 id="qt"><code>Qt</code></h1><ul><li>是非常好的用于开发软件界面的库, 当然我这样说有些狭隘,<code>Qt</code>能做的事情远不止如此</li><li>但本文我只是说一下<code>Qt</code>的信号槽机制</li></ul><h2 id="qt超级经典的信号与槽机制--signal-slot">1.<code>Qt</code>超级经典的信号与槽机制- <code>signal</code> &amp;<code>slot</code></h2><ul><li><p>示例 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Use_SignalAndSlot</span>:</span><span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">useSignalsAndSlots</span><span class="params">()</span></span>;</span><br><span class="line">slots: <span class="comment">// (槽函数可以不是slots下的函数)，可以是public or private or protected 下的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnuseSignalsAndSlots</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>class</code> 必须是继承自 <code>QObject</code></p></li><li><p>要使用<code>Qt</code>的这个机制需要在<code>Class</code>的定义处添加<code>Q_OBJECT</code>的宏定义x</p></li><li><p>定义信号是必须加上- <code>signals:</code> 前缀,且信号不需要实现只需要定义，<code>Qt</code>有自己的解析机制</p></li></ul><h3 id="信号槽的不同写法---官方介绍">1. 信号槽的不同写法 - 官方介绍</h3><h4 id="qt4"><code>Qt4</code></h4>来自官方的文档 - 使用宏包裹 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> <span class="keyword">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure><p>  Creates a connection of the given type from the signal in the senderobject to the method in the receiver object. Returns a handle to theconnection that can be used to disconnect it later.<br>   You must usethe <code> SIGNAL() </code> and <code>SLOT()</code> macros whenspecifying the signal and the method, for example:</p><ul><li><p>上面函数创建一个链接，并将这个链接作为返回值,这个返回值可以用于调用<code>disconnect</code> 断开链接</p></li><li><p>example: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QScrollBar *scrollBar = <span class="keyword">new</span> QScrollBar;</span><br><span class="line">QObject::connect(scrollBar, SIGNAL(valueChanged(<span class="keyword">int</span>)),label,  SLOT(setNum(<span class="keyword">int</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p><font color=red id="danger">友情提示：请记住这种写法，必须使用<code>SIGNAL</code>&amp;<code>SLOT</code>将对应的信号和槽函数包裹起来，并且这种方法无法检测对应的信号和槽函数是否存在</font></p></li><li><p>在创建链接的时候，对应的信号中我们只需要给出参数的类型，不需要写出具体的参数名称:</p><p><p>  This example ensures that the label always displays the currentscroll bar value. Note that the signal and slots parameters must notcontain any variable names, only the type. E.g. the following would notwork and return false:</p></p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line">QObject::connect(scrollBar, SIGNAL(valueChanged(<span class="keyword">int</span> value)),label, SLOT(setNum(<span class="keyword">int</span> value)));</span><br></pre></td></tr></table></figure></p></li><li><p>overloads - 1</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> QMetaMethod &amp;signal, <span class="keyword">const</span> QObject *receiver, <span class="keyword">const</span> QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure></p><p><p>  Creates a connection of the given type from the signal in thesender object to the method in the receiver object. Returns a handle tothe connection that can be used to disconnect it later.<br>   TheConnection handle will be invalid if it cannot create the connection,for example, the parameters were invalid. You can check if the<code>QMetaObject::Connection</code> is valid by casting it to abool.<br>   This function works in the same way as <code>connect(constQObject <em>sender, const char </em>signal, const QObject <em>receiver,const char </em>method, Qt::ConnectionType type)</code> but it uses<code>QMetaMethod</code> to specify signal and method.<br> This functionwas introduced in Qt 4.8.</p></p></li><li><p>overloads - 2</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="keyword">const</span> QObject *sender, <span class="keyword">const</span> <span class="keyword">char</span> *signal, <span class="keyword">const</span> <span class="keyword">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p><p><p>  This function overloads <code>connect()</code>.<br>   Connectssignal from the sender object to this object's method.<br>   Equivalentto <code>connect(sender, signal, <font color=red>this</font>, method,type)</code>.<br>   Every connection you make emits a signal, soduplicate connections emit two signals. You can break a connection using<code>disconnect()</code>.<br>   Note: This function is<font color=#00ff00>thread-safe</font>. <br><font color=red>  友情提示： 默认指定this作为接收者</font></p></p></li></ul><h4 id="qt5之后"><code>Qt5</code>之后</h4><ul><li><p>新的写法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction&gt; <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, <span class="keyword">const</span> QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type =  Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure></p></li><li><p><code>example</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">QObject::connect(lineEdit, &amp;QLineEdit::textChanged,label,  &amp;QLabel::setText);</span><br></pre></td></tr></table></figure></p></li><li><p>请注意信号和槽函数的参数必须是匹配的</p></li><li><p>overloads - 1</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction, <span class="keyword">typename</span> Functor&gt; </span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="keyword">const</span> QObject *sender,PointerToMemberFunction signal, Functor functor)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这是个重载的函数</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p><ul><li>Example</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void someFunction();</span><br><span class="line">QPushButton *button &#x3D; new QPushButton;</span><br><span class="line">QObject::connect(button, &amp;QPushButton::clicked, someFunction);</span><br></pre></td></tr></table></figure></p><ul><li>Lambda expressions can also be used:</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QByteArray page = ...;</span><br><span class="line">QTcpSocket *socket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line">socket-&gt;connectToHost(<span class="string">&quot;qt-project.org&quot;</span>, <span class="number">80</span>);</span><br><span class="line">QObject::connect(socket, &amp;QTcpSocket::connected, [=] () &#123;</span><br><span class="line">        socket-&gt;write(<span class="string">&quot;GET &quot;</span> + page + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><p>  The connection will automatically disconnect if the sender isdestroyed. However, you should take care that any objects used withinthe functor are still alive when the signal is emitted.<br>   Overloadedfunctions can be resolved with help of qOverload.<br>  &amp;enspNote:This function is thread-safe.<br></p></p></li><li><p>overloads - 2</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction, <span class="keyword">typename</span> Functor&gt; QMetaObject::Connection </span><br><span class="line">QObject::connect(<span class="keyword">const</span> QObject *sender, PointerToMemberFunction signal, <span class="keyword">const</span> QObject *context, </span><br><span class="line">                Functor functor, Qt::ConnectionType type = Qt::AutoConnection)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><p>  This function overloads connect().<br>   Creates a connection of agiven type from signal in sender object to functor to be placed in aspecific event loop of context, and returns a handle to theconnection.<br>   Note: <code>Qt::UniqueConnections</code> do not workfor lambdas, non-member functions and functors; they only apply toconnecting to member functions.<br>   The signal must be a functiondeclared as a signal in the header. The slot function can be anyfunction or functor that can be connected to the signal. A function canbe connected to a given signal if the signal has at least as manyargument as the slot. A functor can be connected to a signal if theyhave exactly the same number of arguments. There must exist implicitconversion between the types of the corresponding arguments in thesignal and the slot.</p></p><ul><li>Example:</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line">QPushButton *button = <span class="keyword">new</span> QPushButton;</span><br><span class="line">QObject::connect(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, someFunction, Qt::QueuedConnection);</span><br></pre></td></tr></table></figure></p><ul><li>Lambda expressions can also be used:</li></ul><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QByteArray page = ...;</span><br><span class="line">QTcpSocket *socket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line">socket-&gt;connectToHost(<span class="string">&quot;qt-project.org&quot;</span>, <span class="number">80</span>);</span><br><span class="line">QObject::connect(socket, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [=] () &#123;</span><br><span class="line">        socket-&gt;write(<span class="string">&quot;GET &quot;</span> + page + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;, Qt::AutoConnection);</span><br></pre></td></tr></table></figure></p><p><p>  The connection will automatically disconnect if the sender or thecontext is destroyed. However, you should take care that any objectsused within the functor are still alive when the signal is emitted.<br>  Overloaded functions can be resolved with help of qOverload.<br>  Note: This function is thread-safe.<br>   This function was introducedin Qt 5.2.</p></p></li></ul><h3 id="信号槽的不同写法---几种一般写法">2. 信号槽的不同写法 -几种一般写法</h3><h5id="connect的最后一个参数我们暂时使用他的默认认为"><code>connect</code>的最后一个参数，我们暂时使用他的默认认为</h5><h4 id="qt4的写法"><code>Qt4的写法</code></h4><ul><li>宏包裹 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">connect(btn, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(close()));</span><br></pre></td></tr></table></figure></li><li><a href="#danger">注意事项</a></li></ul><h4 id="qt5后的写法"><code>Qt5</code>后的写法</h4><ul><li><p>模板匹配</p><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton; </span><br><span class="line">connect(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure></p><p><p>Qt5后的官方推荐写法，编译的时候信号或槽不存在是无法编译通过的，槽的可以直接写在<code>publicor protected or private</code>下</p></p></li><li><p>lambda</p><div class="sourceCode" id="cb1"><preclass="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">connect</span><span class="op">(</span>btn<span class="op">,</span> <span class="op">&amp;</span><span class="ex">QPushButton::</span>clicked<span class="op">,</span> <span class="op">[&amp;]()</span> <span class="op">&#123;</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">-&gt;</span>close<span class="op">();</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;);</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">connect</span><span class="op">(</span>btn<span class="op">,</span> <span class="op">&amp;</span><span class="ex">QPushButton::</span>clicked<span class="op">,</span> <span class="kw">this</span><span class="op">,</span> <span class="op">[&amp;]()</span> <span class="op">&#123;</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">-&gt;</span>close<span class="op">();</span></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;);</span></span></code></pre></div><ul><li>两种写法本质上是一样的，只是说第一种默认指定接收者为<code>this</code></li><li>请保证<code>lambda</code>函数中使用成员都是活跃的，不然将是很糟糕的行为</li></ul></li></ul><h3 id="connect-最后一个参数">3. connect 最后一个参数</h3><ul><li><p><code>Qt::AutoConnection</code></p><ul><li>默认使用的参数<div><p>(Default) If the receiver lives in the thread that emits the signal,Qt::DirectConnection is used. Otherwise, Qt::QueuedConnection is used.The connection type is determined when the signal is emitted.</p><p>如果接收器位于发出信号的线程中，则使用 Qt::DirectConnection。 否则，使用Qt::QueuedConnection。 连接类型在信号发出时确定</p></div></li></ul></li><li><p><code>Qt::DirectConnection</code></p><div><p>The slot is invoked immediately when the signal is emitted. The slot isexecuted in the signalling thread.</p><p>发出信号时立即调用插槽。 该槽函数在发送者线程中执行。</p></div></li><li><p><code>Qt::QueuedConnection</code></p><div><p>The slot is invoked when control returns to the event loop of thereceiver's thread. The slot is executed in the receiver's thread.</p><p>当控制返回到接收者线程的事件循环时调用该槽,会等待当前函数执行结束，重新回到事件循环。槽函数在接收者的线程中执行.</p></div></li><li><p><code>Qt::BlockingQueuedConnection</code></p><div><p>Same as Qt::QueuedConnection, except that the signalling thread blocksuntil the slot returns. This connection must not be used if the receiverlives in the signalling thread, or else the application will deadlock.</p><p>与 Qt::QueuedConnection 相同，只是信号线程阻塞直到槽返回。如果接收者与发送者在一个线程中，则不得使用此连接，否则应用程序将死锁</p></div></li><li><p><code>Qt::UniqueConnection</code></p><div><p>This is a flag that can be combined with any one of the above connectiontypes, using a bitwise OR. When Qt::UniqueConnection is set,QObject::connect() will fail if the connection already exists (i.e. ifthe same signal is already connected to the same slot for the same pairof objects). This flag was introduced in Qt 4.6.</p><p>这是一个可以与上述任何一种连接类型结合使用的标志，使用按位或。 当设置了Qt::UniqueConnection时，如果连接已经存在（即，如果相同的信号已经连接到同一对对象的同一槽函数），则QObject::connect() 将失败。 这个标志是在 Qt 4.6 中引入的。</p></div></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  &lt;code&gt;Qt&lt;/code&gt;信号与槽...
&lt;/p&gt;</summary>
    
    
    
    <category term="develop" scheme="https://blog.ranbun.com/categories/develop/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="Qt" scheme="https://blog.ranbun.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Bit manipulation</title>
    <link href="https://blog.ranbun.com/2022/07/29/Bit-manipulation/"/>
    <id>https://blog.ranbun.com/2022/07/29/Bit-manipulation/</id>
    <published>2022-07-29T09:24:35.000Z</published>
    <updated>2022-08-21T06:00:10.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将二进制数某一位置0置1取反">将二进制数某一位置0，置1，取反</h3><ul><li>用位运算可以解决我们的问题,所以下面部分的代码就是一些位运算的简单应用</li></ul><span id="more"></span><ul><li>函数实现</li></ul><h4 id="将不同进制数转为二进制非必须---我们只是为了显示结果">1.将不同进制数转为二进制(非必须) - 我们只是为了显示结果</h4><ul><li>模拟人的计算过程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showBinary</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储具体对应的位的值 0 / 1</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 32&gt; num;</span><br><span class="line">    num.fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// 当前转换的Bit位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &amp; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不是零的数 </span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> 1 </span></span><br><span class="line">    <span class="comment">// 此过程可以省略 做了个显示上的优化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; num.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                i == <span class="number">0</span> ? index = i : index = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = index; i &lt; num.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="某一位置为-0">某一位置为 0</h4><ul><li><code>&amp;</code>运算的应用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 某一位设置为 0</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">setBit2Zero</span><span class="params">(T d, <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// 取反是一个只和取反位数以及之后所有位数相关的操作</span></span><br><span class="line">    <span class="comment">// 二进制的位数从0开始计算 所以需要 bits - 1 </span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; (bits(3) - 1) = 4 = 0100 </span></span><br><span class="line">    <span class="comment">// ~4 = 1011</span></span><br><span class="line">    <span class="comment">// &amp; 同为 1 则为 1 =&gt; 1011 &amp; (任意数字) 第三位等于 0</span></span><br><span class="line">    d = d &amp; (~(<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>)));</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="某一位置为-1">某一位置为 1</h4><ul><li><code>|</code> 运算的应用, 只要有一个是1 结果都是1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 某一位设置为 1</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">setBit2One</span><span class="params">(T d, <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// d(16) = 10000 bits = 3</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; bits - 1 == 4 = 0100</span></span><br><span class="line">    <span class="comment">// d | 0100 = 10000 | 0100  = 10100 </span></span><br><span class="line">    d = d | (<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>));</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="某一位置取反">某一位置取反</h4><ul><li><code>^</code> 异或运算的运用<ul><li><code>^</code> 异或运算 1 ^ 0 == 1 / 0 ^ 1 == 1 其余的情况都是0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 某一位取反</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">setBit2Negate</span><span class="params">(T d, <span class="keyword">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// 转换过程</span></span><br><span class="line">    <span class="comment">// ^ 异或运算 1 ^ 0 == 1 / 0 ^ 1 == 1  其余的情况都是 0 </span></span><br><span class="line">    <span class="comment">// d(15) == 1111 bits = 3</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; bits - 1 == 0100</span></span><br><span class="line">    <span class="comment">// 1111</span></span><br><span class="line">    <span class="comment">// 0100 ^</span></span><br><span class="line">    <span class="comment">// 1011 </span></span><br><span class="line">    d = d ^ (<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>));</span><br><span class="line">    BitManipulate::showBinary(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考">参考</h2><ul><li>[1] <ahref="https://gthub.com/Ranbun/blogProjects/tree/main/BitManipulation"title="Github">Github</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;将二进制数某一位置0置1取反&quot;&gt;将二进制数某一位置0，置1，取反&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用位运算可以解决我们的问题,所以下面部分的代码就是一些位运算的简单应用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://blog.ranbun.com/categories/Coding/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>vector dot product</title>
    <link href="https://blog.ranbun.com/2022/07/28/vector-dot-product/"/>
    <id>https://blog.ranbun.com/2022/07/28/vector-dot-product/</id>
    <published>2022-07-27T16:55:14.000Z</published>
    <updated>2022-08-21T05:55:16.206Z</updated>
    
    <content type="html"><![CDATA[<p>  向量的计算...</p><span id="more"></span><h2 id="向量的内积与外积">向量的内积与外积</h2><h3 id="点与点的减法">点与点的减法</h3><ul><li>描述的是起点到终点的运动</li></ul><h3 id="点p与向量veca的加法">点<spanclass="math inline">\({p}\)</span>与向量<spanclass="math inline">\(\vec{a}\)</span>的加法</h3><ul><li>从<span class="math inline">\(P\)</span>出发经过这个向量<spanclass="math inline">\(\vec{a}\)</span>代表的运动，到达一个新的点<spanclass="math inline">\(P_0\)</span></li></ul><h3 id="在此处定义两个向量">在此处定义两个向量</h3><ul><li><span class="math inline">\(\vec{a}\)</span> <spanclass="math display">\[       \vec{a} = \begin{bmatrix}        a_1 \\        a_2 \\        a_3 \\      \end{bmatrix}\]</span></li><li><span class="math inline">\(\vec{b}\)</span> <spanclass="math display">\[      \vec{b} = \begin{bmatrix}      b_1 \\      b_2 \\      b_3 \\    \end{bmatrix}\]</span></li></ul><h3 id="向量点击">向量点击</h3><ul><li>点击(内积)的公式 <span class="math display">\[\vec{a}\cdot\vec{b} =|\vec{a}|\times|\vec{b}|\times \cos \theta \]</span> <spanclass="math display">\[ \vec{a}\cdot\vec{b} = \sum_{i=1}^{n} \left\{ a_i* b_i \right\}\]</span></li><li>点击的几何意义<ul><li><p>其中一个向量在另一个向量上的投影且与点击的顺序无关</p></li><li><span class="math inline">\(\vec{a}\cdot\vec{b} &gt; 0\)</span>方向基本相同，夹角在0°到90°之间</li><li><span class="math inline">\(\vec{a}\cdot\vec{b} = 0\)</span>正交，相互垂直</li><li><span class="math inline">\(\vec{a}\cdot\vec{b} &lt; 0\)</span>方向基本相反，夹角在90°到180°之间</li></ul></li><li>点击的巧用<ul><li>计算向量的模长的平方 <span class="math display">\[|\vec{a}|^2 =\vec{a} \cdot \vec{a} \]</span></li><li>计算两个向量之间的夹角的<spanclass="math inline">\(\cos\theta\)</span> -<imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/weChat/vector/计算两个向量的夹角.png"title="计算两个向量之间的夹角" alt="计算两个向量之间的夹角" /><ul><li>两个单位向量的点击等于他们的夹角的<spanclass="math inline">\(\cos\theta\)</span>的值</li></ul></li><li>两个互相垂直的向量的点击总是为<code>0</code> <spanclass="math inline">\(\theta = 90^0\)</span> <spanclass="math display">\[\vec{a} \cdot \vec{b} = |\vec{a}| \ast |\vec{b}|\ast \cos\theta = 0 \]</span></li><li>一条射线描述的向量[起点 +方向]点击一个平面的法向可以得到起点到平面的距离<br />### 向量叉积</li></ul></li><li>外积公式 <span class="math display">\[    \vec{a} \times \vec{b} =      \begin{bmatrix}      a_2 * b_3 - b_2 * a_3 \\      a_3 * b_1 - b_3 * a_1 \\      a_1 * b_2 - b_1 * a_2 \\    \end{bmatrix}\]</span></li><li>叉积的几何意义<ul><li>几何表达公式 <span class="math display">\[  \vec{a} \times \vec{b} = |\vec{a}| * |\vec{b}| * sin(\theta) * \vec{n}\]</span><ul><li><span class="math inline">\(\vec{n}\)</span> 表示<spanclass="math inline">\(\vec{a}\)</span>, <spanclass="math inline">\(\vec{b}\)</span>所构成平面的法向量方向的单位向量</li></ul></li><li>在二维空间中：叉积得到的向量的模长<spanclass="math inline">\(|\vec{a}\times\vec{b}|\)</span>等于这两个向量<spanclass="math inline">\(\vec{a},\vec{b}\)</span>组成的平行四边形的面积</li></ul></li><li>外积的使用<ul><li>外积的模长则为夹角的正弦（始终为正）</li></ul></li></ul><h3 id="扩展知识">扩展知识</h3><ul><li>扩展 - 1<ul><li>平面上的四个点<span class="math inline">\(P_1\)</span>,<spanclass="math inline">\(P_2\)</span>,<spanclass="math inline">\(P_3\)</span>,<spanclass="math inline">\(P_4\)</span>,分别构成向量 <spanclass="math inline">\(\vec{P_1P_2}\)</span>与<spanclass="math inline">\(\vec{P_3P_4}\)</span>。如何通过点击计算他们交点的坐标?</li><li>下次吧！</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  向量的计算...
&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://blog.ranbun.com/categories/Math/"/>
    
    <category term="linear algebra" scheme="https://blog.ranbun.com/categories/Math/linear-algebra/"/>
    
    
    <category term="vector" scheme="https://blog.ranbun.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令(上)</title>
    <link href="https://blog.ranbun.com/2022/07/24/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8A/"/>
    <id>https://blog.ranbun.com/2022/07/24/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8A/</id>
    <published>2022-07-24T10:25:51.000Z</published>
    <updated>2022-08-21T05:41:14.897Z</updated>
    
    <content type="html"><![CDATA[<p>  Git常用命令...</p><span id="more"></span><h1 id="git常用命令">Git常用命令</h1><h3 id="install-git"><code>install Git</code></h3><ul><li>Git -- <a href="https://git-scm.com/">官方网站</a></li></ul><h3 id="常用命令">常用命令</h3><ul><li><p>安装完成Git之后的操作 - 指定UserName &amp; Email</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  &quot;Your Git UserName&quot;</span><br><span class="line">git config --global user.email &quot;Your Email Address&quot;</span><br></pre></td></tr></table></figure></p><ul><li>一般时候在你安装完成之后需要做一下这个的配置。</li></ul></li><li><p>生成密钥</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen.exe -t rsa</span><br></pre></td></tr></table></figure></p><ul><li><p>命令提示 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/ssh-genkey.png"alt="Image" /></p></li><li><p>然后将你的公钥添加为你所使用的远程管理平台对应SSH Key</p></li></ul></li><li><p>创建本地版本库</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir repositoryDir  &#x2F;&#x2F; 创建本地文件夹</span><br><span class="line">cd    repositoryDir  &#x2F;&#x2F; 进入到文件夹</span><br><span class="line">git   init           &#x2F;&#x2F; 初始化为本地仓库 创建.git目录</span><br></pre></td></tr></table></figure></p></li><li><p>添加文件到本地暂存区&amp;提交文件到本地</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;fileName&quot;       &#x2F;&#x2F; 提交具体的文件 </span><br><span class="line">git add .                &#x2F;&#x2F; 提交所有修改文件</span><br><span class="line">git commit -m  &quot;备注信息&quot; &#x2F;&#x2F; 提交暂存区文件到本地</span><br></pre></td></tr></table></figure></p><ul><li><code>git commit</code> 命令详解 <imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/git-commit.png"alt="git commit" /></li></ul></li><li><p>版本控制</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git log                      &#x2F;&#x2F;查看提交历史记录，从最近到最远，可以看到3次</span><br><span class="line">git log --pretty&#x3D;oneline     &#x2F;&#x2F;加参数，简洁查看</span><br><span class="line">git reflog                   &#x2F;&#x2F;查看每一次修改历史</span><br><span class="line">cat &quot;fileName&quot;                &#x2F;&#x2F;查看文件内容 -- linux 命令</span><br><span class="line">git status                   &#x2F;&#x2F;查看工作区中文件当前状态</span><br><span class="line">git reset --hard HEAD^(HEAD~100)(commit_id)  &#x2F;&#x2F;回退版本</span><br><span class="line">git checkout -- &quot;fileName&quot;         &#x2F;&#x2F;丢弃工作区的修改，即撤销修改</span><br><span class="line">git reset HEAD &quot;fileName&quot;          &#x2F;&#x2F;丢弃暂存区的修改（若已提交，则回退）</span><br></pre></td></tr></table></figure></p></li><li><p>删除文件</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm &quot;filename&quot;   &#x2F;&#x2F; 删除单个文件 </span><br><span class="line">rm -rf *.*      &#x2F;&#x2F; 强制递归删除所有文件</span><br><span class="line">git rm &quot;filename&quot;  &#x2F;&#x2F; 直接删除</span><br><span class="line">&#x2F;&#x2F; 恢复删除的文件</span><br><span class="line">git checkout -- &quot;filename&quot;</span><br></pre></td></tr></table></figure></p></li><li><p>推送到远程的相关命令</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;前面设置的Email&quot;     &#x2F;&#x2F;创建SSH Key 也可以不指定-C与邮件地址</span><br><span class="line">git remote add origin &quot;git的远程仓库地址&quot;  &#x2F;&#x2F;关联远程仓库-源</span><br><span class="line">git push -u origin main                  &#x2F;&#x2F;将本地内容推送到远程-第一次强制推送</span><br><span class="line">git push origin main                     &#x2F;&#x2F;将本地内容推送到远程</span><br><span class="line">git remote -v                            &#x2F;&#x2F;查看远程源信息</span><br><span class="line">git remote rm origin                     &#x2F;&#x2F;删除远程源</span><br><span class="line">git clone &quot;远程仓库地址可以是https的也可以是SSH(此时需要配置密钥)&quot;  &#x2F;&#x2F;克隆远程仓库</span><br><span class="line">git remote                               &#x2F;&#x2F;查看远程库的信息</span><br><span class="line">git remote -v                            &#x2F;&#x2F;查看远程库的详细信</span><br></pre></td></tr></table></figure></p></li><li><p>分支管理</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 老版本的 git命令 </span><br><span class="line">git checkout -b main        &#x2F;&#x2F;创建并切换到分支dev</span><br><span class="line">&#x3D;&#x3D; 如下操作</span><br><span class="line">git branch   feature        &#x2F;&#x2F;创建分支main</span><br><span class="line">git checkout feature        &#x2F;&#x2F;切换到分支feature</span><br><span class="line">git checkout origin&#x2F;main    &#x2F;&#x2F;拉取远程分支并切换</span><br><span class="line">&#x2F;&#x2F; 版本比较新一定的分支管理命令 </span><br><span class="line">git switch -c feature       &#x2F;&#x2F;创建分支feature并切换</span><br><span class="line">git switch main             &#x2F;&#x2F;直接切换到分支main</span><br><span class="line">&#x2F;&#x2F; -----------------------------------------------------------------------</span><br><span class="line">git branch                  &#x2F;&#x2F;查看当前分支</span><br><span class="line">git merge  feature          &#x2F;&#x2F; 合并分支feature到当前分支(记得合并前拉取一下)</span><br><span class="line">git branch -d dev           &#x2F;&#x2F; 删除dev分支 -d 强制删除</span><br></pre></td></tr></table></figure></p></li><li><p>推送到远程</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git push origin main                               &#x2F;&#x2F;推送分支到远程</span><br><span class="line">git checkout -b feature origin&#x2F;feature                     &#x2F;&#x2F;创建远程origin的dev分支到本地</span><br><span class="line">git pull                                           &#x2F;&#x2F;拉取远程分支内容</span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;main main        &#x2F;&#x2F;指定本地与远程dev的链接</span><br><span class="line">&#x2F;&#x2F; 另一种合并操作，相比merge不会产生一次额外的提交</span><br><span class="line">git rebase                                         &#x2F;&#x2F;把本地未push的分叉提交历史整理成直线</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  Git常用命令...
&lt;/p&gt;</summary>
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="SCU" scheme="https://blog.ranbun.com/categories/works/SCU/"/>
    
    <category term="Git" scheme="https://blog.ranbun.com/categories/works/SCU/Git/"/>
    
    
    <category term="Git" scheme="https://blog.ranbun.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>微信多开</title>
    <link href="https://blog.ranbun.com/2022/02/28/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/"/>
    <id>https://blog.ranbun.com/2022/02/28/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/</id>
    <published>2022-02-28T14:11:02.000Z</published>
    <updated>2022-08-21T05:57:20.470Z</updated>
    
    <content type="html"><![CDATA[<p>  Windows使用小技巧...</p><span id="more"></span><h2 id="微信多开的小技巧---windows">微信多开的小技巧 - Windows</h2><ul><li><p>首先，需要你知道你机器上安装微信 - 请记录它的安装位置</p></li><li><p>一般情况下，如果你不做任何修改的话，它会在<code>C:\Program Files (x86)\Tencent\WeChat</code>这个目录下：   <imgsrc="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png"title="微信安装位置" /></p></li><li><p>然后，打开你机器上任意的一个文本编辑器，输入如下内容：</p></li><li><p>需要多开多少个微信，你便将如下命令输入重复写多少次。</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start D:\&quot;Program Files (x86)<span class="string">&quot;\Tencent\WeChat\WeChat.exe</span></span><br><span class="line"><span class="string">start D:\&quot;Program Files (x86)&quot;</span>\Tencent\WeChat\WeChat.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将上面的路径换成你机器上安装微信的路径</span></span><br><span class="line"><span class="comment"># 上面表示的是同时开两个微信程序</span></span><br><span class="line"><span class="comment"># 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li><li><p>然后将文件保存，文件后缀为<code>.bat</code>,这是<code>cmd</code>识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。</p><p><imgsrc="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png"title="微信多开效果图" /></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  Windows使用小技巧...
&lt;/p&gt;</summary>
    
    
    
    <category term="Tips" scheme="https://blog.ranbun.com/categories/Tips/"/>
    
    
    <category term="windows" scheme="https://blog.ranbun.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>渲染(CAD)</title>
    <link href="https://blog.ranbun.com/2022/01/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95_CAD%E6%B8%B2%E6%9F%93/"/>
    <id>https://blog.ranbun.com/2022/01/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95_CAD%E6%B8%B2%E6%9F%93/</id>
    <published>2022-01-15T16:51:02.000Z</published>
    <updated>2022-08-21T05:57:03.575Z</updated>
    
    <content type="html"><![CDATA[<p>  一次面试的记录...</p><span id="more"></span><h2 id="记一次面试">记一次面试:</h2><p>  距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了.......  这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是<code>CAD</code>方向，大概都是渲染相关的，所以还是符合我的预期。</p><h2 id="start-interview">Start Interview:</h2><ul><li>首先这是一个<code>Cpp</code>&amp;<code>图形</code>的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是<code>CPP</code>和<code>图形学</code>开发经验,可以预见大概的问题就是<code>Cpp</code>和图形相关的知识。</li></ul><hr /><h3 id="第一次面试">第一次面试</h3><h4 id="关于简历中提到的之前的项目">关于简历中提到的之前的项目</h4><ul><li>部分和之前项目相关的问题</li><li>一些技术上的解决方案</li><li>......</li></ul><h4 id="cpp的新的语言特性">CPP的新的语言特性</h4><ul><li><code>C++11</code>的新语言特性 - 比较常用的<ul><li>智能指针</li><li><code>auto</code>自动类型推导</li><li>标准库的多线程</li><li><code>lambda</code>表达式</li></ul></li><li>一些指针和引用相关的问题<ul><li>指针是什么？</li><li>引用是什么？</li><li>两者的区别？</li><li>内存分区的相关问题，如：<ul><li>常量在程序中的的存储位置</li><li>静态变量在什么位置</li><li>......</li></ul></li></ul></li></ul><h4 id="图形相关的问题">图形相关的问题</h4><ul><li>图形管线的问题<ul><li>坐标变换相关的问题<ul><li>投影</li><li>视图</li></ul></li></ul></li><li>一些渲染上面的解决方案<ul><li>大数据量的绘制</li></ul></li></ul><h3 id="第二次面试">第二次面试</h3><p>  第二次面试倒是没有什么技术相关的问题，两个老师，一个人事，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：</p><ul><li>个人介绍<ul><li>基本信息</li><li>求学经历</li><li>......</li></ul></li><li>工作经历<ul><li>项目经历</li></ul></li><li>未来的规划<ul><li>职业规划</li><li>个人规划</li></ul></li><li>个人爱好</li></ul><p> .......</p><p>  后面部分就是关于这个介绍的提问了，无关痛痒。</p><p>  一周以后......，在我以为黄了的时候，竟然通过了。</p><p>  感谢！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  一次面试的记录...
&lt;/p&gt;</summary>
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="interview" scheme="https://blog.ranbun.com/categories/works/interview/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="openGL" scheme="https://blog.ranbun.com/tags/openGL/"/>
    
    <category term="computer graphics" scheme="https://blog.ranbun.com/tags/computer-graphics/"/>
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="https://blog.ranbun.com/2022/01/16/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.ranbun.com/2022/01/16/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-01-15T16:43:19.000Z</published>
    <updated>2022-08-21T05:56:40.151Z</updated>
    
    <content type="html"><![CDATA[<p>  毕业后的第一年，我开始了自己的苟且与悲歌...</p><span id="more"></span><h3 id="我起伏的2021年">我起伏的2021年:</h3><ul><li>2021年鸡毛蒜皮</li></ul><p>....</p><h3 id="我的关于2021年的大事件">我的关于2021年的大事件：</h3><h4 id="换了工作">1、换了工作</h4><h4 id="离开了那个度过了五年的城市">2、离开了那个度过了五年的城市</h4><h4 id="换了工作的城市">3、 换了工作的城市</h4><h4 id="告别了好友">4、告别了好友</h4><h4 id="见了阔怕已久的朋友">5、见了阔怕已久的朋友</h4><h4 id="又一次决定换工作">6、又一次决定换工作</h4><ul><li>面试了一个环境可能更好的工作</li></ul><h3 id="一我换工作这件事">一、我换工作这件事</h3><p>先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。</p><p>  离开我的上一个岗位的原因颇多,当然究其原因，我觉得<code>马老板</code>说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。  新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。</p><h3 id="二离开济南">二、离开济南</h3><p>  我在这个城市上大学，大学毕业在这里找的工作，也是在这里，度过了我和我对象为期6年的异地恋。  若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息......  我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以<code>成都</code>应该是个不错的选择，我开始面试，将目标公司地域选到了成都.....  然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。  然后我来了<code>北京</code>.....,只能说，造化弄人。</p><h3 id="三告别好友">三、告别好友</h3><p>  我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的<code>二哥</code>还有<code>杨哥</code>,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。  从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。</p><h3 id="四见了好久不见的朋友">四、见了好久不见的朋友</h3><p>  2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。  有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。  同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。</p><h3 id="五又一次决定换工作">五、又一次决定换工作</h3><p>  决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。  又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  毕业后的第一年，我开始了自己的苟且与悲歌...
&lt;/p&gt;</summary>
    
    
    
    <category term="bun" scheme="https://blog.ranbun.com/categories/bun/"/>
    
    <category term="life" scheme="https://blog.ranbun.com/categories/bun/life/"/>
    
    
    <category term="mylife" scheme="https://blog.ranbun.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>Games202-ShadowMap</title>
    <link href="https://blog.ranbun.com/2021/12/13/Games202-ShadowMap/"/>
    <id>https://blog.ranbun.com/2021/12/13/Games202-ShadowMap/</id>
    <published>2021-12-13T14:25:25.000Z</published>
    <updated>2022-08-21T05:40:07.556Z</updated>
    
    <content type="html"><![CDATA[<p>  你该如何渲染阴影...</p><span id="more"></span><h2 id="shadow-map">Shadow Map</h2><ul><li>记录一下关于<code>Games202</code>的学习</li></ul><h4 id="shadow-map-1">shadow map</h4><ul><li><p>实现：通过比较当前的<code>point</code>,在光源空间的的深度与深度图中记录的深度的大小，决定当前的<code>point</code>是否在阴影中</p></li><li><p>如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：</p><p><imgsrc="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png" /></p></li></ul><p>上图来自<code>Games202</code>的课件：</p><ul><li><p>阴影图<code>shadow map</code>记录了相机在光照位置下的最近最近深度。</p></li><li><p>关于计算当前vertex point是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-<code>lightPVM</code>)，用于将顶点转换到光空间。</p></li><li><p>在<code>Games202</code>的作业1中，我们需要使用提供的matrix的接口处理矩阵。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mat.translate() <span class="comment">// 设置矩阵的移动 </span></span><br><span class="line">mat4.scale      <span class="comment">// 设置矩阵的缩放</span></span><br><span class="line"></span><br><span class="line">mat4.lookAt(); <span class="comment">// 生成的视图矩阵</span></span><br><span class="line">mat4.ortho();  <span class="comment">// 平行投影</span></span><br><span class="line"></span><br><span class="line">mat4.multiply(); <span class="comment">// 矩阵的乘法</span></span><br></pre></td></tr></table></figure><p><ahref="https://www.icode9.com/content-4-956693.html">gl-matrix文档</a></p></li><li><p>深度比较：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sampler2D</span> shadowMap;   <span class="comment">// 你的深度图</span></span><br><span class="line"><span class="type">mat4</span> lightPVM;         <span class="comment">// 光空间的变换矩阵</span></span><br><span class="line"><span class="type">vec4</span> vertexPosition;   <span class="comment">// 渲染的顶点坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1： 将顶点变换到光空间 </span></span><br><span class="line"><span class="type">vec4</span> vertex_light = lightPVM * vertexPosition;</span><br><span class="line"><span class="comment">// 2: 透视除法将顶点变换到NDC坐标</span></span><br><span class="line"><span class="type">vec3</span> ndc_pos = vertex_light.xyz / vertex_light.w;</span><br><span class="line"><span class="comment">// 3: 将深度变到 0-1</span></span><br><span class="line">ndc_pos = ndc_pos * <span class="number">0.5</span> + <span class="number">0.5</span>；</span><br><span class="line"><span class="comment">// 4：获取深度图中记录的深度</span></span><br><span class="line"><span class="comment">// 5: 获取当前点在光空间下的实际深度</span></span><br><span class="line"><span class="comment">// 6: 比较两个深度的大小    </span></span><br><span class="line"><span class="comment">// 7：返回当前点是否在阴影中    </span></span><br></pre></td></tr></table></figure></li><li><p>最终效果</p></li></ul><p><imgsrc="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  你该如何渲染阴影...
&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    
    <category term="Games202" scheme="https://blog.ranbun.com/tags/Games202/"/>
    
    <category term="Shadow" scheme="https://blog.ranbun.com/tags/Shadow/"/>
    
  </entry>
  
  <entry>
    <title>Multi KeyWord Sort</title>
    <link href="https://blog.ranbun.com/2021/11/07/Multi-KeyWord-Sort/"/>
    <id>https://blog.ranbun.com/2021/11/07/Multi-KeyWord-Sort/</id>
    <published>2021-11-07T14:18:51.000Z</published>
    <updated>2022-08-21T05:43:14.124Z</updated>
    
    <content type="html"><![CDATA[<p>  多关键字排序...</p><span id="more"></span><h3 id="多关键字排序">多关键字排序</h3><ul><li><p>扑克牌的例子</p></li><li><p>一副扑克牌是按照两种顺序排的：</p><ul><li>K0,花色：梅花 &lt; 方块 &lt; 红桃 &lt; 黑桃</li><li>k1，面值: 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10&lt; J &lt; Q &lt; K &lt; A</li></ul></li><li><p>主位优先：（Most Significant Digit）</p><ul><li>先用四个花色建桶，然后使用面值建桶</li></ul></li></ul><h4 id="一个更好的方法">一个更好的方法：</h4><ul><li><p>依旧使用次位优先：</p><ul><li><p>先使用面值建桶</p></li><li><p>然后按照大小将结果合并，使用花色建桶。</p></li><li><p>最终的输出结果便是有序的</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;
  多关键字排序...
&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="sort" scheme="https://blog.ranbun.com/tags/sort/"/>
    
  </entry>
  
</feed>
